在 MySQL 存储过程中，**游标（Cursor）** 是处理多行数据的核心工具。

你可以把它想象成一个**“指针”**或**“迭代器”**。

普通的 SQL 语句（如 `SELECT`）是**面向集合**的，一次性处理一批数据；而存储过程中的逻辑通常是**面向过程**的，需要一行一行地处理。游标就是这两者之间的桥梁：**它允许你从查询结果集中，一次只拿出一行数据，交给程序处理，处理完再拿下一行。**

---

### 一、 游标的“生命周期” (4 步曲)

使用游标必须严格遵循这 4 个步骤，顺序不能乱：

1. **声明 (DECLARE)**：定义游标，告诉 MySQL 这个游标对应哪条 `SELECT` 查询。
    
2. **打开 (OPEN)**：执行查询，将数据加载到内存（或者建立结果集链接），让指针指向第一行之前。
    
3. **获取 (FETCH)**：把当前行的字段值“赋值”给变量，并将指针下移一行。
    
4. **关闭 (CLOSE)**：用完了必须关闭，释放内存资源。
    

---

### 二、 标准代码模板 (背下来！)

这是游标最标准的写法，包含了**变量声明**、**Handler 处理**、**循环**和**退出机制**。

**场景**：遍历 `users` 表，把所有用户名拼接成一个长字符串。


```SQL
DELIMITER //

CREATE PROCEDURE loop_users_cursor()
BEGIN
    -- 1. 【变量声明】(必须在最前面)
    DECLARE done INT DEFAULT 0;   -- 用于标记是否遍历结束
    DECLARE u_name VARCHAR(50);   -- 用于暂存每一行的用户名
    DECLARE result_str TEXT DEFAULT '';
    
    -- 2. 【声明游标】(指定要遍历的数据源)
    DECLARE my_cursor CURSOR FOR SELECT name FROM users;
    
    -- 3. 【声明 Handler】(关键一步！)
    -- 当 FETCH 拿不到数据时(报 NOT FOUND 错误)，自动把 done 设为 1
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = 1;
    
    -- 4. 【打开游标】
    OPEN my_cursor;
    
    -- 5. 【循环获取】
    read_loop: LOOP
        -- 拿一行数据，存入变量 u_name
        FETCH my_cursor INTO u_name;
        
        -- 【非常重要】判断是否结束
        -- 必须在 FETCH 之后立刻判断，否则最后一行会被多处理一次
        IF done = 1 THEN
            LEAVE read_loop;
        END IF;
        
        -- 业务逻辑：拼接字符串
        SET result_str = CONCAT(result_str, u_name, ',');
        
    END LOOP;
    
    -- 6. 【关闭游标】
    CLOSE my_cursor;
    
    -- 输出结果
    SELECT result_str;
END //

DELIMITER ;
```

假设我们有一张 `users` 表，里面有 `id` (整数), `name` (字符串), `age` (整数)。我们要同时把这三列都取出来。


```SQL
DELIMITER //

CREATE PROCEDURE fetch_multi_columns()
BEGIN
    -- 1. 先准备好 3 个“碗”（变量），对应表的 3 列
    DECLARE v_id INT;           -- 对应 id
    DECLARE v_name VARCHAR(50); -- 对应 name
    DECLARE v_age INT;          -- 对应 age
    
    DECLARE done INT DEFAULT 0;
    
    -- 2. 声明游标：这里 SELECT 了 3 列
    DECLARE my_cursor CURSOR FOR 
        SELECT id, name, age FROM users; 
    
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = 1;
    
    OPEN my_cursor;
    
    read_loop: LOOP
        -- 3. 【关键步骤】FETCH 的时候，变量要有 3 个，且顺序必须对齐
        -- id -> v_id
        -- name -> v_name
        -- age -> v_age
        FETCH my_cursor INTO v_id, v_name, v_age;
        
        IF done = 1 THEN
            LEAVE read_loop;
        END IF;
        
        -- 此时，v_id, v_name, v_age 里都存着当前这一行的数据了
        -- 你可以拿它们做任何逻辑处理
        -- 比如：SELECT v_id, v_name, v_age;
        
    END LOOP;
    
    CLOSE my_cursor;
END //

DELIMITER ;
```

---

### 三、 深度解析关键点

#### 1. `FETCH` 的映射关系

`FETCH cursor_name INTO var1, var2;`

- 游标 `SELECT` 查出来有几列，`INTO` 后面就必须跟几个变量。
    
- 顺序必须一一对应（类型也要兼容）。
    

#### 2. 为什么需要 `HANDLER`？

MySQL 的游标不像 Java 的 `Iterator.hasNext()` 那样方便。 当你执行 `FETCH` 但后面已经没有数据时，MySQL 会**抛出一个 Error**（SQLSTATE '02000', 即 NOT FOUND）。 如果不定义 Handler，程序会报错停止。所以我们利用 Handler **捕获这个错误**，将其转化为一个逻辑标志（`done = 1`），从而优雅地退出循环。

#### 3. 声明顺序的“死规定”

在 `BEGIN` 块中，声明的顺序是**强制**的，写反了直接报错：

1. **变量** (`DECLARE var ...`)
    
2. **条件** (`DECLARE condition ...`)
    
3. **游标** (`DECLARE cursor ...`)
    
4. **处理程序** (`DECLARE handler ...`)
    

_(记忆口诀：变 -> 条 -> 游 -> 处)_

---

### 四、 游标的特性与限制

- **只读 (Read Only)**：MySQL 的游标主要用于读取数据。你不能直接通过游标去更新当前行（虽然 SQL 标准支持 `WHERE CURRENT OF`，但 MySQL 实现得不完整，通常建议用主键去单独执行 UPDATE）。
    
- **不可滚动 (Non-Scrollable)**：只能**从头到尾**顺序读取。不能回退（没有 `PREVIOUS`），不能跳跃（没有 `ABSOLUTE`）。如果想重新遍历，必须先 `CLOSE` 再 `OPEN`。
    
- **敏感性 (Asensitive)**：MySQL 游标通常指向的是实际数据或临时表。在游标打开期间，如果原表数据被其他事务修改了，游标读到的数据可能会变，也可能不变（取决于存储引擎和结果集大小）。
    

---

### 五、 什么时候该用游标？

**能不用，最好不用。**

- **性能警告**：游标的效率远低于纯 SQL 集合操作（Set-based operations）。
    
- **推荐场景**：
    
    - 当你需要对每一行数据进行极度复杂的计算，无法用单一 SQL 写出时。
        
    - 当你需要调用其他存储过程来处理每一行数据时。
        
    - 跨表、跨库的复杂逻辑迁移或清洗脚本。
        

**如果可以用 `UPDATE users SET score = score + 10 WHERE ...` 搞定，千万不要写个游标去一行行加。**