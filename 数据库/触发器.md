### 一、 什么是触发器？（核心概念）

你可以把触发器想象成数据库里的**“隐形哨兵”**或**“绊雷”**。

- **普通 SQL**：你需要手动执行（比如你点一下运行，或者代码调一次接口）。
    
- **触发器**：**被动触发**。它潜伏在某张表上，一旦这张表发生了特定的动作（增、删、改），它就会瞬间自动“爆炸”（执行预定义的逻辑）。
    

**它的核心作用只有两个：**

1. **数据校验/修正**（在写入前拦截）。
    
2. **自动化联动**（在写入后，自动去更新别的表或记录日志）。
    

---

### 二、 触发器的“六大要素”

在写代码前，你必须先在脑子里想清楚这 6 个空怎么填：

1. **监视地点**：哪张表？(`ON table_name`)
    
2. **监视事件**：什么动作？(`INSERT`, `UPDATE`, `DELETE`)
    
3. **触发时机**：动作发生前还是后？(`BEFORE`, `AFTER`)
    
4. **触发频率**：MySQL 目前只支持“行级触发”（`FOR EACH ROW`）。即：你一条 SQL 修改了 100 行数据，触发器就会执行 100 次。
    

---

### 三、 语法解构（手把手写）

标准语法结构如下：

```SQL
DELIMITER //

CREATE TRIGGER 触发器名字
[BEFORE | AFTER]  -- 1. 时机
[INSERT | UPDATE | DELETE] -- 2. 事件
ON 表名 -- 3. 监视谁
FOR EACH ROW -- 4. 固定写法
BEGIN
    -- 5. 这里写你的业务逻辑
    -- 可以是 INSERT, UPDATE, IF 判断等
END //

DELIMITER ;
```

---

### 四、 灵魂核心：`NEW` 和 `OLD` 对象（最重要！）

这是触发器里最关键的概念。因为触发器是自动执行的，你没法传参数给它。那它怎么知道你修改了什么数据？

MySQL 提供了两个临时的“虚拟行”对象：**`NEW`** 和 **`OLD`**。

|**触发事件**|**OLD 对象**|**NEW 对象**|**解释**|
|---|---|---|---|
|**INSERT**|❌ 不存在|✅ **有效**|插入是无中生有，只有新数据 (`NEW`)。|
|**UPDATE**|✅ **有效**|✅ **有效**|修改有前有后。`OLD` 是改之前的旧值，`NEW` 是改之后打算存的新值。|
|**DELETE**|✅ **有效**|❌ 不存在|删除是销毁，只有临死前的数据 (`OLD`)，没有新数据。|

> **口诀**：引用列值时，用 `NEW.列名` 或 `OLD.列名`。

---

### 五、 实战场景教学

为了让你学会，我们用三个最经典的场景来演练。

#### 场景 1：数据校验（BEFORE INSERT）

**需求**：在员工表 `employees` 插入数据前，强制检查工资。如果工资低于 3000，自动修正为 3000（类似于强制低保）。


```SQL
DELIMITER //

CREATE TRIGGER check_salary_before_insert
BEFORE INSERT ON employees
FOR EACH ROW
BEGIN
    -- 检测准备插入的 salary (NEW.salary)
    IF NEW.salary < 3000 THEN
        SET NEW.salary = 3000; -- 直接篡改即将入库的数据
    END IF;
END //

DELIMITER ;
```

- **解析**：这里必须用 `BEFORE`。如果在 `AFTER` 就晚了，数据已经进磁盘了，你再 `SET NEW` 是没用的。
    

#### 场景 2：数据审计日志（AFTER UPDATE）

**需求**：每当商品表 `products` 的价格发生变化时，自动把“旧价格、新价格、修改时间”记录到 `price_logs` 表里，留作证据。


```SQL
DELIMITER //

CREATE TRIGGER log_price_change
AFTER UPDATE ON products
FOR EACH ROW
BEGIN
    -- 只有价格真变了才记录
    IF OLD.price != NEW.price THEN
        INSERT INTO price_logs(product_id, old_price, new_price, change_time)
        VALUES(OLD.id, OLD.price, NEW.price, NOW());
    END IF;
END //

DELIMITER ;
```

- **解析**：这里用 `AFTER` 更好，确保数据真的更新成功了再记日志。同时展示了 `OLD`（过去的值）和 `NEW`（现在的值）的混用。
    

#### 场景 3：级联统计（AFTER DELETE）

**需求**：当有人从 `orders` 订单表中删除订单时，自动扣减 `users` 表里该用户的“订单总数”字段。


```SQL
DELIMITER //

CREATE TRIGGER decrease_user_order_count
AFTER DELETE ON orders
FOR EACH ROW
BEGIN
    -- 既然删除了，就要引用被删掉的那行数据，所以用 OLD
    UPDATE users 
    SET order_count = order_count - 1 
    WHERE id = OLD.user_id; -- 找到那个倒霉的用户
END //

DELIMITER ;
```
**增加**
```SQL
delimiter //
create trigger increase_user_order_count
after insert on orders
for each row
begin 
	update users
	SET order_count = order_count +1
	where id = NEW.user_id;
end //
delimiter ;
```

---

### 六、 触发器的管理

- **查看触发器**：
    
    SQL
    
    ```
    SHOW TRIGGERS;
    -- 或者
    SHOW CREATE TRIGGER 触发器名;
    ```
    
- **删除触发器**：
    
    SQL
    
    ```
    DROP TRIGGER [IF EXISTS] 触发器名;
    ```
    
    _注意：修改触发器很麻烦，通常是先 DROP 再重新 CREATE。_
    

---

### 七、 工程师的肺腑之言：慎用触发器！

学会了触发器，你可能会觉得它太好用了，想到处用。**请打住！**

在很多互联网大厂的开发规范（如阿里巴巴 Java 开发手册）中，是**禁止使用存储过程和触发器**的。为什么？

1. **逻辑隐形，调试地狱**：
    
    - 新人接手项目，发现更新了一行数据，结果数据库里多了五条莫名其妙的记录。他要查 Java 代码查半死，最后才发现是数据库里藏了个触发器。触发器对应用层代码是**不可见**的。
        
2. **性能杀手**：
    
    - MySQL 的触发器是同步阻塞的。如果你的 `AFTER UPDATE` 触发器里写了个复杂的 SQL（比如还要去查别的表），那么原本 10ms 的更新操作可能会被拖慢到 100ms，导致主业务卡顿。
        
3. **死锁风险**：
    
    - 触发器会扩大事务的范围，持有锁的时间变长，容易引发高并发下的死锁。
        

**总结建议**：

- **什么时候用？** 数据一致性要求极高、且无法在应用层（Java/Python）控制的场景；或者是做简单的数据归档。
    
- **怎么学？** 掌握 `NEW`/`OLD` 的用法，理解 `BEFORE`/`AFTER` 的区别，你就已经出师了。


-----
**查看触发器**
```SQL
show trigger;

show create trigger 触发器名;

select * from information_schema.TRIGGERS;
```

**删除触发器**
```SQL
drop trigger if exists 触发器名；
```