
## 定义条件与处理程序

**定义条件是事先定义程序运行过程中可能遇到的问题，处理程序定义了遇到错误时的执行程序**

```SQL
declare 错误名称 condition for 错误码(或者错误条件)；
```

错误码：
### 一、 错误码的结构

当 MySQL 报错时，它通常会返回三个信息：

1. **MySQL Error Code (数值)**：MySQL 特有的错误标识，通常是 4 位数字。
    
    - _特点_：不仅包含标准 SQL 错误，还包含 MySQL 特有的存储引擎错误（如 InnoDB 特定错误）。
        
    - _示例_：`1062`
        
2. **SQLSTATE (字符串)**：ANSI SQL 标准定义的 5 位字符串。
    
    - _特点_：跨数据库通用（Oracle, PostgreSQL, DB2 通常通用）。
        
    - _示例_：`'23000'`
        
3. **Message (文本)**：人类可读的错误描述。
    

> 在存储过程中的应用：
> 
> 正如我们之前讨论的 DECLARE HANDLER，你可以用数值（FOR 1062）或者 SQLSTATE（FOR SQLSTATE '23000'）来捕获错误。推荐优先使用 SQLSTATE，因为它更具移植性。

---

### 二、 错误码的分类范围

MySQL 的错误码大致按照数字范围进行分类：

|**范围**|**类别**|**说明**|
|---|---|---|
|**1000 - 1999**|**服务端错误**|SQL 语法错误、表不存在、约束冲突、死锁等。这是开发中最常见的。|
|**2000 - 2999**|**客户端/连接错误**|无法连接服务器、连接超时、协议不匹配等。通常是网络或配置问题。|
|**3000 - 4999**|**特定组件错误**|涉及 NDB 集群、特定的插件或较新的功能模块。|
|**5000+**|**其他**|自定义错误或非常具体的内部错误。|

---

### 三、 开发者必知必会的 Top 10 错误码

这是你在日志中最常看见的“老朋友”，建议熟记：

|**错误码 (Errno)**|**SQLSTATE**|**错误名称**|**典型原因与解决方案**|
|---|---|---|---|
|**1064**|42000|Parse Error|**SQL 语法错误**。拼写错误，或者用了保留字没加反引号。检查 SQL 拼写。|
|**1062**|23000|Duplicate Entry|**唯一键冲突**。试图插入重复的主键或唯一索引值。检查数据或使用 `INSERT IGNORE`。|
|**1045**|28000|Access Denied|**密码或权限错误**。用户名密码不对，或者该用户没有从当前 IP 登录的权限。|
|**1054**|42S22|Unknown Column|**字段不存在**。SELECT 了一个表里没有的列，或者拼写错误。|
|**1146**|42S02|Table Doesn't Exist|**表不存在**。表名写错，或者数据库选错了。|
|**1213**|40001|Deadlock Found|**死锁**。两个事务互相持有锁。业务层通常需要捕获此错误并重试。|
|**1205**|HY000|Lock Wait Timeout|**锁等待超时**。一个事务占着锁太久没提交，导致你的 SQL 等不到锁。|
|**1451 / 1452**|23000|Foreign Key Error|**外键约束失败**。试图删除父表数据但子表有引用（1451），或插入子表数据但父表没对应ID（1452）。|
|**2002**|HY000|Connection Refused|**无法连接**。MySQL 服务没启动，或者 socket 文件路径不对，或者防火墙拦截。|
|**2006**|HY000|Server Has Gone Away|**连接断开**。SQL 语句太长超过了 `max_allowed_packet`，或者连接超时被服务端踢了。|

---

### 四、 如何快速查询错误码含义？

#### 1. 使用命令行工具 `perror` (最快)

MySQL 自带了一个极其好用的终端工具叫 `perror`。你不需要查文档，直接在 Linux/Windows 命令行输入：


```Bash
$ perror 1062
MySQL error code 1062 (ER_DUP_ENTRY): Duplicate entry '%-.192s' for key %d

$ perror 13
OS error code  13:  Permission denied
```

_注：它不仅能查 MySQL 错误码，还能查操作系统的错误码（如 13 代表权限不足）。_

#### 2. 在 MySQL 客户端中查看

如果你刚执行了一条语句报错了，想看详细信息：


```SQL
SHOW ERRORS;
SHOW WARNINGS; -- 即使没报错，也可以看警告
```

### 五、 错误码与存储过程处理程序的结合

回到您之前关于**处理程序（Handler）**的问题，错误码是 Handler 的“触发器”。

**示例：如何优雅地处理“死锁” (1213)**


```SQL
DECLARE EXIT HANDLER FOR 1213
BEGIN
    ROLLBACK;
    -- 这里可以记录日志，或者返回一个特定的状态码让应用层重试
    SELECT 'Transaction failed due to Deadlock, please retry.' AS msg;
END;
```

**总结建议：**

- **开发阶段**：重点关注 **1064 (语法)** 和 **1054 (字段错误)**。
    
- **上线后监控**：重点监控 **1213 (死锁)**、**1205 (锁超时)** 和 **1062 (主键冲突)**，这些往往意味着业务逻辑或并发设计有问题。

---
### 定义处理程序
```SQL
declare 处理方式 handler for 错误类型 处理语句;
```
### 一、 处理方式 (Handler Action)

这里决定了当错误被捕获并执行完“处理语句”后，程序的**下一步去向**。MySQL 支持以下 **2 种**：

|**处理方式**|**关键词**|**行为逻辑**|**适用场景**|
|---|---|---|---|
|**继续执行**|**`CONTINUE`**|捕获错误 -> 执行处理语句 -> **返回到出错行的下一行**继续执行后续代码。|适用于非致命错误，例如“主键重复时忽略该条并继续插入下一条”。|
|**立即退出**|**`EXIT`**|捕获错误 -> 执行处理语句 -> **立即跳出当前的 `BEGIN...END` 代码块**。|适用于致命错误，例如“数据严重校验失败”或“关键表不存在”，必须立刻停止业务。|

_(注：标准 SQL 中还有 `UNDO`，但 MySQL 目前不支持)_

---

### 二、 错误类型 (Condition Value)

这里定义了“什么情况”会触发这个处理器。由**具体到宽泛**，共有 **6 种**写法：

#### 1. 精确匹配（针对特定错误）

- **MySQL 数值错误码 (MySQL Error Code)**
    
    - **写法**：直接写数字，如 `1062`。
        
    - **说明**：这是 MySQL 独有的错误编号。
        
    - _例子_：`DECLARE CONTINUE HANDLER FOR 1062 ...` (针对主键冲突)。
        
- **SQLSTATE 字符串**
    
    - **写法**：`SQLSTATE '字符串'`，如 `SQLSTATE '23000'`。
        
    - **说明**：ANSI SQL 标准定义的错误码，跨数据库通用性更好（推荐）。
        
    - _例子_：`DECLARE CONTINUE HANDLER FOR SQLSTATE '23000' ...` (也是针对完整性约束违反)。
        
- **命名条件 (Condition Name)**
    
    - **写法**：先用 `DECLARE ... CONDITION` 定义的名字。
        
    - **说明**：为了让代码更好读，给上面的数字或字符串起个“别名”。
        
    - _例子_：
        
        SQL
        
        ```
        DECLARE dup_key CONDITION FOR 1062;
        DECLARE CONTINUE HANDLER FOR dup_key ...;
        ```
        

#### 2. 宽泛匹配（针对一类错误）

如果不想针对每个错误单独写处理逻辑，可以使用以下**三大预定义类别**：

- **`SQLWARNING`**
    
    - **范围**：捕获所有以 `01` 开头的 SQLSTATE 代码。
        
    - **含义**：警告类信息（如 `DATA TRUNCATED` 数据被截断）。
        
- **`NOT FOUND`**
    
    - **范围**：捕获所有以 `02` 开头的 SQLSTATE 代码。
        
    - **含义**：通常指**游标（Cursor）遍历结束**，或者 `SELECT ... INTO` 没查到数据。
        
    - _最常用场景_：`DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = 1;` (用于结束循环)。
        
- **`SQLEXCEPTION`**
    
    - **范围**：捕获所有**除了** `SQLWARNING` 和 `NOT FOUND` 之外的错误。
        
    - **含义**：这是**兜底（Catch-All）**选项，捕获大部分通用错误（如语法错误、约束冲突、表不存在等）。
        

---

### 三、 组合使用示例

假设我们有一个存储过程，结合了多种用法：

SQL

```
BEGIN
    -- 1. 针对“游标读完”的情况：继续执行，并将标志位设为1
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = 1;

    -- 2. 针对“主键重复 (1062)”：继续执行，并记录一个日志变量
    DECLARE CONTINUE HANDLER FOR 1062 SELECT 'Duplicate key ignored' INTO log_msg;

    -- 3. 针对“其它严重错误”：立即退出，并回滚事务
    DECLARE EXIT HANDLER FOR SQLEXCEPTION 
    BEGIN
        ROLLBACK;
        SELECT 'Critical Error Occurred' AS msg;
    END;

    -- ... 业务代码 ...
END
```

### 总结建议

1. **优先级规则**：如果同时定义了精确匹配（如 `1062`）和宽泛匹配（如 `SQLEXCEPTION`），MySQL 会优先选择**最精确**的那个处理器。
    
2. **开发习惯**：
    
    - 用 `NOT FOUND` 处理游标结束。
        
    - 用 `SQLEXCEPTION` 做最后的安全网（防崩溃）。
        
    - 尽量使用 `SQLSTATE` 而不是数值错误码，因为数值错误码在不同 MySQL 版本间可能会有细微变化，而 SQLSTATE 更稳定。