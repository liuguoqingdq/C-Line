## 1. 存储函数 vs. 存储过程

在深入语法之前，首先要明确两者之间的核心区别，以确保你在正确的场景使用它。

| **特性**     | **存储函数 (Function)**           | **存储过程 (Procedure)**          |
| ---------- | ----------------------------- | ----------------------------- |
| **返回值**    | **必须**返回一个且仅一个值               | 可以通过 `OUT` 参数返回多个值，或不返回       |
| **调用方式**   | 像变量一样调用：`SELECT func()`       | 使用 `CALL` 关键字调用：`CALL proc()` |
| **SQL 嵌入** | **可以**嵌入在 SQL 语句中（如 `SELECT`） | **不可以**，必须独立调用                |
| **参数类型**   | 只有输入参数（默认为 `IN`）              | 支持 `IN`, `OUT`, `INOUT`       |
| **主要用途**   | 用于计算、格式化、逻辑转换                 | 用于业务逻辑封装、批处理操作                |

| **特性关键字**               | **含义**                             | **备注**                     |
| ----------------------- | ---------------------------------- | -------------------------- |
| **`CONTAINS SQL`**      | **包含 SQL**。子程序包含 SQL 语句，但不读取或写入数据。 | **默认值**。例如：`SET @x = 1;`   |
| **`NO SQL`**            | **不包含 SQL**。子程序中完全没有 SQL 语句。       | 例如：纯数学运算。                  |
| **`READS SQL DATA`**    | **读取 SQL 数据**。子程序包含从表中读取数据的语句。     | 例如：包含 `SELECT`。            |
| **`MODIFIES SQL DATA`** | **修改 SQL 数据**。子程序包含修改表中数据的语句。      | 例如：包含 `INSERT` 或 `UPDATE`。 |

---

## 2. 基本语法

创建存储函数的基本结构如下：


```SQL
DELIMITER //

CREATE FUNCTION 函数名(参数名1 数据类型, 参数名2 数据类型, ...)
RETURNS 返回值类型
[DETERMINISTIC | NOT DETERMINISTIC] -- 特性限定符
BEGIN
    -- 定义局部变量
    DECLARE 变量名 数据类型;
    
    -- 逻辑代码
    SET 变量名 = ...;
    
    -- 返回结果
    RETURN 变量名;
END //

DELIMITER ;
```

```SQL
DELIMITER //

CREATE FUNCTION get_user_count() 
RETURNS INT
-- 这里就是特性限定符
READS SQL DATA
DETERMINISTIC
SQL SECURITY DEFINER
COMMENT '获取用户总数的函数'
BEGIN
    DECLARE total INT;
    SELECT COUNT(*) INTO total FROM users;
    RETURN total;
END //

DELIMITER ;
```

### 关键点解释：

1. **DELIMITER //**：告诉 MySQL 暂时不要用分号作为结束符，这样才能在函数体内部正常使用分号。
    
2. **RETURNS**：声明函数返回的数据类型（如 `INT`, `VARCHAR(50)`, `DECIMAL`）。
    
3. **DETERMINISTIC (确定性)**：
    
    - `DETERMINISTIC`: 输入相同的参数，永远返回相同的结果。
        
    - `NOT DETERMINISTIC`: 结果受环境影响（如包含 `NOW()` 或随机数）。
        
    - _注意：如果启用了二进制日志，MySQL 要求必须明确指定其中一种特性。_
        

---

## 3. 核心语法组件

### A. 变量声明与赋值

在 `BEGIN...END` 块中，使用 `DECLARE` 声明局部变量。

```SQL
DECLARE total_score INT DEFAULT 0;
SET total_score = score1 + score2;
-- 或者从表中查询结果赋值
SELECT grade INTO total_score FROM student_scores WHERE id = 1;
```

### B. 条件判断 (IF-ELSE)

SQL

```
IF condition THEN
    -- 执行语句
ELSEIF condition THEN
    -- 执行语句
ELSE
    -- 执行语句
END IF;
```

### C. 循环结构 (WHILE)

SQL

```
WHILE condition DO
    -- 循环体
END WHILE;
```

---

## 4. 实战案例：计算折扣价

假设我们有一个电商数据库，需要一个函数根据会员等级计算折扣后的价格。

SQL

```
DELIMITER //

CREATE FUNCTION GetDiscountPrice(original_price DECIMAL(10,2), level INT)
RETURNS DECIMAL(10,2)
DETERMINISTIC
BEGIN
    DECLARE final_price DECIMAL(10,2);
    
    IF level = 1 THEN
        SET final_price = original_price * 0.9; -- 9折
    ELSEIF level = 2 THEN
        SET final_price = original_price * 0.8; -- 8折
    ELSEIF level >= 3 THEN
        SET final_price = original_price * 0.7; -- 7折
    ELSE
        SET final_price = original_price;       -- 原价
    END IF;
    
    RETURN final_price;
END //

DELIMITER ;
```

### 如何调用这个函数？

SQL

```
-- 在查询中直接使用
SELECT name, price, GetDiscountPrice(price, user_level) AS discounted_price 
FROM orders;
```

---

## 5. 管理存储函数

### 查看函数状态

SQL

```
-- 查看所有自定义函数
SHOW FUNCTION STATUS WHERE Db = 'your_database_name';

-- 查看函数的创建代码
SHOW CREATE FUNCTION GetDiscountPrice;
```

### 删除函数

SQL

```
DROP FUNCTION IF EXISTS GetDiscountPrice;
```

---

## 6. 注意事项与限制 (陷阱预警)

1. **无法直接更新表数据**：虽然技术上可行，但在存储函数中执行 `UPDATE` 或 `DELETE` 操作通常是不推荐的，因为这可能导致 SQL 语句产生难以预料的副作用。
    
2. 错误提示 log_bin_trust_function_creators：
    
    如果你在创建函数时报错，可能是因为 MySQL 开启了二进制日志安全检查。你可以运行：
    
    SET GLOBAL log_bin_trust_function_creators = 1;
    
3. **性能**：在 `SELECT` 语句中对大量行调用复杂的存储函数，会显著降低查询速度。对于大规模数据处理，建议尽量使用原生 SQL 或在应用层处理。
    

---

## 7. 学习建议

- **练习 1**：编写一个函数，接收两个日期，返回这两个日期之间的天数。
    
- **练习 2**：编写一个函数，根据输入的分数返回 "优秀"、"良好"、"及格" 或 "不及格"。