# SQL 查询优化方案

## 0. 目标与原则

优化目标通常分三类（按优先级）：

1. **减少扫描数据量**（rows）
    
2. **减少随机 I/O**（回表、随机读、临时表）
    
3. **减少 CPU 计算与排序**（函数、filesort、hash 聚合）
    

核心原则：

- **让过滤更早发生**（尽早缩小候选集）
    
- **让排序/分组走索引**（避免临时表/外部排序）
    
- **让 join 的内表可被快速定位**（INLJ、hash join 等）
    

---

## 1. 定位慢 SQL（先找“谁最慢”）

### 1.1 收集慢查询

- MySQL：开启 slow_query_log，配合 pt-query-digest 做聚合分析
    
- PostgreSQL：pg_stat_statements
    
- 线上一定要看 **P95/P99**，不要只看平均值
    

建议输出：

- SQL 模板（归一化）
    
- QPS/调用量
    
- 平均/最大耗时
    
- 扫描行数、返回行数、排序/临时表次数
    

---

## 2. 解释执行计划（一定要做）

### 2.1 MySQL：`EXPLAIN` / `EXPLAIN ANALYZE`

重点看：

- `type`：const/ref/range/index/all（越靠前越好）
    
- `key`：是否用到期望索引
    
- `rows`：预估扫描行数（越小越好）
    
- `Extra`：
    
    - `Using where` 正常
        
    - `Using temporary` / `Using filesort` 通常要关注
        
    - `Using index` 说明覆盖索引（好）
        

### 2.2 PostgreSQL：`EXPLAIN (ANALYZE, BUFFERS)`

重点看：

- 实际行数 vs 估算行数（偏差大=统计信息问题）
    
- Seq Scan / Index Scan / Bitmap Scan
    
- Hash Join / Merge Join / Nested Loop
    
- Buffers 命中率
    

---

## 3. 80% 的优化来自 SQL 改写（先改写再谈索引）

### 3.1 只查需要的列（拒绝 `SELECT *`）

- `SELECT *` 会导致更多 I/O、更多回表、更多网络传输
    
- 尤其宽表（text/json/blob）开销巨大
    

✅ 改成：

```SQL
SELECT id, name, status FROM user WHERE ...
```

### 3.2 让条件“可用索引”（SARGable）

常见导致索引失效：

- 对列做函数/计算
    
- 隐式类型转换
    
- `LIKE '%xxx'`
    

✅ 改写示例：
```SQL
-- ❌
WHERE DATE(create_time) = '2026-01-01'

-- ✅
WHERE create_time >= '2026-01-01' AND create_time < '2026-01-02'
```

### 3.3 `OR` 改 `UNION ALL`

```SQL
-- ❌ 可能导致无法走索引或走不全
WHERE a = 1 OR b = 2

-- ✅
SELECT ... WHERE a = 1
UNION ALL
SELECT ... WHERE b = 2 AND a <> 1;

```

### 3.4 大分页优化（禁止深度 OFFSET）

```SQL
-- ❌ offset 很大时极慢
SELECT * FROM orders ORDER BY id LIMIT 20 OFFSET 100000;

-- ✅ 用“游标翻页/seek”
SELECT * FROM orders
WHERE id > 100000
ORDER BY id
LIMIT 20;
```

### 3.5 EXISTS vs IN（尤其子查询返回很多值）

- 大结果集：`EXISTS` 通常更稳（能早停）
    
- 小集合：`IN` 可以
    

✅：

```SQL
SELECT *
FROM Customers c
WHERE EXISTS (
    SELECT 1
    FROM Orders o
    WHERE o.customer_id = c.id
);
```
**执行逻辑**：

1. SQL 引擎遍历 `Customers` 表中的每一行（作为外部查询）。
    
2. 对于当前客户 `c`，执行内部子查询：去 `Orders` 表里找有没有 `customer_id` 等于当前 `c.id` 的记录。
    
3. 只要找到**任何一条**订单，`EXISTS` 就返回 TRUE，该客户被保留在结果集中。
    
4. 如果没找到订单，返回 FALSE，该客户被过滤掉。

#### A. 什么时候用 `EXISTS`？

- **场景**：当**主表（外表）较小**，而**子查询表（内表）非常大**时。
    
- **原因**：`EXISTS` 使用“相关子查询”的机制。它对外表的每一行执行一次检查。因为 `EXISTS` 只要找到一条就停止，如果内表有索引，这个检查非常快。
    

#### B. 什么时候用 `IN`？

- **场景**：当**主表（外表）非常大**，而**子查询表（内表）非常小**且结果集固定时。
    
- **原因**：SQL 引擎通常会先执行子查询，把结果集缓存起来（甚至构建哈希表），然后外表只需要去这个小集合里匹配即可。
    

#### C. 对比总结

| **特性**        | **EXISTS**                             | **IN**                                   |
| ------------- | -------------------------------------- | ---------------------------------------- |
| **逻辑**        | 检查是否存在（相关子查询）                          | 检查值是否在集合中                                |
| **执行方式**      | Loop 外表，探测内表                           | 先查内表，再供外表匹配                              |
| **对 NULL 处理** | **安全**。`EXISTS (SELECT NULL)` 返回 TRUE。 | **危险**。如果列表中包含 NULL，`NOT IN` 可能会失效（返回空）。 |
| **最佳场景**      | 外表小，内表大                                | 外表大，内表小                                  |
### 3.6 聚合前先过滤，能分段就分段

- 先 WHERE 缩小，再 GROUP BY
    
- 对超大表做“先取候选 id 再 join”
    

---

## 4. 索引设计与调整（最常见收益点）

### 4.1 单表查询索引策略

对一个典型查询：

`SELECT col1, col2 FROM t WHERE a=? AND b=? AND c BETWEEN ? AND ? ORDER BY d LIMIT 20;`

建议优先：

1. 把 **等值条件** 放前面：`(a, b, c, d)`
    
2. `c` 是范围，后面的列能否用于排序取决于数据库与写法
    
3. `SELECT` 列尽量包含在索引中 → **覆盖索引**
    

### 4.2 复合索引的“最左前缀”

`INDEX(a,b,c)` 能支持：

- `a`
    
- `a,b`
    
- `a,b,c`  
    但不支持仅 `b` / 仅 `c`
    

### 4.3 覆盖索引（避免回表）

`SELECT id, status FROM orders WHERE user_id=?; -- 建 idx(user_id, id, status)`

### 4.4 Join 索引（你前面问的 NLJ 这里很关键）

- 驱动表：小表/过滤后小的表
    
- 被驱动表 join 字段必须有索引，否则退化为全表扫描
    

`A JOIN B ON A.k = B.k -- B.k 必须索引`

### 4.5 控制索引数量

索引是“空间换时间”，但会：

- 降低写入性能（insert/update/delete）
    
- 增大维护成本
    

经验：以“实际慢 SQL”驱动索引，不要拍脑袋全加。

---

## 5. Join 优化策略（常见瓶颈）

### 5.1 小表驱动大表

- 让外层（驱动表）尽可能小
    
- 把过滤条件下推到 join 前
    

### 5.2 避免 join 产生“爆炸”

- 连接条件不唯一/缺少约束，会导致行数指数增长
    
- 优先确认 join key 是否唯一、是否需要去重
    

### 5.3 先取主键集合再回表

当过滤很强但表很宽：

`SELECT * FROM big_table WHERE ...;`

改成：

`SELECT t.* FROM big_table t JOIN (   SELECT id FROM big_table WHERE ... LIMIT 1000 ) x ON t.id = x.id;`

---

## 6. 排序与分组优化（filesort/temporary 的来源）

### 6.1 ORDER BY 走索引

满足“索引顺序与排序一致”时可避免 filesort。  
常见坑：排序字段没放到合适索引位置。

### 6.2 GROUP BY 尽量用索引

- 如果 GROUP BY 列有索引，能减少临时表/排序
    
- 但聚合通常仍要扫描匹配行，关键还是先过滤
    

---

## 7. 统计信息与参数（优化器选错计划时必看）

### 7.1 统计信息过旧

- MySQL：`ANALYZE TABLE`
    
- PG：`ANALYZE` / autovacuum 设置
    

现象：估算 rows 偏差巨大，导致选错索引或 join 算法。

### 7.2 参数与缓存

- buffer pool 太小 → 磁盘读多
    
- work_mem 太小（PG）→ sort/hash spill 到磁盘
    
- MySQL 临时表落盘：tmp_table_size / max_heap_table_size
    

---

## 8. 表结构与数据层面的优化（中长期）

### 8.1 分区（按时间/范围）

适合日志、订单等按时间查：

- 让查询只扫描少量分区（Partition Pruning）
    

### 8.2 归档与冷热分离

- 热数据保留少量
    
- 冷数据归档到历史表或 OLAP
    

### 8.3 反范式与冗余

- 高频 join 可考虑冗余字段（但要一致性策略）
    

### 8.4 预计算/物化

- 报表类：物化视图/汇总表
    
- 复杂聚合：离线计算 + 在线查询
    

---

## 9. 一套“落地排查流程”（你可以照着跑）

1. 找慢 SQL（按 P95/P99、按 QPS 排序）
    
2. `EXPLAIN` 看是否全表扫、是否临时表、是否 filesort
    
3. 看过滤比例：扫描行数 / 返回行数（越大越不健康）
    
4. 改写 SQL：SARGable、去掉深分页、拆 OR、减少列
    
5. 设计索引：where/join/order/group 组合，尽量覆盖索引
    
6. 再 `EXPLAIN` 对比 rows、key、extra
    
7. 压测：并发下看锁等待、IO、buffer 命中率
    
8. 仍慢：考虑分区/归档/预计算/缓存