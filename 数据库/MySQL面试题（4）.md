**1.MySQL里有哪些锁？**
在 MySQL 里，根据加锁的范围，可以分为**全局锁、表级锁和行锁**三类。

![](https://cdn.xiaolincoding.com//picgo/1720433609532-38aec7fc-734e-4b35-a802-4e6ba3339ffa.png)

- **全局锁**：通过flush tables with read lock 语句会将整个数据库就处于只读状态了，这时其他线程执行以下操作，增删改或者表结构修改都会阻塞。全局锁主要应用于做**全库逻辑备份**，这样在备份数据库期间，不会因为数据或表结构的更新，而出现备份文件的数据与预期的不一样。
    
- **表级锁**：MySQL 里面表级别的锁有这几种：
    
    - 表锁：通过lock tables 语句可以对表加表锁，表锁除了会限制别的线程的读写外，也会限制本线程接下来的读写操作。
        
    - 元数据锁：当我们对数据库表进行操作时，会自动给这个表加上 MDL，对一张表进行 CRUD 操作时，加的是 **MDL 读锁**；对一张表做结构变更操作的时候，加的是 **MDL 写锁**；MDL 是为了保证当用户对表执行 CRUD 操作时，防止其他线程对这个表结构做了变更。
        
    - 意向锁：当执行插入、更新、删除操作，需要先对表加上「意向独占锁」，然后对该记录加独占锁。**意向锁的目的是为了快速判断表里是否有记录被加锁**。
        
- **行级锁**：InnoDB 引擎是支持行级锁的，而 MyISAM 引擎并不支持行级锁。
    
- 记录锁，锁住的是一条记录。而且记录锁是有 S 锁和 X 锁之分的，满足读写互斥，写写互斥
    
- 间隙锁，只存在于可重复读隔离级别，目的是为了解决可重复读隔离级别下幻读的现象。
    
- Next-Key Lock 称为临键锁，是 Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。

------
**2.数据库的表锁和行锁有什么作用？**
- 答：
- 表锁的作用：

- **整体控制**：表锁可以用来控制整个表的并发访问，当一个事务获取了表锁时，其他事务无法对该表进行任何读写操作，从而确保数据的完整性和一致性。
- **粒度大**：表锁的粒度比较大，在锁定表的情况下，可能会影响到整个表的其他操作，可能会引起锁竞争和性能问题。
- **适用于大批量操作**：表锁适合于需要大批量操作表中数据的场景，例如表的重建、大量数据的加载等。

行锁的作用：

- **细粒度控制**：行锁可以精确控制对表中某行数据的访问，使得其他事务可以同时访问表中的其他行数据，在并发量大的系统中能够提高并发性能。
- **减少锁冲突**：行锁不会像表锁那样造成整个表的锁冲突，减少了锁竞争的可能性，提高了并发访问的效率。
- **适用于频繁单行操作**：行锁适合于需要频繁对表中单独行进行操作的场景，例如订单系统中的订单修改、删除等操作。

------
**3.MySQL两个事物同时update同一条信息是否会阻塞？**
- 答：会。
如果是两个事务同时更新了 id = 1，比如 update ... where id = 1，那么是会阻塞的。因为 InnoDB 存储引擎实现了行级锁。

当A事务对 id =1 这行记录进行更新时，会对主键 id 为 1 的记录加X类型的记录锁，这样第二事务对 id = 1 进行更新时，发现已经有记录锁了，就会陷入阻塞状态。

-------
**4.如果两个范围查询不是主键或者索引会触发死锁吗？**
- 答：会，如果范围查询不是主键或者用索引，那么会触发全表扫描，对全表加行级锁。

-----
**5.日志文件是分了哪几种文件**
- **redo log 重做日志**  
    是 InnoDB 存储引擎层生成的日志，实现了事务中的**持久性**，主要用于**掉电等故障恢复**；
    
- **undo log 回滚日志**  
    是 InnoDB 存储引擎层生成的日志，实现了事务中的**原子性**，主要用于**事务回滚和 MVCC**；
    
- **bin log 二进制日志**  
    是 Server 层生成的日志，主要用于**数据备份和主从复制**；
    
- **relay log 中继日志**  
    用于主从复制场景下，slave 通过 IO 线程拷贝 master 的 bin log 后在本地生成的日志；
    
- **慢查询日志**  
    用于记录执行时间过长的 SQL，需要设置阈值后手动开启。

------
**6.讲一下binlog**
**Binlog 全称 Binary Log（二进制日志）**  
它是 **MySQL Server 层生成的一种日志文件**，用于记录数据库执行的所有更改操作（包括 DML 和 DDL），以便后续的复制、恢复、审计等功能使用。

- 它是 **二进制格式**，不能直接用文本查看（可用工具解析）。
    
- 不会记录查询类语句（如 `SELECT`, `SHOW`）。
    
- 一条 Binlog 包含多个事件（事件是描述一次修改行为的记录）。
    

📌 核心是：**记录数据库发生的所有真实修改行为**，而不是查看日志本身的过程。

-----
**7.UndoLog日志的作用是什么？**
- 答：用于事物回滚。在提交以前会把更新的数据记录到undo日志中。
- 当事务对某条数据执行修改（比如 `INSERT / UPDATE / DELETE`）之前，数据库会先把被修改的数据当前值（旧值）写到 Undo Log 里。这个旧值用来 _撤销_后续的修改操作。

在 InnoDB 中，这些日志存放在 **undo 表空间（undo tablespace）** 或系统表空间里，不像 `binlog` 那样是独立的日志文件。
- 在插入一条数据时，把数据主键值记录到undo空间中，当回滚的时候，就根据主键删除
- 在删除一条数据时，先把这个数据完整记录下来，在回滚时还原
- 在更新一条数据时，把旧值记录下来，然后回滚时还原回去

------
**8.有了undolog为什么还要redolog呢？**
- 答：
- **Undo Log：用来“回退”没做完的事**
    
- **Redo Log：用来“重做”已经做完但还没来得及落盘的事**

-  Buffer Pool 是提高了读写效率没错，但是问题来了，Buffer Pool 是基于内存的，而内存总是不可靠，万一断电重启，还没来得及落盘的脏页数据就会丢失。

* 为了防止断电导致数据丢失的问题，当有一条记录需要更新的时候，InnoDB 引擎就会先更新内存（同时标记为脏页），然后将本次对这个页的修改以 redo log 的形式记录下来，**这个时候更新就算完成了**。
* 后续，InnoDB 引擎会在适当的时候，由后台线程将缓存在 Buffer Pool 的脏页刷新到磁盘里，这就是 **WAL (Write-Ahead Logging) 技术**。

------
**9.redolog如何保证持久性？**
##### 1. Write-ahead logging (WAL)

在事务提交之前，将事务所做的修改操作记录到 redo log 中，然后再将数据写入磁盘。这样即使在数据写入磁盘之前发生了宕机，系统可以通过 redo log 中的记录来恢复数据。

##### 2. Redo log 的顺序写入

Redo log 采用追加写入的方式，将 redo 日志记录追加到文件末尾，而不是随机写入。这样可以减少磁盘的随机 I/O 操作，提高写入性能。

##### 3. Checkpoint 机制

MySQL 会定期将内存中的数据刷新到磁盘，同时将最新的 **LSN (Log Sequence Number)** 记录到磁盘中，这个 LSN 可以确保 redo log 中的操作是按顺序执行的。在恢复数据时，系统会根据 LSN 来确定从哪个位置开始应用 redo log。

------
**10.能不能只用binlog不用redolog？**
- 答：不能，binlog是sever层的日志，不能记录哪些脏页还没有刷新回磁盘。redolog是存储引擎层日志，可以记录哪些脏页还没有刷新回磁盘。

-----
**11.一条update语句的执行步骤**
- 答：
- - **搜索记录：** 执行器负责具体执行，调用存储引擎接口，通过主键索引树搜索 `id = 1` 的记录。
    
    - 如果数据页已在 **Buffer Pool** 中，则直接返回给执行器。
        
    - 如果不在，则先从磁盘读入 Buffer Pool 再返回。
        
- **判断更新：** 执行器对比更新前后的记录是否一致。
    
    - 如果一致，不进行后续流程；
        
    - 如果不一致，则将新旧记录传给 InnoDB 层执行更新。
        
- **记录 Undo Log：** InnoDB 层更新前需记录 **Undo log**（记录旧值用于回滚）。Undo log 写入 Buffer Pool 的 Undo 页面后，还需记录对应的 **Redo log**。
    
- **更新内存与 Redo Log：** InnoDB 更新内存（标记为**脏页**），并将修改记录到 Redo log 中，此时更新逻辑完成。
    
    - **WAL 技术应用：** 不会立即写磁盘数据文件，而是通过后台线程异步刷新脏页，以减少磁盘 I/O。
        
- **语句更新完成：** 至此，内存层面的记录更新结束。
    
- **记录 Binlog：** 开始记录该语句对应的 **Binlog** 并保存到 **Binlog cache**。注意，此时尚未刷新到硬盘文件，需等到事务提交时才统一刷新。
    
- **事务提交（两阶段提交）：**
    
    - **Prepare 阶段：** 将 Redo log 对应的事务状态设为 `prepare`，并将 Redo log 刷新到硬盘。
        
    - **Commit 阶段：** 将 Binlog 刷新到磁盘，调用引擎提交接口，将 Redo log 状态设置为 `commit` 并刷新到磁盘。
        
- **流程结束：** 一条更新语句彻底执行完成。

-----
**12.MySQL如何保障数据不丢失？**
- 答：MySQL 通过「WAL + Redo Log + Undo Log + Binlog + 两阶段提交 + 刷盘策略」来保证数据在宕机、崩溃、异常情况下不丢失。

------
**13.为什么要写redolog而不是直接写B+树**
- 因为直接写 B+ 树 = 随机 I/O + 高成本 + 难以保证崩溃一致性。
- 而写 Redo Log = 顺序 I/O + 快 + 易恢复。
- ###### B+ 树的数据页分布

- 数据页在磁盘上 **高度离散**
    
- 一次 UPDATE 可能涉及：
    
    - 数据页
        
    - 索引页
        
    - 可能还会页分裂
        

👉 写磁盘是 **随机写**
数据库的核心思想之一：
> **把多次修改合并，一次写盘**

------
