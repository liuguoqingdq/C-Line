## 为什么要多表查询
MySQL 之所以需要多表查询（JOIN），根本原因不是“SQL 喜欢复杂”，而是**关系模型的结构设计决定了数据被拆分到多张表里**；而你在业务上又经常需要把这些被拆开的信息重新组合成“一个视图/一份结果”。多表查询就是把**规范化存储**与**组合输出**连接起来的机制。

----
## 多表查询

**笛卡尔积错误**

原因是出现缺少多表连接的条件
**正确方式：**
```SQL
SELECT employee_id,department_id
FROM employees,departments
WHERE employees.`department_id` = departments.`department_id`;
```

### 1）什么是笛卡尔积（Cartesian Product）

当你把两张表 A、B 放在同一个查询里，但没有有效的关联条件时：

- A 有 m 行
    
- B 有 n 行
    

**结果会变成 m × n 行**

典型错误写法：

```SQL
SELECT *FROM users u, orders o;
```

或


```SQL
SELECT *FROM users uJOIN orders o;   -- 没有 ON
```

---

### 2）最常见的“导致笛卡尔积”的几类错误

#### 错误 A：忘了写 ON / WHERE 关联条件


```SQL
SELECT *FROM users uJOIN orders o;   -- 缺 ON，直接交叉连接
```

✅ 正确：


```SQL
SELECT *FROM users uJOIN orders o ON o.user_id = u.id;
```

#### 错误 B：把连接条件写到 WHERE 里但写错了列

比如误写成常量或同表列比较：


```SQL
-- ❌ 条件永真或无效，等同于没连上
WHERE u.id = u.id
```

✅ 正确：


```SQL
WHERE u.id = o.user_id
```

#### 错误 C：用 LEFT JOIN 但把右表条件写进 WHERE，把外连接“变内连接”

这不一定产生笛卡尔积，但会造成结果异常（丢行），很多人会误判为“连接错了”。

```SQL
SELECT *FROM users uLEFT JOIN orders o ON o.user_id = u.idWHERE o.status = 'PAID';   -- ❌ 会过滤掉 o 为 NULL 的行
```

✅ 正确（把条件放 ON）：


```SQL
SELECT *FROM users uLEFT JOIN orders o
  ON o.user_id = u.id AND o.status = 'PAID';
```

#### 错误 D：多表连接时漏写“某一条边”

三张表时最常见：只连了 A-B，忘了连 B-C，于是 C 和前面结果做了乘积。


```SQL
SELECT *FROM AJOIN B ON ...JOIN C;          -- ❌ 忘了 ON
```

✅ 正确：每加一张表，基本都要有一条明确的 join 条件


```SQL
SELECT *FROM AJOIN B ON B.a_id = A.idJOIN C ON C.b_id = B.id;
```

---

### 3）如何快速判断“是不是笛卡尔积”

1. **看行数是否异常变大**（接近乘积）
    
2. **用 EXPLAIN 检查连接条件**： `EXPLAIN SELECT ...` 如果某个表显示：
    
    - `type = ALL`（全表扫）
        
    - `rows` 很大
        
    - `Extra` 里没有合理的连接信息 很可能 join 条件缺失或无法利用索引。
        
3. **查重复组合**： `SELECT COUNT(*) FROM ...;`
    

---

### 4）正确写法建议（避免踩坑）

- 永远用显式 `JOIN ... ON ...`，不要用旧式逗号连接
    
- 每新增一张表，都确保有明确的 ON 条件
    
- LEFT JOIN 的右表过滤条件优先写在 ON（除非你就是想把它变成内连接）
    
- 给连接键建索引：如 `orders(user_id)`，`detail(order_id)` 等


**字段不明确的错误：**
```SQL
SELECT employee_id,department_name,department_id
FROM employees,departments
WHERE employees.`department_id` = departments.`department_id`;//会报错，如果department_id在两张表里都有的话，字段不明确

SELECT employee_id,department_id,departments.department_id
FROM employees,departments
WHERE employees.`department_id` = departments.`department_id`;//正确的
```


**如果给表起了别名，一旦SELECT或者WHERE中使用了别名，就不能使用表名了:**
```SQL
SELECT u.id, u.name
FROM users AS u
WHERE u.id = 1;
```

**！！！如果有n个表做多表查询，就需要n-1个连接条件**

-------
## 多表查询的分类

**角度1:等值连接 VS 非等值连接
定义对比

|维度|等值连接（Equi-Join）|非等值连接（Non-Equi / Theta Join）|
|---|---|---|
|连接条件|使用 `=`（或多列 `=`）|使用 `<` `>` `<=` `>=` `BETWEEN` `!=` 等|
|常见数据关系|主键-外键、ID 对应|区间映射、阈值分段、范围重叠|
|结果特征|一般更“确定”（一对一/一对多）|可能出现“多对多”膨胀（一个值落入多个区间）|
等值连接：
```SQL
SELECT o.id, u.name, o.total
FROM orders o
JOIN users u ON o.user_id = u.id;
```

非等值连接：
```SQL
SELECT s.user_id, s.score, g.grade
FROM scores s
JOIN grade_rules g
  ON s.score BETWEEN g.min_score AND g.max_score;
```




**角度2:自连接 VS 非自连接
## 定义对比

### 自连接（Self Join）

- **同一张表与自己做 JOIN**，通常用**表别名**把“同一表”当作“两张逻辑表”来用。
    
- 目的：表达**行与行之间的关系**（同表内的层级、对比、配对、相邻关系、重复检测等）。
    

### 非自连接（Non-self Join）

- **不同表之间做 JOIN**（如 `orders` 连 `customers`）。
    
- 目的：把**实体拆分在多表**的数据（主表/从表、维表/事实表）在查询时组合起来。

**自连接**
```SQL
SELECT employee_id,last_name,employee_id,last_name
FROM employees "emp",employee "master"
WHERE emp.`manger_id` = master.`employee_id`;
```



**角度3:内连接 VS 外连接

## 1) 内连接（INNER JOIN）

### 定义

只返回两边**能够匹配上连接条件**的记录（交集）。

### 结果特征

- 如果某行在连接条件下找不到匹配行，它就**消失**（不出现在结果里）。
    
- `INNER JOIN` 与 `JOIN` 在 MySQL 中等价（`JOIN` 默认就是 `INNER JOIN`）。

## 2) 外连接（OUTER JOIN）

外连接的核心：**保留一边（或两边）的“所有行”**，匹配不到的部分用 `NULL` 补齐。

外连接分三类：

### A) 左外连接（LEFT OUTER JOIN）

- **保留左表全部行**
    
- 右表匹配不到 → 右表列为 `NULL`
```SQL
SELECT
  emp.employee_id AS emp_id,
  emp.last_name   AS emp_name,
  mgr.employee_id AS mgr_id,
  mgr.last_name   AS mgr_name
FROM employees emp
LEFT JOIN employees mgr
  ON emp.manager_id = mgr.employee_id;
```

### B) 右外连接（RIGHT OUTER JOIN）

- **保留右表全部行**
    
- 左表匹配不到 → 左表列为 `NULL`
```SQL
SELECT
  emp.employee_id AS emp_id,
  emp.last_name   AS emp_name,
  mgr.employee_id AS mgr_id,
  mgr.last_name   AS mgr_name
FROM employees emp
RIGHT JOIN employees mgr
  ON emp.manager_id = mgr.employee_id;
```


左右表区分：
```SQL
FROM A
RIGHT JOIN B
  ON 条件
```
- **左表（left table）**：`A`（写在 `RIGHT JOIN` 之前、`FROM` 后面的那个）
    
- **右表（right table）**：`B`（写在 `RIGHT JOIN` 后面的那个）
    
- `RIGHT JOIN` 的含义：**保留右表 B 的全部行**；左表 A 匹配不到就补 `NULL`。

### C) 全外连接（FULL OUTER JOIN）

- **两边都保留全部行**
    
- 任一边匹配不到 → 另一边补 `NULL`
    

注意：**MySQL 没有原生 `FULL OUTER JOIN`**，通常用 `LEFT JOIN UNION RIGHT JOIN` 模拟。


**SQL92语法实现外连接
使用`+` 

```SQL
SELECT employee_id,department_id,departments.department_id
FROM employees,departments
WHERE employees.`department_id` = departments.`department_id`(+);//缺东西的表用`+`补齐（MySQL不支持，oracle支持）
```

**SQL99语法支持外连接**
JOIN ON基本语法
```SQL
SELECT  列清单
FROM    表A AS a
JOIN类型 表B AS b
  ON    a.连接键 = b.连接键
WHERE   过滤条件
ORDER BY ...
LIMIT ...
```

多表连接模版
```SQL
SELECT ...
FROM A a
JOIN B b
  ON a.key = b.key
JOIN C c
  ON b.key2 = c.key2;   -- 或者 c 与 a 关联也可以
```

不用JOIN ON
```SQL
SELECT e.employee_id, e.last_name, d.department_name, l.city
FROM employees e, departments d, locations l
WHERE e.department_id = d.department_id
  AND d.location_id   = l.location_id;
```

**JOIN ON实现内连接**
```SQL
SELECT employee_id,department_id,departments.department_id
FROM employees JOIN departments
ON employees.`department_id` = departments.`department_id`;
```

**JOIN ON 实现左外连接**
```SQL
SELECT emp.last_name,dep.department_name
FROM employees emp LEFT JOIN departments dep
ON emp.`department_id` = dep.`department_id`;
```

**JOIN ON 实现右外连接**
```SQL
SELECT emp.last_name,dep.department_name
FROM employees emp LEFT JOIN departments dep
ON emp.`department_id` = dep.`department_id`;
```
**！！！MySQL不支持满外连接（FULL JOIN ON）

-----
## 7种 SQL JOINS

![[Pasted image 20251226215003.png]]
UNION ALL语法：
```SQL
SELECT col1, col2, ...
FROM t1
UNION ALL
SELECT col1, col2, ...
FROM t2
UNION ALL
SELECT col1, col2, ...
FROM t3;
```
**求A B全集：
```SQL
SELECT * FROM TABLEA
LEFT JOIN TABLEB
ON A.Key=B.Key
UNION ALL
SELECT * FROM TABLEA
RIGHT JOIN TABLEB
ON A.Key=B.Key
WHERE A.Key IS NULL;

//或

SELECT * FROM TABLEA
RIGHT JOIN TABLEB
ON A.Key=B.Key
UNION ALL
SELECT * FROM TABLEA
LEFT JOIN TABLEB
ON A.Key=B.Key
WHERE B.Key IS NULL;
```

---
## 自然连接
**自然连接（NATURAL JOIN）**是 SQL 标准里的“自动等值连接”语法：数据库会**自动找出两张表中同名的列**，并把这些同名列作为连接条件（等值匹配），同时在结果集中**只保留一份同名列**。
语法：
```SQL
SELECT ...
FROM A NATURAL JOIN B;
```
外连接形式：
```SQL
FROM A NATURAL LEFT JOIN  B;
FROM A NATURAL RIGHT JOIN B;
```


### USING
`USING` 是 SQL 连接语法里的一种 **“按同名列做等值连接，并把同名列合并输出”** 的写法。它只能用在 `JOIN` 中（不是 `WHERE`、也不是 `UNION`）。
基本语法：
```SQL
SELECT ...
FROM A
JOIN B USING (col1, col2, ...);
```
外连接：
```SQL
FROM A LEFT JOIN  B USING (col);
FROM A RIGHT JOIN B USING (col);
```