## 约束
**约束的分类：**
- 角度1:约束字段的个数
	- **单列约束VS多列约束**
- 角度2：约束的作用范围
	- **列级约束：**：声明在字段后面
	- **表级约束**：表中所有字段都声明玩，在所有字段后面的声明
关键字：constraint
- 角度3:约束的作用：

|      |          |         |        |             |             |       |
| ---- | -------- | ------- | ------ | ----------- | ----------- | ----- |
| 约束类型 | 非空约束     | 默认约束    | 唯一约束   | 主键约束        | 外键约束        | 检查约束  |
| 关键字  | not null | default | unique | primary key | foreign key | CHECK |

----
### 添加删除约束

- **在create table时添加约束**
- **alter table时删除或者修改约束**

----

###### 1. 非空约束 (NOT NULL)

- **作用**：强制列不能存储 `NULL` 值。
    
- **场景**：必填项，如用户名、密码、创建时间。
    
- **效果**：如果尝试插入一个没有该列值的记录，数据库会报错。
    

### 2. 唯一约束 (UNIQUE)

- **作用**：保证一列或多列组合中的每一行数据都是唯一的。
    
- **注意**：`UNIQUE` 约束允许 `NULL` 值，且一个表中可以有多个 `UNIQUE` 约束。
    
- **场景**：手机号、身份证号、邮箱地址。
    
**添加唯一约束**
**创建唯一约束的时候，如果不给约束命名，默认和列名相同，如果列没有NOT NULL约束，可以添加多个NULL**
```SQL
create table test1(
id INT UNIQUE,
name varchar(25) NOT NULL,
email varchar(25) UNIQUE,
salary DECIMAL(10,2)，
#表级约束
constraint unique_test_email UNIQUE(email)//unique_test_email是约束名
);


//创建复合约束
create table USER(
id INT,
`name` varchar(15),
`password` varchar(25),

CONSTRAINT unique_name_password UNIQUE(name,password);
);

//对于复合约束
INSERT INTO USER
VALUES 
(1,'tom','1b')
(2,'tom1','1b');//是可以成功的，只要向量中，有一个不一样就行
```
**建表后指定唯一性约束**
```SQL
//方式1
ALTER TABLE test1
MODIFY 字段名 字段类型 UNIQUE；

//方式2
alter table test1
add unique key(字段名)；

//方式3
alter table test1
add constraint unique_test_e unique(字段名);
```

------

### 3. 主键约束 (PRIMARY KEY)

- **作用**：**`NOT NULL` + `UNIQUE` 的组合**。它是每一行记录的唯一标识符。
    
- **特性**：
    
    - 每个表只能有一个主键。
        
    - 主键值绝对不能重复，且绝对不能为空。
        
- **场景**：通常使用自增 ID（如 `id INT AUTO_INCREMENT`）。
    
* 需要注意的一点是，不要修改主键的值，因为主键是数据的唯一标识符，修改主键的值会破坏数据的完整性
**多列复合主键，不允许值为NULL**

------
### 自增列：AUTO INCREMENT
### 一、 基本定义与作用

`AUTO_INCREMENT` 用于在插入新记录时，自动为该列生成一个唯一的、递增的数值。(**一般给主键用的**)

- **核心作用**：保证记录的唯一性，简化主键管理。
    
- **常用场景**：订单号、用户 ID、日志编号。
    
```SQL
create table test3(
id INT PRIMARY KEY AUTO INCREMENT,
last_name varchar(25)
);

//插入时不用管id了
INSERT INTO test3
VALUES ('tom');


//添加自增列
ALTER TABLE test3
MODIFY id INT AUTO INCREMENT;


//在5.7版本中
INSERT TABLE test3
VALUES (值)
....
...
这里的id会自增，即便是（假设增到4）删除4，也会从5开始，除非重启服务器
```


---

### 二、 核心使用规则

1. **必须是键**：自增列必须被定义为键（通常是 `PRIMARY KEY` 或 `UNIQUE` 索引）。
    
2. **每表唯一**：一个表中**只能有一个**自增列。
    
3. **数据类型限制**：通常用于整数类型（`INT`, `BIGINT`），也可以用于浮点型（但不推荐）。
    
4. **非空性**：自增列隐式具备 `NOT NULL` 属性。
    

---

### 三、 语法示例

#### 1. 创建表时指定

```SQL
CREATE TABLE users (
    id INT AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(50) NOT NULL
);
```

#### 2. 插入数据

插入时可以忽略该列，或者传入 `NULL` / `0`，MySQL 会自动生成下一个值：

SQL

```
INSERT INTO users (username) VALUES ('Alice'); -- id 自动为 1
INSERT INTO users (id, username) VALUES (NULL, 'Bob'); -- id 自动为 2
```

---

### 四、 数学逻辑与配置

MySQL 通过两个全局/会话变量来控制自增步长，这在**主主复制**或**多主架构**中非常重要，用于避免 ID 冲突。

#### 1. 核心变量

- `auto_increment_offset`：起始偏移量（从几开始）。
    
- `auto_increment_increment`：步长（每次加几）。
    

#### 2. 计算公式

下一个自增值的计算逻辑如下：

$$Value_{next} = Value_{current} + \text{step}$$

其中 $\text{step}$ 由系统配置决定。在多机环境下，公式通常演变为：

$$Value_{next} = (\text{Current\_Max\_ID} \div \text{increment} + 1) \times \text{increment} + \text{offset}$$

---

### 五、 进阶操作：修改自增值

如果你删除了数据，想让下一个 ID 从指定位置开始：

SQL

```
-- 将自增起始值改为 1000
ALTER TABLE users AUTO_INCREMENT = 1000;
```

> **注意**：如果你设置的值小于当前表中已有的最大 ID，该操作将不会生效。

---

### 六、 常见坑点与注意事项（必看）

#### 1. ID 不连续（空洞现象）

自增 ID 并不保证绝对连续，以下情况会导致“跳号”：

- **事务回滚**：如果插入操作在事务中失败并回滚，已申请的 ID 不会退回。
    
- **唯一约束冲突**：插入数据因其他字段重复而报错，ID 仍会自增。
    
- **批量插入**：MySQL 为了性能会预留一段 ID 空间。
    

#### 2. 溢出问题

如果使用的是 `INT`（最大约 21 亿），当达到上限后，再次插入会报错。

- **建议**：对于海量数据的表（如订单、日志），建议使用 **`BIGINT`**。
    

#### 3. 删除全表数据

- 使用 `DELETE FROM table;`：在某些引擎（如旧版 InnoDB）中，重启后自增值可能会重置为最大 ID + 1。
    
- 使用 `TRUNCATE TABLE table;`：**推荐方式**，它会清空数据并彻底重置自增计数器。
    

---

### 七、 获取刚插入的 ID

在应用程序中，通常需要知道刚才插入的那行数据的 ID。

- **SQL 方式**：`SELECT LAST_INSERT_ID();`
    
- **编程语言**：
    
    - PHP: `$conn->insert_id`
        
    - Python (Cursor): `cursor.lastrowid`
        
    - Java (JDBC): `getGeneratedKeys()`
        

---

### 总结

|**特性**|**说明**|
|---|---|
|**存储位置**|InnoDB 存储在内存中（8.0 以后持久化到重做日志）。|
|**重置方法**|`ALTER TABLE ... AUTO_INCREMENT = N` 或 `TRUNCATE`。|
|**最大优势**|性能高，插入时减少索引页分裂（顺序写入）。|
|**潜在风险**|ID 耗尽溢出、不具备业务含义。|



-----
### 4. 外键约束 (FOREIGN KEY)

- **作用**：维护两张表之间数据的**参照完整性**。它将一个表中的列与另一个表的主键关联起来。
    
- **效果**：
    
    - 防止破坏表之间连接的行为。
        
    - 防止非法数据插入外键列（必须在关联的主键中存在）。
        
- **场景**：订单表中的 `user_id` 必须对应用户表中的某个 `id`。
    
```SQL
//添加外键约束,先创建主表
create table dept1(
dept_id INT,
dept_name varchar(25)
);//主表
//关联的主表的列需要是主键或者有唯一性约束
ALTER TABLE dept1
ADD PRIMARY KEY(dept_ID);


create table emp(
emp_id INT PRIMARY KEY AUTO INCREMENT,
emp_name varchar(15),
department_id INT,

#创建表级约束
constraint fk_emp_dept_id 
foreign key (department_id) reference (dept_id)
);


//一旦创建了外键，那么被约束的字表，不能改随意添加修改行，除非被修改的外键约束列的值在主表中可以找到
//一个表中可以有多个外键约束
//删除外键约束
#1.先删除外键
alter table test1
drop foreign key 外键名；
#2.再删除外键约束对应的索引列
show index from test1;
alter table test1
drop index 约束名;
```
**在MySQL里外键约束是有成本的，在大并发的系统设计里不建议使用**

---
### 作用

#### 1. 保证参照完整性

确保子表中的数据在父表中确实存在。

- **例子**：在`订单表`里插入一个 `用户ID=99` 的订单，如果`用户表`里根本没有 ID 为 99 的人，外键约束会直接报错，禁止插入。
    

#### 2. 防止数据孤儿（Orphaned Data）

防止删除父表记录时，子表还残留着指向它的失效引用。

- **例子**：如果你删除了一个用户，外键可以确保该用户下的所有订单也随之处理（删除或置空），避免数据库中存在“不知道是谁下的订单”。
    

#### 3. 级联操作（Cascading）

外键不仅能“限制”操作，还能“联动”操作。当你更新或删除父表数据时，子表会自动跟随。

---

### 二、 外键的四种行为（Action）

在定义外键时，可以指定 `ON DELETE`（删除时）和 `ON UPDATE`（更新时）的策略：

|**行为策略**|**描述**|**效果**|
|---|---|---|
|**CASCADE (级联)**|**连带操作**|父表删了/改了，子表对应的记录也跟着删了/改了。|
|**SET NULL (置空)**|**断开联系**|父表删了，子表相关字段变为 `NULL`（前提是该字段允许为空）。|
|**RESTRICT (限制)**|**强行禁止**|只要子表还有人在引用这条记录，父表就不准删/改（MySQL 默认行为）。|
|**NO ACTION**|**同上**|在 MySQL 中与 RESTRICT 作用相同。|

---

### 三、 语法示例

假设我们有 `部门表 (departments)` 和 `员工表 (employees)`：


```SQL
CREATE TABLE departments (
    dept_id INT PRIMARY KEY,
    dept_name VARCHAR(50)
);

CREATE TABLE employees (
    emp_id INT PRIMARY KEY,
    name VARCHAR(50),
    d_id INT,
    -- 定义外键约束
    CONSTRAINT fk_dept 
    FOREIGN KEY (d_id) REFERENCES departments(dept_id)
    ON DELETE CASCADE  -- 如果部门撤编，员工记录自动删除
    ON UPDATE CASCADE  -- 如果部门编号改了，员工记录自动同步
);
```

---

### 四、 为什么要用外键？（优点）

1. **逻辑强硬**：将业务逻辑（如“订单必须属于用户”）固化在数据库层，比在代码里写 `if` 判断更可靠。
    
2. **减少脏数据**：自动清理无效引用，保持数据干净。
    
3. **直观展示关系**：通过 `SHOW CREATE TABLE` 或数据库建模工具，能一眼看出表与表之间的拓扑结构。
    

---

### 五、 为什么大厂（如阿里、美团）建议禁用外键？

在分布式、超大规模并发的互联网场景中，外键存在以下问题：

1. **性能开销**：每次插入、更新、删除操作，数据库都要去另一张表查一遍是否存在关联，高并发下会产生明显的性能损耗。
    
2. **死锁风险**：外键操作会引发额外的行锁甚至表锁，增加数据库死锁的概率。
    
3. **分库分表困难**：当 `用户表` 在 A 服务器，`订单表` 在 B 服务器时，物理外键无法跨物理机工作。
    
4. **级联失控**：如果级联层级太深（A连B连C连D），删除 A 表一条记录可能导致数据库瞬间产生几万个删除操作，造成系统卡顿。
    

---

### 总结建议

- **小型/中型项目、内部管理系统**：**强烈建议使用外键**。它能帮你省去大量的数据校验代码，保证数据绝对安全。
    
- **高并发、分布式、互联网 C 端项目**：建议使用**逻辑外键**。即：表结构上不建立物理约束，由应用程序（Java/Python/Go 等）在逻辑代码中保证一致性。



-----
### 5. 默认约束 (DEFAULT)

- **作用**：当插入记录时，如果没有为该列指定值，则自动填入默认值。
    
- **场景**：状态字段（如 `status = 1`）、记录创建时间（`DEFAULT CURRENT_TIMESTAMP`）。
    

### 6. 检查约束 (CHECK)

- **版本说明**：!!!!!MySQL 8.0.16 及以后版本才真正支持。
    
- **作用**：确保列中的值符合指定的条件。
    
- **场景**：限制年龄在 0 到 150 之间，或性别只能是 'M'/'F'。
    
    - 示例：`CHECK (age > 0 AND age < 150)`
        


```SQL
//创建时添加
create table test1(
id INT,
last_name varchar(15),
salary DECIMAL(10,2) CHECK(salary > 2000)
);
```



---

### 约束对比总结表

| **约束类型** | **缩写** | **核心功能** | **是否允许多个**  | **是否允许 NULL** |
| -------- | ------ | -------- | ----------- | ------------- |
| **主键**   | `PK`   | 唯一标识一行   | **否**（每表一个） | 否             |
| **唯一**   | `UK`   | 防止重复数据   | 是           | 是             |
| **外键**   | `FK`   | 建立跨表关联   | 是           | 是             |
| **非空**   | `NN`   | 确保必填     | 是           | 否             |
| **默认**   | `DF`   | 填充预设值    | 是           | 是             |
| **检查**   | `CK`   | 自定义逻辑校验  | 是           | 是             |

---

### 为什么要使用约束？

如果不使用约束，数据的维护将完全依赖于应用程序逻辑，这会导致以下风险：

1. **数据孤儿**：删除了父表记录，子表却留下了无法对应的外键 ID。
    
2. **数据冗余/冲突**：同一个手机号注册了两个账号。
    
3. **脏数据**：年龄出现了 -1 岁或 500 岁的情况。
    

> **💡 建议**：在设计数据库阶段，应尽可能通过约束来固定业务规则，这比在代码里写 `if-else` 校验要可靠得多。


---
### 查看表的约束

```SQL
SELECT 
    CONSTRAINT_NAME, 
    CONSTRAINT_TYPE 
FROM 
    information_schema.TABLE_CONSTRAINTS 
WHERE 
    TABLE_SCHEMA = '数据库名' AND TABLE_NAME = '表名';
```

### 创建表时添加约束
```SQL
create table if not exists test1(
id INT NOT NULL,
name varchar(20) NOT NULL,
email varchar(25),
salary DECIMAL(10,2) 
);



ALTER TABLE test1
modify email varchar(25) NOT NULL;//如果列中现有数据存在NULL值，会修改失败

//删除约束
ALTER TABLE test1
MODIFY email varchar(25) NULL;
```