## 一、 会话用户变量 (User-Defined Variables)

会话用户变量是针对当前连接定义的变量。你可以把它们看作是当前 SQL 窗口中的“临时剪贴板”。

### 1. 核心特性

- **符号标识**：必须以 **`@`** 开头（如 `@my_price`）。
    
- **作用域**：**整个会话（Session）**。只要你不关闭当前连接，变量就一直存在。
    
- **声明方式**：不需要预先声明类型。变量的类型取决于你第一次赋给它的值。
    
- **初始值**：如果引用一个未初始化的用户变量，其值为 `NULL`，不会报错。
    

### 2. 定义与赋值语法

你可以使用 `SET` 语句或 `SELECT` 语句进行赋值。

- **方式 A：使用 `SET`**（推荐）


    ```SQL
    SET @age = 25;
    SET @name := 'Tom'; -- 在 SET 中 = 和 := 效果一样
    ```
    
- **方式 B：在 `SELECT` 语句中赋值**（必须使用 `:=`）

    
    ```SQL
    SELECT @max_price := MAX(price) FROM products;
    -- 注意：在 SELECT 内部，= 被视为比较运算符，赋值必须用 :=
    ```
    

### 3. 使用场景示例

跨 SQL 语句传递数据。例如：先查出某个 ID，再用这个 ID 去更新另一张表。


```SQL
-- 1. 记录当前订单的总价
SELECT @total := sum(amount) FROM orders WHERE user_id = 1;

-- 2. 在后续查询中直接使用该变量
SELECT * FROM coupon WHERE min_spend <= @total;
```

---

## 二、 局部变量 (Local Variables)

局部变量是数据库编程的核心，它只能在 **存储程序**（存储过程、函数、触发器）的内部使用。

### 1. 核心特性

- **符号标识**：**不以 `@` 开头**，直接写名字（如 `my_count`）。
    
- **作用域**：**`BEGIN ... END` 代码块内部**。一旦代码块执行结束，变量立即销毁。
    
- **声明方式**：必须先使用 **`DECLARE`** 关键字声明，且必须放在代码块的最顶部。
    
- **强类型**：声明时必须指定数据类型（如 `INT`, `VARCHAR`）。
    

### 2. 定义与赋值语法

- **声明变量**：
    
    
    ```SQL
    DECLARE my_total INT DEFAULT 0; -- 必须在最前面
    ```
    
- **赋值变量**：
    
    
    ```SQL
    SET my_total = 100;
    -- 或者从表中查询结果赋值
    SELECT count(*) INTO my_total FROM users;
    ```
    

### 3. 代码示例（存储过程内）


```SQL
DELIMITER //
CREATE PROCEDURE test_local_var()
BEGIN
    -- 1. 声明局部变量
    DECLARE user_count INT DEFAULT 0;
    
    -- 2. 赋值
    SELECT COUNT(*) INTO user_count FROM users;
    
    -- 3. 逻辑判断
    IF user_count > 10 THEN
        SELECT 'User count is high';
    ELSE
        SELECT 'User count is low';
    END IF;
    -- 函数结束，user_count 变量消失
END //
DELIMITER ;
```

---

## 三、 会话用户变量 vs. 局部变量：深度对比

|**特性**|**会话用户变量 (@var)**|**局部变量 (var)**|
|---|---|---|
|**位置**|任何地方（命令行、脚本、存储过程）|仅在 `BEGIN ... END` 内部|
|**前缀**|必须有 `@`|不能有 `@`|
|**声明**|直接使用，自动创建|必须先 `DECLARE`|
|**类型**|弱类型（动态改变）|强类型（声明时固定）|
|**生命周期**|整个连接（直到你退出登录）|随代码块结束而消失|
|**初始化**|默认为 `NULL`|可用 `DEFAULT` 指定初始值|

---

## 四、 关键差异与“坑”

### 1. 为什么局部变量不带 `@`？

如果局部变量带了 `@`，MySQL 会把它识别为“用户变量”，从而导致它的作用域溢出到存储过程之外。

- 如果你想在存储过程中定义一个**只在内部有效**的临时计数器，请使用 `DECLARE`。
    
- 如果你想在存储过程中修改一个**在过程结束后依然能被外面看到**的变量，请使用 `@`。
    

### 2. 赋值符号的迷思

- 在 `SET` 语句中，两者都通用。
    
- 在 **`SELECT`** 语句中：
    
    - `SELECT @var := value`：这是在“**执行查询的同时进行赋值**”。
        
    - `SELECT value INTO var`：这是在“**将查询结果存入已声明的局部变量**”。
        

### 3. 变量名冲突

如果局部变量的名字和表的列名相同，MySQL 会优先识别为**变量**。

- _反例_：`DECLARE id INT; SELECT id FROM users;` —— 这会返回变量 `id` 的值，而不是表里的 `id` 列。
    
- _对策_：局部变量名通常建议加上前缀，如 `v_id` 或 `l_id`（local id）。
    

---

## 五、 总结建议

1. **日常临时查询**：用 `@会话变量`。比如计算行号、跨语句传参。
    
2. **编写存储过程/函数**：尽量用 `DECLARE 局部变量`。这能保证代码的封装性，避免污染外部环境。
    
3. **性能**：局部变量（强类型）在复杂计算中通常比用户变量（弱类型）效率略高。