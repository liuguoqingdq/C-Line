**1.执行一条SQL语句的请求过程是什么样的？**
先来一个上帝视角图，下面就是 MySQL 执行一条 SQL 查询语句的流程，也从图中可以看到 MySQL 内部架构里的各个功能模块。

![img](https://cdn.xiaolincoding.com//picgo/1720155840218-b95c4217-6502-42b8-bcc5-384b297de75d.png)

- 连接器：建立连接，管理连接、校验用户身份；
    
- 查询缓存：查询语句如果命中查询缓存则直接返回，否则继续往下执行。MySQL 8.0 已删除该模块；
    
- 解析 SQL，通过解析器对 SQL 查询语句进行词法分析、语法分析，然后构建语法树，方便后续模块读取表名、字段、语句类型；
    
- 执行 SQL：执行 SQL 共有三个阶段：
    
    - 预处理阶段：检查表或字段是否存在；将 `select *` 中的 `*` 符号扩展为表上的所有列。
        
    - 优化阶段：基于查询成本的考虑， 选择查询成本最小的执行计划；
        
    - 执行阶段：根据执行计划执行 SQL 查询语句，从存储引擎读取记录，返回给客户端；

-----
**2.讲一讲SQL引擎**
- 答：
	- innodb存储引擎：是MySQL默认的存储引擎，也是最重要、使用最广泛的存储引擎。具有ACID事务支持、行级锁、外键约束等特性。它适用于高并发的读写操作，支持较好的数据完整性和并发控制。
		- innodb的数据存储在表空间中表空间是由Innodb管理的一个黑箱，由一系列数据文件组成。Innodb将每个表的索引与数据存储在单独的一个文件中。
		- innodb表是基于聚簇索引建立，聚簇索引对主键查询有很高的性能。不过他的二级索引中必须包含主键列。
	- MyISAM存储引擎：5.1版本以前MyISAM是默认的存储引擎。MyISAM提供了大量的特性，包括全文索引、压缩，空间函数等，**但是MyISAM不支持事务、行级锁和外键约束，缺陷就是崩溃后无法安全恢复**。
		- MyISAM会将表存储在两个文件中，一个数据文件一个索引文件，分别以.myd和.myi作为后缀。MyISAM表可以包含动态行和静态行。
		- **特性**：
			- **加锁与并发**：MyISAM对整张表加锁。
			- **修复**：对于MyISAM表，MySQL可以手工或者自动执行检查和修复操作。
			- **索引**：对于MyISAM表，即使是BLOB和TEXT等长字段，也可以基于前500个字符创建索引。MyISAM也支持全文索引，这是一种基于分词创建的索引，可以支持复杂查询。
			- **延迟更新索引键**：创建MyISAM表的时候，如果指定了DELAY_KEY_WRITE选项，每次执行修改完成时，不会立即将修改的索引数据写入磁盘，而是会写到缓冲区。
			- **MyISAM压缩表**：如果表在创建并导入数据以后，不会进行修改操作，那么这样的表或许适合采用MyISAM表压缩。可以使用myisampack打包。

-----
**3.MySQL的Innodb为什么是默认的存储引擎**
InnoDB引擎在事务支持、并发性能、崩溃恢复等方面具有优势，因此被MySQL选择为默认的存储引擎。

- 事务支持：InnoDB引擎提供了对事务的支持，可以进行ACID（原子性、一致性、隔离性、持久性）属性的操作。Myisam存储引擎是不支持事务的。
- 并发性能：InnoDB引擎采用了行级锁定的机制，可以提供更好的并发性能，Myisam存储引擎只支持表锁，锁的粒度比较大。
- 崩溃恢复：InnoDB引引擎通过 redolog 日志实现了崩溃恢复，可以在数据库发生异常情况（如断电）时，通过日志文件进行恢复，保证数据的持久性和一致性。Myisam是不支持崩溃恢复的。

-----
**4.Innodb与MyISAM的区别是什么？**
- **事务**：InnoDB 支持事务，MyISAM 不支持事务，这是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一。
- **索引结构**：InnoDB 是聚簇索引，MyISAM 是非聚簇索引。聚簇索引的文件存放在主键索引的叶子节点上，因此 InnoDB 必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。而 MyISAM 是非聚簇索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。
- **锁粒度**：InnoDB 最小的锁粒度是行锁，MyISAM 最小的锁粒度是表锁。一个更新语句会锁住整张表，导致其他查询和更新都会被阻塞，因此并发访问受限。
- **count 的效率**：InnoDB 不保存表的具体行数，执行 select count(*) from table 时需要全表扫描。而MyISAM 用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快。
聚簇索引B+tree
```lua
                           [ Root Page ]
                 +--------------------------------+
                 |  (PK=20)   (PK=50)   (PK=80)   |
                 |   /  \       /  \       /  \   |
                 +--/----\-----/----\-----/----\--+
                   /      \     /      \     /      
                  v        v   v        v   v
            [Internal]  [Internal]  [Internal]
          +-----------+-----------+-----------+
          | PK=10 ... | PK=35 ... | PK=65 ... |
          +-----+-----+-----+-----+-----+-----+
                |           |           |
                v           v           v

     +------------------+   +------------------+   +------------------+
     |   Leaf Page L1   |<->|   Leaf Page L2   |<->|   Leaf Page L3   |<-> ...
     +------------------+   +------------------+   +------------------+
     | (PK=1, row data) |   | (PK=21,row data) |   | (PK=51,row data) |
     | (PK=5, row data) |   | (PK=28,row data) |   | (PK=60,row data) |
     | (PK=9, row data) |   | (PK=34,row data) |   | (PK=79,row data) |
     +------------------+   +------------------+   +------------------+
```

----
**5.数据管理里，数据文件大体分成哪几种数据文件？**
我们每创建一个 database（数据库） 都会在 /var/lib/mysql/ 目录里面创建一个以 database 为名的目录，然后保存表结构和表数据的文件都会存放在这个目录里。

比如，我这里有一个名为 my_test 的 database，该 database 里有一张名为 t_order 数据库表。

![img](https://cdn.xiaolincoding.com//picgo/1716792105334-854b63c4-0b44-43c9-b808-c5efe4f602fd.webp)

然后，我们进入 /var/lib/mysql/my_test 目录，看看里面有什么文件？

```shell
[root@xiaolin ~]#ls /var/lib/mysql/my_test
db.opt  
t_order.frm  
t_order.ibd
```

可以看到，共有三个文件，这三个文件分别代表着：

- db.opt，用来存储当前数据库的默认字符集和字符校验规则。
- t_order.frm ，t_order 的表结构会保存在这个文件。在 MySQL 中建立一张表都会生成一个.frm 文件，该文件是用来保存每个表的元数据信息的，主要包含表结构定义。
- t_order.ibd，t_order 的表数据会保存在这个文件。表数据既可以存在共享表空间文件（文件名：ibdata1）里，也可以存放在独占表空间文件（文件名：表名字.ibd）。这个行为是由参数 innodb_file_per_table 控制的，若设置了参数 innodb_file_per_table 为 1，则会将存储的数据、索引等信息单独存储在一个独占表空间，从 MySQL 5.6.6 版本开始，它的默认值就是 1 了，因此从这个版本后， MySQL 中每一张表的数据都存放在一个独立的 .ibd 文件。

-------
**6.索引是什么？有什么好处？**
- 答：索引类似于书籍的目录，可以减少查询的扫描量，如果检索时没用用到索引，就会全表扫描，此时时间复杂度是O(n)。
	- 如果用到了索引，那么查询的时候，可以基于二分查找算法，通过索引快速定位到目标数据， mysql 索引的数据结构一般是 b+树，其搜索复杂度为O(logdN)，其中 d 表示节点允许的最大子节点个数为 d 个。

-------
**7.讲讲索引的分类是什么？**
MySQL可以按照四个角度来分类索引。

- 按「数据结构」分类：**B+tree索引、Hash索引、Full-text索引**。
- 按「物理存储」分类：**聚簇索引（主键索引）、二级索引（辅助索引）**。
- 按「字段特性」分类：**主键索引、唯一索引、普通索引、前缀索引**。
- 按「字段个数」分类：**单列索引、联合索引**。

在创建表时，InnoDB 存储引擎会根据不同的场景选择不同的列作为索引：

- 如果有主键，默认会使用主键作为聚簇索引的索引键（key）；
- 如果没有主键，就选择第一个不包含 NULL 值的唯一列作为聚簇索引的索引键（key）；
- 在上面两个都没有的情况下，InnoDB 将自动生成一个隐式自增 id 列作为聚簇索引的索引键（key）；
每一种存储引擎支持的索引类型不一定相同，我在表中总结了 MySQL 常见的存储引擎 InnoDB、MyISAM 和 Memory 分别支持的索引类型。

![img](https://cdn.xiaolincoding.com//picgo/1719803663459-11b9a82a-6bf2-46cd-b882-e0b85e5a4256.png)

-----
**8.HASH索引的使用场景是什么？**
- 答：
	- **优点**：哈希索引优势是等值查询极快、能直接通过哈希函数定位数据位置，
	- **缺点**：而短板是不支持范围查询、排序和前缀匹配，所以使用场景必然是那些以等值查询为核心，且不需要复杂查询操作的场景。

比如 MySQL 的 Memory 存储引擎，默认就用哈希索引。因为内存表本身是基于内存存储的，追求极致的查询速度，而这类场景通常都是简单的等值查询，比如缓存用户登录信息，通过用户 ID 快速查找对应的登录状态、权限信息，这时候哈希索引能直接通过用户 ID 计算哈希值，定位到数据所在的桶，查询效率接近 O(1)，比 B+ 树索引的等值查询更快。

-----
**9.聚簇索引和非聚簇索引的区别是什么？**
- 答：
	- 1.聚簇索引中完整的数据和索引存在一起，叶子节点中保存了完整的行，非聚簇索引的叶子节点存的是指向数据的地址/主键
	- 2.聚簇索引数据和索引在一起，可以直接找到完整数据，而非聚簇索引是需要找到主键，然后再回表。
	- 3.聚簇索引在范围查询和排序查询时效率更高，不需要回表，非聚簇查询在使用覆盖索引时效率更高，他不需要读完整的行。
	- 4.聚簇索引是基于主键的，只能有一个，非聚簇索引可以有多个。

-----
**10.什么字段适合当主键？**
- 答：适合做主键的字段需要具有唯一性、非空的属性，字段最好具有递增的特性，不建议用业务数据做主键，因为我们无法预测未来会不会因为业务需要，而出现业务字段重复或者重用的情况。

------
**11.为什么不建议用性别字段做索引？**
- 答：
	- **性能低**：字段区别度低，索引的价值 = 尽可能过滤掉大量数据。
	- **优化器往往不会使用**：索引扫描 + 回表成本 > 全表扫描。
	- **额外成本大于收益**。

-------
**12.表中十个字段，你主键用自增ID还是UUID，为什么？**
- 答：
	- 使用自增字段做主键。uuid相对于自增id来说是无序的。所以innodb无法每次把新的数据插入到最后，这个过程会带来很多额外的开销。
	- 无序的插入会导致想要写入的页不在内存中，增加IO开销。
	- 因为写入是无序的索引，会经常页分裂，经常的移动数据分配空间，增加开销。
	- 由于频繁的分裂可能导致碎片增多。

------
**13.MySQL中的存储引擎是如何实现的**
- 答：
	- MySQL使用B+tree实现innodb存储引擎。
	- B+tree是一种多叉树，叶子节点存储完整数据，非叶子节点只存放索引，并且底层叶子节点是一个链表。并且索引值按照顺序摆放。非叶子节点中的索引值是其孩子节点中的最小值。

----
**14.查询数据时，查询到叶子节点，之后查找数据是如何操作的？**
- 答：
	- 叶子节点中数据是用链表连起来的，优点是增删效率高，缺点是查询效率低，因此数据页中会有一个目录页的数据结构，就像一本书中目录保存章节一样，每几条数据为一组，目录页中一个槽位指向一个组。查找记录的时候就可以使用二分法查找。快速定位到数据应该在那个组，然后在遍历该槽位。

------
**15.MySQL为什么用B+树结构？和其他结构比的优点？**
- 答：
	- **B**+ 树高度低，IO 次数极少（最关键）
		- B+ 树的特点：
		- 一个节点 = 一个磁盘页
		- 一个节点可以存 **几百～上千个 key**
		- 树高通常只有 **2～4 层**
			- 只需要3次IO（IO次数稳定）
	- 所有数据都在叶子节点上，叶子节点天然有序、保存完整数据，可以范围查询，顺序IO性能稳定。

-----
**16.MySQL为什么不用跳表**
- 答：B+ 树高度低，IO 次数极少（最关键），B+树在3层时，存储的数据量已经达到千万级，同样的数据量，跳表需要多层，增加了IO次数。

------
**17.联合索引的实现原理？**
- 答：联合索引本质上是一个按“多个列顺序拼接”组成 key 的 B+ 树索引，  
索引项按照最左列 → 次左列 → … 的字典序排序。

------
**18.创建联合索引时需要注意什么？**
- 答：按照最左匹配原则，经常用到的，选择性接近1的放在左边。

-----
**19.联合索引(a,b,c) ，查询条件 where b > xxx and a = x 会生效吗**
- 答：SQL 里 `WHERE b > xxx AND a = x` 和 `WHERE a = x AND b > xxx` **在逻辑上等价**，MySQL 优化器会把条件做等价变换、选择更优的访问路径，所以仍然可以用到联合索引 `(a,b,c)` 的**最左前缀**部分。（**一旦联合索引中某一列使用了范围查询，  
后续列不能再用于索引定位，所以c不能用索引了**）

------
**20.索引失效有哪些？**
- 答：
	- 一：不满足最左匹配原则
	- 二：在索引上使用函数表达式
	- 三：隐式类型转换
	- 四：LIKE以%开头，（“张%”是可以的）
	- 五：OR条件中存在非索引字段解决方式：给 b 建索引，或拆成 UNION ALL
	- 六：范围查询导致联合索引截断，（a,b,c） 如果b用范围查询，c就被截断了，不能用索引
	- 七：使用 NOT、!=、<>、NOT IN
	- 八：IS NOT NULL（可能失效）如果命中大量数据，可能放弃使用索引
	- 九：ORDER BY顺序与索引顺序不一致
	- 十：表的数据量过小
	- 十一：字段区分度（选择性）过低

----
**21.什么情况下需要回表？**
- 答：当使用二级索引时，查询的内容不在二级索引中，就需要先按索引找到对应叶子节点，再根据主键，回表找到对应的数据。

-----
**22.什么是覆盖索引？**
- 答：覆盖索引是指一个索引包含了所有要查询的字段。

----
**23.索引已经建好了，那我再插入一条数据，索引会有哪些变化？**
- 答：可能会导致B+树的调整和索引信息的更新，这些通常由数据库自动处理，以保证数据的一致性和有效性。如果插入的叶子节点满，那可能触发叶子节点的分裂。

---------
**24.索引的优缺点**
- 答：
	- **优点**：
		- 提高查询速度  
		    索引可以大幅减少数据扫描范围，避免全表扫描，尤其在大表中效果明显。
		    
		- 减少磁盘 IO 次数  
		    索引基于 B+ 树结构，树高低，查找路径短，能用更少的磁盘 IO 定位数据。
		    
		- 加速 WHERE 条件过滤  
		    对常用的查询条件建立索引，可以快速定位符合条件的记录。
		    
		- 提高 ORDER BY 和 GROUP BY 性能  
		    索引本身有序，可以避免额外排序（Using filesort），提高排序和分组效率。
		    
		- 支持快速范围查询  
		    B+ 树叶子节点有序且通过链表连接，适合 BETWEEN、>、< 等范围查询。
		    
		- 有助于避免全表扫描  
		    在大数据量表中，合理索引是性能优化的关键手段。
		    
		- 唯一索引可保证数据唯一性  
		    PRIMARY KEY、UNIQUE INDEX 能从结构层面防止重复数据。
		    
		- 覆盖索引可避免回表  
		    查询字段全部在索引中时，可直接从索引返回数据，减少 IO。
	- **缺点**：
		- 占用额外存储空间  
		    索引本身需要磁盘空间，索引越多，占用空间越大。
		    
		- 降低写操作性能  
		    INSERT、UPDATE、DELETE 时需要维护索引，增加额外开销。
		    
		- 索引维护成本高  
		    数据变动会引起索引页分裂、合并，影响性能。
		    
		- 索引设计不当会适得其反  
		    低区分度字段、无效索引反而会拖慢查询。
		    
		- 增加数据库调优复杂度  
		    索引过多会影响优化器选择执行计划。
		    
		- 并非所有查询都适合使用索引  
		    小表、返回大量数据的查询，索引可能不如全表扫描。
		    
		- 索引无法解决所有性能问题  
		    复杂业务瓶颈往往在 SQL 设计、表结构、IO、锁等层面。

-------
**25.索引优化**
- 答：
- 控制索引数量  
    索引不是越多越好，避免冗余索引。
    
- 删除长期不用的索引  
    减少写入开销，提高整体性能。
    
- 定期更新统计信息  
    执行 ANALYZE TABLE 保证优化器判断准确。
    
- 避免频繁重建大索引  
    大表建索引需注意锁和业务影响。
    
- 合理拆分大表  
    当单表过大时，索引效率也会下降。
    
- 选择合适的索引字段  
    优先为经常出现在 WHERE、JOIN、ORDER BY、GROUP BY 中的字段建索引。
    
- 优先选择区分度高的字段  
    重复值少的字段更容易过滤大量数据，索引价值更高。
    
- 合理使用联合索引  
    用一个联合索引替代多个单列索引，减少索引数量和维护成本。
    
- 遵循最左前缀原则  
    联合索引的字段顺序应与查询条件使用顺序一致。
    
- 等值条件在前，范围条件在后  
    联合索引顺序建议：等值查询字段 → 范围查询字段。
    
- 避免为低区分度字段单独建索引  
    如性别、状态字段，适合放在联合索引的后列。
    
- 使用自增主键作为聚簇索引  
    减少页分裂，提高插入和查询性能。

-------
**26.什么是前缀索引？**
- 答：前缀索引，是指 **只对字段值的前 N 个字符建立索引**，而不是对整个字段建立完整索引。
- 减少索引占用空间  
    对长字符串字段（如 URL、邮箱、地址）完整建索引成本很高。
    
- 提高索引页的利用率  
    key 更短，一个索引页能存更多条记录。
    
- 提升缓存命中率  
    更小的索引结构更容易被缓存在内存中。

1. 明显减少索引大小
    
2. 降低索引维护成本
    
3. 对前缀区分度较高的字段，查询性能接近完整索引

