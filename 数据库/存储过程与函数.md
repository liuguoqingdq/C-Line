## 一、 为什么需要存储程序？

在普通的开发模式中，逻辑通常写在 Java、Python 或 Go 的后端代码里。但当涉及到**频繁的数据核算、多表联动修改、或者严格的数据一致性业务**时，将逻辑下沉到数据库层有以下优势：

1. **减少网络损耗**：如果一个逻辑需要查询 5 次数据库才能完成，后端与数据库之间会有 5 次往返（Round-trip）；而存储过程只需 1 次。
    
2. **执行计划缓存**：MySQL 对存储程序会进行预编译和缓存，执行效率通常高于动态 SQL。
    
3. **安全性**：你可以不给用户直接操作表的权限，只允许他们调用特定的存储过程，从而实现精确的行级或逻辑级权限控制。
    

---

## 二、 存储过程（Stored Procedures）详解

存储过程可以看作是数据库里的“脚本”，它不返回值，但可以通过参数改变状态或返回结果集。

### 1. 基础语法与“定界符”的秘密

在控制台写存储过程时，必须使用 `DELIMITER`。因为存储过程内部包含很多分号（`;`），如果不更改定界符，MySQL 看到第一个分号就会认为语句结束了，从而报错。

SQL

```
DELIMITER //  -- 将结束符临时改为 //
CREATE PROCEDURE 过程名(参数列表)
BEGIN
    -- 这里写 SQL 逻辑
END //
DELIMITER ;   -- 将结束符改回 ;
```

### 2. 参数类型：IN, OUT, INOUT 的深度理解

这是存储过程的核心，理解它们就像理解编程语言中的“值传递”与“引用传递”。

- **IN (输入参数)**：默认类型。参数从外部传入，过程内部可以修改它，但**修改不会影响外部变量**。
    
- **OUT (输出参数)**：初始值为 `NULL`。过程内部给它赋值后，**外部变量会同步改变**。
    
- **INOUT (输入输出参数)**：结合了两者。外部传入的值可以被使用，内部修改后外部也会变。
    

---

### 3. 高难度实例：自动化阶梯折扣引擎

**需求**：根据用户的消费金额（IN），计算本次应付金额，并输出该用户累计节省的总额（OUT），同时根据消费额度更新用户的会员等级（过程内逻辑）。


```SQL
DELIMITER //

CREATE PROCEDURE p_calculate_discount(
    IN  p_user_id INT,
    IN  p_raw_amount DECIMAL(10,2),
    OUT p_final_amount DECIMAL(10,2),
    OUT p_total_saved  DECIMAL(10,2)
)
BEGIN
    -- 1. 定义局部变量 (必须放在 BEGIN 后的第一行)
    DECLARE v_user_level INT DEFAULT 0;
    DECLARE v_discount_rate DECIMAL(3,2) DEFAULT 1.0;

    -- 2. 获取当前用户等级
    SELECT level INTO v_user_level FROM users WHERE id = p_user_id;

    -- 3. 复杂分支逻辑：判定折扣
    CASE 
        WHEN v_user_level >= 5 AND p_raw_amount > 1000 THEN 
            SET v_discount_rate = 0.70; -- 7折
        WHEN v_user_level >= 3 OR p_raw_amount > 500 THEN 
            SET v_discount_rate = 0.85; -- 85折
        ELSE 
            SET v_discount_rate = 0.95; -- 95折
    END CASE;

    -- 4. 计算结果赋值给 OUT 参数
    SET p_final_amount = p_raw_amount * v_discount_rate;
    SET p_total_saved = p_raw_amount - p_final_amount;

    -- 5. 执行数据更新
    UPDATE users SET total_spent = total_spent + p_final_amount WHERE id = p_user_id;

END //

DELIMITER ;
```

**调用方法：**


```SQL
-- 定义会话变量接收结果
CALL p_calculate_discount(1, 1200.00, @final, @saved);
SELECT @final AS '实付', @saved AS '节省';
```

---

## 三、 存储函数（Stored Functions）详解

函数与过程最大的区别在于：**函数是为了“计算”并“返回”一个值**。它必须有且只有一个返回值，且可以在 `SELECT` 语句中直接嵌套。

### 1. 关键属性：Deterministic (确定性)

在创建函数时，你会看到 `DETERMINISTIC`、`READS SQL DATA` 等声明。

- **DETERMINISTIC**：指相同的输入永远得到相同的输出（如 `abs(x)`）。
    
- **NOT DETERMINISTIC**：输出具有随机性（如 `now()`）。
    
- **重要性**：在主从复制环境下，如果不声明这些属性，MySQL 可能会拒绝创建函数，因为无法保证主从库执行结果一致。
    

### 2. 高难度实例：复利投资计算器

需求：输入本金、年化收益率和年限，通过循环计算复利结果。这里我们使用 LaTeX 公式展示计算逻辑：

$$Result = Principal \times (1 + rate)^{years}$$


```SQL
DELIMITER //

CREATE FUNCTION f_calculate_compound_interest(
    p_principal DECIMAL(15,2),
    p_rate DECIMAL(5,4),
    p_years INT
) 
RETURNS DECIMAL(15,2)
DETERMINISTIC
BEGIN
    DECLARE v_counter INT DEFAULT 0;
    DECLARE v_result DECIMAL(15,2);
    
    SET v_result = p_principal;

    -- 使用 WHILE 循环模拟每年的复利滚存
    WHILE v_counter < p_years DO
        SET v_result = v_result * (1 + p_rate);
        SET v_counter = v_counter + 1;
    END WHILE;

    RETURN v_result;
END //

DELIMITER ;
```

**DELIMITER是结束符设定，原来‘;’是结束符，DELIMITER //之后就是 ‘//’ 是结束符**
```SQL
#创建过程，搜索某个员工的管理者是谁
delimiter //
create procedure emp_manager_name(IN emn varchar(25), OUT emm varchar(25))
begin
	select last_name into emm
	from employees
	where employee_id = (
		select manager_id
		from employees
		where last_name=emn
	);
end //
delimiter ;

set @emn := 'olsen';
call emp_managet_name(@emn,@emm);

select @emm;
```

**使用场景：**

```SQL
-- 直接在查询中使用，就像使用自带函数一样
SELECT name, f_calculate_compound_interest(balance, 0.05, 10) AS '十年后预期' FROM accounts;


//可以直接调用
CALL f_calculate_compound_interest(balance, 0.05, 10);
```

**如何使用返回值**
```SQL
DELIMITER //
create procedure show_min_salary(out ms DECIMAL(10,2))
BEGIN
	SELECT MIN(salary) INTO ms
	FROM employees;
END //
DELIMITER ;

//调用
CALL show_min_salary(@ms);
//使用
select @ms

//如果参数是IN，有两种调用方式
#1
CALL func('变量');
#2
SET @arg := '变量'；
CALL func(@arg);
```

---

## 四、 核心差异对比：深度总结

|**特性**|**存储过程 (Procedure)**|**存储函数 (Function)**|
|---|---|---|
|**关键字**|`PROCEDURE`|`FUNCTION`|
|**返回值**|不返回任何值，但能返回多个 `OUT` 参数|必须返回一个值（`RETURNS` + `RETURN`）|
|**调用方式**|使用 `CALL` 语句独立调用|嵌入在 SQL 表达式中（如 `SELECT`, `WHERE`）|
|**内部逻辑**|可以执行 `UPDATE`, `DELETE` 等任何操作|虽然能改数据，但通常只建议用于计算（只读）|
|**事务处理**|允许 `COMMIT` / `ROLLBACK`|不允许（或极大限制）|

---

## 五、 变量的作用域 (Scope)

在存储程序中，变量分为三种，混淆它们是很多错误的根源：

1. **局部变量 (Local Variable)**：
    
    - 定义：在 `BEGIN...END` 块中使用 `DECLARE` 定义。
        
    - 生命周期：仅在当前的 `BEGIN...END` 块执行期间有效。
        
2. **会话变量 (User Variable)**：
    
    - 定义：以 `@` 开头，如 `@my_val`。
        
    - 生命周期：在整个数据库连接（会话）期间有效，跨过程也能访问。
        
3. **系统变量**：
    
    - 定义：以 `@@` 开头，如 `@@max_connections`。用于控制数据库全局或当前会话的行为。
        

---

## 六、 进阶技巧：循环控制

除了上面例子中的 `WHILE`，MySQL 还提供了 `REPEAT` 和 `LOOP`：

- **REPEAT**：先执行一次逻辑，再判断条件（类似于 `do-while`）。
    
- **LOOP**：死循环，必须配合 `LEAVE`（跳出循环）和 `ITERATE`（跳过本次，开始下次）使用。
    

**LOOP 例子：**

```SQL
my_loop: LOOP
    IF some_condition THEN
        LEAVE my_loop; -- 相当于 break
    END IF;
    -- 业务代码
END LOOP my_loop;
```

---

## 七、 使用存储程序的“红线” (不足与风险)

虽然存储程序很强大，但在大型互联网架构中要谨慎使用：

1. **调试困难**：MySQL 几乎没有好用的单步调试工具，只能靠打印日志调试。
    
2. **压力偏移**：逻辑运行在数据库 CPU 上。数据库往往是系统的瓶颈，如果在数据库里跑大量计算，会导致整个系统卡死且难以横向扩容。
    
3. **可移植性差**：MySQL 的存储程序语法与 Oracle、SQL Server 差异巨大，一旦用了，以后想换数据库就得重写所有业务逻辑。