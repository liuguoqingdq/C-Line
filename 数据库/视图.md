### 一、 核心定义：什么是视图？

从形式上看，视图表现得像一张**“虚拟表”**（Virtual Table）。它拥有行和列，你也可以像查询普通表一样对它执行 `SELECT` 操作。

但从本质上讲，视图**并不在数据库中存储真实的数据**。它仅仅是一个**存储在数据库中的 SQL 查询语句**。当你查询视图时，数据库引擎会实时执行这个预定义的查询，并将结果呈现给你。

---

### 二、 逻辑架构：视图是如何工作的？

为了理解视图，我们可以将其视为一种**“查询宏”**（Query Macro）：

1. **定义阶段**：你编写一个复杂的 SQL（涉及多表连接、过滤、聚合），并给它起个名字。
    
    - `CREATE VIEW v_order_summary AS SELECT ...`
        
2. **调用阶段**：当你执行 `SELECT * FROM v_order_summary` 时。
    
3. **解析阶段**：数据库引擎会自动将视图名称替换为它背后的原始 SQL 语句，并在底层基础表（Base Tables）上运行。
    

---

### 三、 实战价值：为什么要使用视图？

采用“端到端”的视角来看，视图在企业级架构中扮演了以下关键角色：

#### 1. 简化复杂的查询（抽象性）

在大型系统中，获取一份报表可能需要连接（JOIN）5、6 张表。通过视图，你可以将这些复杂的逻辑封装起来。开发人员只需要查询视图，而不需要关心底层繁琐的关联逻辑。

#### 2. 数据的安全性（权限控制）

视图可以作为一种**安全屏障**。

- **场景**：你有一张包含“员工姓名”、“基本工资”和“银行卡号”的表。
    
- **做法**：你可以创建一个只包含“员工姓名”的视图给普通查询人员。这样，他们既能看到姓名，又无法接触到敏感的财务数据。
    

#### 3. 逻辑独立性（解耦）

如果底层的表结构发生了变化（例如拆分了表或重命名了字段），你只需要修改视图背后的 SQL 语句，而不需要修改所有引用了该表的上层应用程序。这大大降低了系统的维护成本。

---

### 四、 认知边界：视图的局限性

为了体现“知其然亦知其所以然”的思考，我们也必须正视视图的局限：

1. **性能开销**：由于视图是实时执行的，如果视图背后的 SQL 非常复杂，每次查询都会产生巨大的计算开销。
    
    > **进阶提示**：针对高性能需求，数据库提供了**物化视图（Materialized View）**，它会物理存储查询结果，但这涉及数据同步的复杂性。
    
2. **更新限制**：并非所有视图都是可更新的（UPDATE）。涉及聚合函数（SUM/COUNT）、去重（DISTINCT）或多表连接的视图通常无法直接进行写操作。

## 1. 导致视图不可更新的常见情况

如果视图的 `SELECT` 语句中包含以下任何一种结构，该视图就是**不可更新**的：

### ① 聚合函数 (Aggregate Functions)

使用了 `SUM()`、`MIN()`、`MAX()`、`COUNT()`、`AVG()` 等。

- **原因**：聚合结果是多行汇总而成的，数据库不知道更新聚合值该如何拆分到原始行中。
    

### ② 分组与去重 (GROUP BY, HAVING, DISTINCT)

使用了 `DISTINCT`、`GROUP BY` 或 `HAVING` 子句。

- **原因**：这些操作会将多条记录合并或筛选，破坏了 1:1 的映射关系。
    

### ③ 集合操作 (UNION / UNION ALL)

使用了 `UNION` 或 `UNION ALL`。

- **原因**：数据来自多个结果集的合并，结构上无法反向推导。
    

### ④ 特定类型的连接 (JOIN)

虽然某些简单的 `JOIN` 视图是可更新的，但以下情况通常不行：

- 更新涉及多个表（MySQL 要求一次 `UPDATE` 只能修改视图中属于同一个基础表的列）。
    
- 某些复杂的 `OUTER JOIN`（外连接）。
    

### ⑤ 子查询 (Subqueries)

在 `SELECT` 列表或 `WHERE` 子句中包含了引用了 `FROM` 子句中表的子查询。

### ⑥ 常量或表达式列

如果某列是由常量、数学表达式或函数生成的（例如 `SELECT price * 0.8 AS discount_price`），那么这一列是不可更新的（尽管视图的其他原始列可能仍可更新）。


---
## 视图的实际操作（使用例子）

假设我们有两张表：

1. **`students` (学生表)**：`id`, `name`, `age`
    
2. **`scores` (成绩表)**：`student_id`, `subject`, `score`
    

### A. 创建视图

我们想创建一个视图，直接显示每个学生的姓名、科目和分数，省去每次都写 `JOIN` 的麻烦。


```SQL
CREATE VIEW v_student_scores AS
SELECT 
    s.name AS student_name,
    sc.subject,
    sc.score
FROM students s
JOIN scores sc 
ON s.id = sc.student_id;
```

```SQL
create VIEW V_emp(emp_id,NAME,emp_salary)
AS
SELECT id,name,salary
FROM employees
WHERE id>10;
```


```SQL
create VIEW emp_avg_sal AS
SELECT name,AVG(salary) avg_sal
FROM employees
WHERE department_id IS NOT NULL
GROUP BY department_id;
```


**利用视图对表中数据进行格式化**
```SQL
create view sufficient_info AS
select concat(e.last_name,'(',d.department_name,')') emp_info
FROM employees e JOIN department dep
ON e.`department_id` = d.`department_id`;
```

**基于视图创建视图**
```SQL
create view v1 AS
SELECT 属性
FROM 视图;
```

**查看视图结构**
```SQL
DESCRIBE v1;
```

**查看视图属性**
```SQL
SHOW TABLE STATUS LIKE v1;


//查看详细定义信息
SHOW CREATE VIEW v1;
```

### B. 使用视图

查询视图就像查询普通表一样：


```SQL
SELECT * FROM v_student_scores WHERE score > 90;
```

### C. 修改视图

如果你想在视图中增加“年龄”字段，可以使用 `OR REPLACE`：

```SQL
CREATE OR REPLACE VIEW v_student_scores AS
SELECT 
    s.name,
    s.age,
    sc.subject,
    sc.score
FROM students s
JOIN scores sc ON s.id = sc.student_id;
```

### D. 删除视图


```SQL
DROP VIEW IF EXISTS v_student_scores;
```





------
### 五、 总结与对比

| **特性**   | **数据表 (Base Table)** | **视图 (View)** |
| -------- | -------------------- | ------------- |
| **存储**   | 物理存储数据在磁盘            | 仅存储 SQL 逻辑定义  |
| **空间占用** | 占用实际磁盘空间             | 几乎不占用空间       |
| **数据来源** | 原始输入                 | 来源于底层基础表      |
| **主要目的** | 持久化存储数据              | 简化、安全、逻辑抽象    |

----
### 视图的不足
## 1. 性能开销 (Performance)

这是视图最常被诟病的一点。

- **实时计算**：MySQL 中的标准视图是**虚拟的**，它不存储数据。每次你查询视图时，数据库都必须重新执行视图定义中的基础 SQL 语句。如果视图包含多表 `JOIN`、子查询或复杂的函数，查询效率会显著降低。
    
- **缺乏“物化视图”支持**：与 Oracle 或 PostgreSQL 不同，MySQL 原生不支持**物化视图（Materialized View）**（即将查询结果物理存储在磁盘上并定期刷新）。这意味着在大数据量场景下，视图无法通过预存储结果来提速。
    
- **优化限制**：虽然 MySQL 尝试通过 `MERGE` 算法优化视图，但如果视图过于复杂（如包含 `GROUP BY` 或 `DISTINCT`），MySQL 会被迫使用 `TEMPTABLE`（临时表）算法，这会导致无法利用基础表的索引，性能大幅下降。
    

---

## 2. 维护负担 (Maintenance & Dependency)

视图与基础表之间存在强耦合关系，这给长期维护带来了挑战。

- **脆弱的依赖关系**：如果你修改了基础表的结构（例如重命名了一个字段或删除了一个表），依赖于该表的视图会立即失效（但 MySQL 在修改表时不会主动提醒你视图坏了）。只有当有人查询视图时，系统才会报错。
    
- **排错困难**：在嵌套视图（视图中引用视图）的情况下，一旦数据出错，开发者需要一层一层剥开视图定义去定位底层哪张表、哪个连接出现了逻辑错误。
    

---

## 3. 功能局限性 (Functional Constraints)

相比于普通表或存储过程，视图的功能受到很多限制。

- **索引限制**：你**不能在视图上创建索引**。视图的查询性能完全依赖于基础表上的索引。如果视图的逻辑导致索引失效（如对字段进行了运算），查询速度会非常慢。
    
- **禁止参数化**：视图不能接受参数。如果你需要根据不同输入动态过滤数据，视图无法胜任，通常需要改写为存储过程或函数。
    
- **特定语法的限制**：在某些旧版本的 MySQL 中，视图定义里不能包含子查询（虽然新版本已放宽限制，但依然存在不少边界限制）。
    

---

## 4. 开发中的“黑盒”陷阱 (Hidden Complexity)

视图容易给不知情的开发者造成错觉。

- **性能误判**：一名新进开发人员看到 `SELECT * FROM v_user_report` 可能会觉得这只是个简单的查询，但实际上这个视图背后可能关联了 10 张大表，导致一个简单的 `SELECT` 拖慢整个系统的数据库连接池。
    
- **更新受限**：正如我们在“不可更新视图”中讨论的，很多视图是只读的。如果开发时过度依赖视图，后续需要通过视图修改数据时会发现行不通，迫使重构代码。
    

---

## 5. 总结：何时应避免使用视图？

为了平衡利弊，建议在以下情况下慎用或避开视图：

| **场景**       | **建议**                          |
| ------------ | ------------------------------- |
| **超大规模数据量**  | 避免使用多表关联视图，建议在应用层处理逻辑或使用汇总表。    |
| **频繁变动的表结构** | 视图会增加重构成本，建议直接在代码中使用 SQL 或 ORM。 |
| **需要高性能响应**  | 视图的解析开销可能成为瓶颈，建议使用索引覆盖的原始查询。    |
| **多层嵌套**     | 绝对禁止视图套视图（超过 3 层），这会变成维护和性能的噩梦。 |

----
## 练习
**1**
```SQL
create or replace view employee_vu AS
select last_name,employee_id,department_id
FROM employees;
```

**2**
```SQL
select * from employee_vu;
```

**3**
```SQL
create or replace view employee_vu AS
select last_name,employee_id,department_id
FROM employees
WHERE department_id = 90;
```

**4**
```SQL
create or replace view emp_vl AS
select last_name,salary,email
FROM employees
WHERE phone_number LIKE '110%';
```

**5向emp_vl中插入一条数据是否可以**
```SQL
INSERT INTO emp_vl
VALUES ('tom','123@email','11012345');//插入失败，因为基表其他字段有非空约束
```

**6更新**
```SQL
UPDATE emp_vl
SET salary = salary + 1000;
```

**7删除**
```SQL
drop from emp_vl
where last_name = 'olsen';
```

**8**
```SQL
create or replace view emp_v2(dep_id,max_sal)
AS
select  department_id,max(salary)
from employees
Group by department_id;
having max(salary) > 12000
```