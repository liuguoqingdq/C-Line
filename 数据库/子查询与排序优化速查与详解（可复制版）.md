# 子查询优化（Subquery）与排序优化（ORDER BY）

> 这是一份**可直接复制到笔记/文档**的版本，围绕 MySQL 常见执行计划与索引策略整理（其他数据库大体同理）。

---

## 一、子查询优化（Subquery）

### 1）先判断：相关子查询 vs 非相关子查询

- **非相关子查询**：子查询不依赖外层表，可先算一次。
- **相关子查询**：子查询依赖外层每一行，可能会被执行很多次。

#### 相关子查询的典型慢法

```sql
SELECT *
FROM A
WHERE EXISTS (
  SELECT 1
  FROM B
  WHERE B.a_id = A.id AND B.status = 'ok'
);
```

如果没有合适索引，B 会被反复扫描。

✅ **优化关键：让 B 的条件可被“快速定位”**

- 建议索引：`B(a_id, status)`
- 或 `B(a_id)` + `status`（取决于选择性/过滤强度）

---

### 2）能用 JOIN / EXISTS 就别用 IN（大集合）

#### 2.1 `IN (子查询)` 返回集合大时常慢

```sql
SELECT *
FROM A
WHERE A.id IN (
  SELECT a_id
  FROM B
  WHERE status = 'ok'
);
```

✅ 改成 `EXISTS`（可早停）

```sql
SELECT *
FROM A
WHERE EXISTS (
  SELECT 1
  FROM B
  WHERE B.a_id = A.id AND B.status = 'ok'
);
```

✅ 或改成 `JOIN`（注意去重）

```sql
SELECT DISTINCT A.*
FROM A
JOIN B ON B.a_id = A.id
WHERE B.status = 'ok';
```

**索引建议：** `B(status, a_id)` 或 `B(a_id, status)`

- 如果 `status = 'ok'` 过滤很强（命中很少）→ `(status, a_id)` 更好
- 如果按 `a_id` 关联更常见 → `(a_id, status)` 更好

---

### 3）用派生表/CTE 先“缩小再 JOIN”

当 B 过滤很强，但 JOIN 还要带很多列时：

```sql
SELECT A.*, B.*
FROM A JOIN B ON ...
WHERE ...;
```

✅ 先只取 B 的主键集合（小集合）再 JOIN 回表

```sql
SELECT A.*, B.*
FROM A
JOIN (
  SELECT id, a_id
  FROM B
  WHERE status = 'ok'
) b0 ON b0.a_id = A.id
JOIN B ON B.id = b0.id;
```

**好处：**
- 减少宽表扫描
- 减少回表
- 让优化器更容易选到好的计划

---

### 4）避免在子查询里做无意义的 `ORDER BY / LIMIT`（除非必须）

很多人写：

```sql
SELECT *
FROM A
WHERE id IN (
  SELECT a_id
  FROM B
  ORDER BY create_time DESC
);
```

`IN` 只需要集合，排序白做。

✅ 去掉 `ORDER BY`

```sql
SELECT *
FROM A
WHERE id IN (SELECT a_id FROM B);
```

---

### 5）用半连接（Semi-Join）思路：只要“存在性”，不要取整行

你只需要判断“有没有”，就别取 B 的列：

```sql
-- ✅ EXISTS 只返回布尔存在性，通常更轻
WHERE EXISTS (SELECT 1 FROM B WHERE ...);
```

---

### 6）子查询里避免函数/隐式转换（否则索引失效）

```sql
WHERE EXISTS (
  SELECT 1
  FROM B
  WHERE DATE(B.t) = '2026-01-01'  -- ❌
);
```

✅ 改写（范围查询）

```sql
WHERE B.t >= '2026-01-01'
  AND B.t <  '2026-01-02';
```

---

### 7）子查询优化要看执行计划的信号（MySQL）

常见信号：

- `DEPENDENT SUBQUERY`：相关子查询（可能被执行多次）
- `Using temporary / Using filesort`：子查询内部在排序/临时表
- `rows` 很大：说明没过滤/没走索引

---

## 二、排序优化（ORDER BY）

### 1）排序慢的根因只有三类

1. 排序的数据量太大（需要排序的行数多）
2. 不能用索引顺序（只能 `filesort`）
3. 排序过程溢出到磁盘（内存不够/临时表落盘）

---

### 2）让 `ORDER BY` 走索引（最关键）

要想避免 MySQL 的 `Using filesort`，通常需要：

- `WHERE + ORDER BY` 使用同一个索引前缀
- 排序方向一致（MySQL 8 支持 `DESC` 索引更好）
- 避免在排序列上使用函数

#### 2.1 典型可走索引

```sql
SELECT id, create_time
FROM orders
WHERE user_id = ?
ORDER BY create_time DESC
LIMIT 20;
```

✅ 索引：

```sql
CREATE INDEX idx_orders_user_time
ON orders(user_id, create_time DESC);
```

---

### 3）排序 + LIMIT 的优化：先定位再回表

如果你要 `SELECT *`（宽表），但又只要前 20 条：

✅ 用覆盖索引先拿主键，再回表

```sql
SELECT o.*
FROM orders o
JOIN (
  SELECT id
  FROM orders
  WHERE user_id = ?
  ORDER BY create_time DESC
  LIMIT 20
) x ON x.id = o.id
ORDER BY o.create_time DESC;
```

**好处：**
- 排序时只排序索引里的小字段（id/time）
- 避免对大行排序

---

### 4）深分页（OFFSET 很大）= 排序灾难

```sql
SELECT *
FROM orders
ORDER BY id
LIMIT 20 OFFSET 100000; -- ❌
```

✅ 用 seek（游标翻页）

```sql
SELECT *
FROM orders
WHERE id > 100000
ORDER BY id
LIMIT 20;
```

或者按时间（稳定翻页）：

```sql
WHERE (create_time, id) < (?, ?)
ORDER BY create_time DESC, id DESC
LIMIT 20;
```

---

### 5）避免排序列不确定导致“额外排序”

如果你只 `ORDER BY create_time`，但 `create_time` 重复很多，分页会不稳定，还可能增加开销。

✅ 加第二排序键（通常主键）

```sql
ORDER BY create_time DESC, id DESC;
```

同时索引也要对应：

```sql
(user_id, create_time DESC, id DESC)
```

---

### 6）`GROUP BY` 的排序优化（本质也是排序/聚合）

`GROUP BY` 常常隐含排序/哈希聚合。

✅ 实战要点：
- 先过滤再 group
- group 列建索引
- 必要时用预聚合表

---

### 7）当排序不可避免：减少排序输入规模

- 更强的 WHERE 过滤
- 先取候选 id（小集合）再回表
- 只排序必要列（别 `SELECT *` 参与排序）

---

### 8）用 `EXPLAIN` 判断排序是否优化成功（MySQL）

看 `Extra`：

- ✅ 理想：`Using index` / 没有 `Using filesort`
- ⚠️ 需要优化：`Using filesort`、`Using temporary`

---

## 三、速查：常见子查询 + 排序“组合坑”

### 坑 1：子查询里 `ORDER BY` 但外层不需要顺序
→ 去掉子查询排序。

### 坑 2：相关子查询 + 内表无索引
→ 给内表 join/filter 列加复合索引，或改 JOIN/EXISTS。

### 坑 3：`ORDER BY + LIMIT + SELECT *`
→ 覆盖索引先取 id，再回表。

