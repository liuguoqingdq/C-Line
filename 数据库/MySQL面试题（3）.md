**1.事务的特性是什么？如何实现的？**
- 答：事物的四大特性ACID：
	- 1. **原子性**（Atomicity）
	- 含义：事务中的所有操作要么全部执行成功，要么全部不执行。
	- 2. **一致性**（Consistency）
	- 含义：事务执行前后，数据库都必须处于 **一致性状态**，满足约束规则。
	- 3. **隔离性**（Isolation）
	- 含义：多个事务并发执行时，一个事务的执行不应被其他事务干扰。
	- 4. **持久性**（Durability）
	- 含义：事务一旦提交，其修改结果将被永久保存，即使数据库崩溃也不会丢失。
- **原子性**是通过undo log(回滚)来保证的
- **持久性**是通过redo log来保证的
- **隔离性**是通过MVCC或锁机制来保证
- **一致性**通过持久性+原子性+隔离性保证


-------
**2.MySQL可能出现的与并发相关的问题**
- 答：
	- **与隔离性相关的：**
		- **脏读**：一个事物读到另一个事物未提交的数据
		- **不可重复读**：一个事物两次读取同一行，数据不一样
		- **幻读**：同一个事物内，两次读取数据，行数不一样
		- **丢失更新**：两个事物读取同一个数据，分别计算更新，后写的覆盖先写的，导致丢失更新。

-------
**3.哪些场景不适合脏读？**
- 答：脏读是一个事物读取到了另一个事物还未提交的数据。
- 金融和资金相关业务  
    例如转账、支付、余额查询、对账等。  
    如果发生脏读，可能读到未提交的扣款或加款，一旦回滚就会造成资金数据错误，风险极高。
    
- 下单、库存、扣减类业务  
    例如下单扣库存、秒杀、预约名额。  
    脏读可能导致读到临时扣减但最终回滚的库存数据，从而出现错误拒单或超卖、少卖的问题。
    
- 核心业务状态流转  
    例如订单状态变更、账户状态修改、审批流程。  
    如果读到未提交的状态变化，可能导致业务流程错乱。
    
- 写后立即读并依赖读结果继续写的业务  
    例如先读取余额，再判断是否足够，然后再扣款。  
    如果读到脏数据，后续逻辑就会建立在错误前提之上，非常危险。
    
- 报表、对账和审计类业务  
    例如财务报表、日终结算、对账系统。  
    脏读会导致数据前后不一致，报表结果无法复现。
    
- 需要结果稳定一致的查询场景  
    例如用户查询订单详情、客服查询用户状态。  
    脏读会导致同一时间查询结果不稳定，影响用户体验和信任。

------
**4.MySQL是怎样解决并发问题的？**
- 答：
	- 1）事务（ACID）  ：事务把一组操作当成一个整体，要么全成功，要么全失败。
	- 2）事务隔离级别  ：MySQL 通过事务隔离级别，控制并发事务之间的可见性。
	- 3）MVCC（多版本并发控制）  ：读不加锁，通过版本控制来解决并发读写冲突。
	- 4）锁机制（行锁、间隙锁等）：当涉及“修改数据”或“当前读”时，MySQL 必须加锁。

----
**5.事物的隔离级别有哪些？**
- 答：
	- **read uncommitted**:一个事物可以读到另一个事物未提交的数据。
	- 可能出现的问题：
		- **脏读**
		    
		- 不可重复读
		    
		- 幻读
	- **read committed**：一个事物只能读到已经提交的数据。
	- 可能出现的问题：
		- ❌ 脏读（被解决）
		    
		- ✅ 不可重复读
		    
		- ✅ 幻读
	- **repeatable read**：一个事物中，读取同一行数据，不会有变化。
	- 可能出现的问题：
		- ❌ 脏读（被解决）
		    
		- ❌ 不可重复读（被解决）
		    
		- ⚠️ 幻读（InnoDB 通过 MVCC + Next-Key Lock 在大多数场景下解决）
	- **SERIALIZABLE（串行化）**：所有事物串行执行，相当于给读取范围加锁。
	- 可能出现的问题
		- ❌ 脏读
		    
		- ❌ 不可重复读
		    
		- ❌ 幻读

|隔离级别|脏读|不可重复读|幻读|并发性能|
|---|---|---|---|---|
|READ UNCOMMITTED|✔️|✔️|✔️|⭐⭐⭐⭐|
|READ COMMITTED|❌|✔️|✔️|⭐⭐⭐|
|REPEATABLE READ|❌|❌|⚠️|⭐⭐|
|SERIALIZABLE|❌|❌|❌|⭐|

-------
**6.mysql默认的隔离级别？**
- 答：mysql默认级别是可重复读。但是并没有严格遵守。

----
**7.在可重复读的条件下，别人提交的数据本事物能看见吗？**
- 答：可重复读隔离级是由 MVCC（多版本并发控制）实现的，实现的方式是开始事务后（执行 begin 语句后），在执行第一个查询语句后，会创建一个 Read View，**后续的查询语句利用这个 Read View，通过这个 Read View 就可以在 undo log 版本链找到事务开始时的数据，所以事务过程中每次查询的数据都是一样的**，即使中途有其他事务插入了新纪录，是查询不出来这条数据的。
-----
**8.MySQL可重复读没有完全解决幻读问题**
**可重复读隔离级别下虽然很大程度上避免了幻读，但是还是没有能完全解决幻读**。

我举例一个可重复读隔离级别发生幻读现象的场景。以这张表作为例子：

![img](https://cdn.xiaolincoding.com//picgo/1717913623026-b457c2fd-d09d-4cd7-940a-eec8f2478e79.png)

事务 A 执行查询 id = 5 的记录，此时表中是没有该记录的，所以查询不出来。

```SQL
# 事务 A
mysql> begin;
Query OK, 0 rows affected (0.00 sec)

mysql> select * from t_stu where id = 5;
Empty set (0.01 sec)
```

然后事务 B 插入一条 id = 5 的记录，并且提交了事务。

```SQL
# 事务 B
mysql> begin;
Query OK, 0 rows affected (0.00 sec)

mysql> insert into t_stu values(5, '小美', 18);
Query OK, 1 row affected (0.00 sec)

mysql> commit;
Query OK, 0 rows affected (0.00 sec)
```

此时，**事务 A 更新 id = 5 这条记录，对没错，事务 A 看不到 id = 5 这条记录，但是他去更新了这条记录，这场景确实很违和，然后再次查询 id = 5 的记录，事务 A 就能看到事务 B 插入的纪录了，幻读就是发生在这种违和的场景**。

```SQL
# 事务 A
mysql> update t_stu set name = '小林coding' where id = 5;
Query OK, 1 row affected (0.01 sec)
Rows matched: 1  Changed: 1  Warnings: 0

mysql> select * from t_stu where id = 5;
+----+--------------+------+
| id | name         | age  |
+----+--------------+------+
|  5 | 小林coding   |   18 |
+----+--------------+------+
1 row in set (0.00 sec)
```

整个发生幻读的时序图如下：

在可重复读隔离级别下，事务 A 第一次执行普通的 select 语句时生成了一个 ReadView，之后事务 B 向表中新插入了一条 id = 5 的记录并提交。接着，事务 A 对 id = 5 这条记录进行了更新操作，在这个时刻，这条新记录的 trx_id 隐藏列的值就变成了事务 A 的事务 id，之后事务 A 再使用普通 select 语句去查询这条记录时就可以看到这条记录了，于是就发生了幻读。

因为这种特殊现象的存在，所以我们认为 **MySQL Innodb 中的 MVCC 并不能完全避免幻读现象**。

-----
**9.Mysql 设置了可重读隔离级后，怎么保证不发生幻读？**
- 答：**尽量在开启事务之后，马上执行 select ... for update 这类锁定读的语句**，因为它会对记录加 next-key lock，从而避免其他事务插入一条新记录，就避免了幻读的问题。

------
**10.串行隔离级别是如何实现的？**
- 答：是通过行级锁来实现的，序列化隔离级别下，普通的 select 查询是会对记录加 S 型的 next-key 锁，其他事务就没没办法对这些已经加锁的记录进行增删改操作了，从而避免了脏读、不可重复读和幻读现象。


-------
**11.介绍MVCC的原理**
- 答：
- MVCC允许多个事务同时读取同一行数据，而不会彼此阻塞，每个事务看到的数据版本是该事务开始时的数据版本。这意味着，如果其他事务在此期间修改了数据，正在运行的事务仍然看到的是它开始时的数据状态，从而实现了非阻塞读操作。

对于「读提交」和「可重复读」隔离级别的事务来说，它们是通过 Read View 来实现的，它们的区别在于创建 Read View 的时机不同，大家可以把 Read View 理解成一个数据快照，就像相机拍照那样，定格某一时刻的风景。

- 「读提交」隔离级别是在「每个select语句执行前」都会重新生成一个 Read View；
- 「可重复读」隔离级别是执行第一条select时，生成一个 Read View，然后整个事务期间都在用这个 Read View。

Read View 有四个重要的字段：

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/mysql/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/readview%E7%BB%93%E6%9E%84.drawio.png)

- m_ids ：指的是在创建 Read View 时，当前数据库中「活跃事务」的**事务 id 列表**，注意是一个列表，**“活跃事务”指的就是，启动了但还没提交的事务**。
- min_trx_id ：指的是在创建 Read View 时，当前数据库中「活跃事务」中事务 **id 最小的事务**，也就是 m_ids 的最小值。
- max_trx_id ：这个并不是 m_ids 的最大值，而是**创建 Read View 时当前数据库中应该给下一个事务的 id 值**，也就是全局事务中最大的事务 id 值 + 1；
- creator_trx_id ：指的是**创建该 Read View 的事务的事务 id**。

对于使用 InnoDB 存储引擎的数据库表，它的聚簇索引记录中都包含下面两个隐藏列：

![图片](https://cdn.xiaolincoding.com//picgo/f595d13450878acd04affa82731f76c5.png)

- trx_id，当一个事务对某条聚簇索引记录进行改动时，就会**把该事务的事务 id 记录在 trx_id 隐藏列里**；
- roll_pointer，每次对某条聚簇索引记录进行改动时，都会把旧版本的记录写入到 undo 日志中，然后**这个隐藏列是个指针，指向每一个旧版本记录**，于是就可以通过它找到修改前的记录。

在创建 Read View 后，我们可以将记录中的 trx_id 划分这三种情况：

![](https://cdn.xiaolincoding.com//picgo/1719905850875-89fa5b61-e48c-4171-9248-c966c8d474ce.webp)

一个事务去访问记录的时候，除了自己的更新记录总是可见之外，还有这几种情况：

- 如果记录的 trx_id 值小于 Read View 中的 min_trx_id 值，表示这个版本的记录是在创建 Read View **前**已经提交的事务生成的，所以该版本的记录对当前事务**可见**。
    
- 如果记录的 trx_id 值大于等于 Read View 中的 max_trx_id 值，表示这个版本的记录是在创建 Read View **后**才启动的事务生成的，所以该版本的记录对当前事务**不可见**。
    
- 如果记录的 trx_id 值在 Read View 的 min_trx_id 和 max_trx_id 之间，需要判断 trx_id 是否在 m_ids 列表中：
    
- 如果记录的 trx_id **在** m_ids 列表中，表示生成该版本记录的活跃事务依然活跃着（还没提交事务），所以该版本的记录对当前事务**不可见**。
    
- 如果记录的 trx_id **不在** m_ids列表中，表示生成该版本记录的活跃事务已经被提交，所以该版本的记录对当前事务**可见**。
    

**这种通过「版本链」来控制并发事务访问同一个记录时的行为就叫 MVCC（多版本并发控制）。**

### 可见性规则总结

假设：

- 当前行版本事务 ID = `trx_id`
    

|条件|是否可见|
|---|---|
|`trx_id == 自己事务ID`|✅ 可见|
|`trx_id < low_limit_id`|✅ 可见（已提交）|
|`trx_id ≥ up_limit_id`|❌ 不可见（未来事务）|
|`trx_id ∈ trx_ids`|❌ 不可见（未提交）|
|其他情况|✅ 可见|

-------
**12.一条update是不是原子性的？**
- 答：是原子性，主要通过锁+undolog 日志保证原子性的

- 执行 update 的时候，会加行级别锁，保证了一个事务更新一条记录的时候，不会被其他事务干扰。
- 事务执行过程中，会生成 undolog，如果事务执行失败，就可以通过 undolog 日志进行回滚。

------
**13.滥用事物或者在一个事物里有特别多的sql会怎么样？**
- 答：事务的资源在事务提交之后才会释放的，比如存储资源、锁。

如果一个事务特别多 sql，那么会带来这些问题：

- 如果一个事务特别多 sql，锁定的数据太多，容易造成大量的死锁和锁超时。
- 回滚记录会占用大量存储空间，事务回滚时间长。在[MySQL (opens new window)](https://cloud.tencent.com/product/cdb?from_column=20065&from=20065)中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值，sql 越多，所需要保存的回滚数据就越多。
- 执行时间长，容易造成主从延迟，主库上必须等事务执行完成才会写入binlog，再传给备库。所以，如果一个主库上的语句执行10分钟，那这个事务很可能就会导致从库延迟10分钟
