## 分支结构IF
### 一、 `IF()` 函数（用于 SQL 查询语句）

这是最常用的场景。它类似于 Excel 中的 `IF` 函数，或者编程语言中的三元运算符（`a ? b : c`）。它通常用于 `SELECT`、`UPDATE` 或 `DELETE` 语句中，用来对数据进行简单的转换。

#### 1. 语法

```SQL
IF(条件表达式, 值为真时的结果, 值为假时的结果)
```

#### 2. 常用示例

**场景：** 查询成绩表，分数大于 60 显示“及格”，否则显示“挂科”。


```SQL
SELECT 
    student_name,
    score,
    IF(score >= 60, '及格', '挂科') AS result
FROM exams;
```

**场景：** 嵌套使用（处理多重条件，但不建议层数太多，否则难以阅读）。

```SQL
-- 分类：大于90优秀，大于60及格，否则不及格
SELECT 
    score,
    IF(score >= 90, '优秀', IF(score >= 60, '及格', '不及格')) AS grade
FROM exams;
```

---

### 二、 `IF` 语句（用于存储过程/函数）

这种用法**只能**在存储过程（Stored Procedure）、函数（Function）或触发器（Trigger）的 `BEGIN ... END` 代码块内部使用。它是真正的流程控制语句，用来决定执行哪一段 SQL 代码。

#### 1. 语法

注意：必须以 `END IF;` 结尾（注意分号）。

```SQL
IF search_condition THEN
    statement_list; -- 如果条件为真，执行这里的代码
    
[ELSEIF search_condition THEN
    statement_list;] -- (可选) 其他条件
    
[ELSE
    statement_list;] -- (可选) 都不满足时执行
    
END IF;
```

#### 2. 常用示例

**场景：** 写一个存储过程，根据用户 ID 判断用户级别。如果积分 > 1000 是 VIP，否则是普通用户。

```SQL
DELIMITER //

CREATE PROCEDURE check_user_level(IN u_id INT)
BEGIN
    -- 定义一个局部变量存积分
    DECLARE u_points INT;
    DECLARE u_level VARCHAR(20);
    
    -- 获取积分
    SELECT points INTO u_points FROM users WHERE id = u_id;
    
    -- 【重点】IF 语句开始
    IF u_points > 1000 THEN
        SET u_level = 'VIP User';
    ELSEIF u_points > 500 THEN
        SET u_level = 'Gold User';
    ELSE
        SET u_level = 'Normal User';
    END IF; 
    -- 【重点】IF 语句结束
    
    -- 输出结果
    SELECT u_level;
END //

DELIMITER ;
```

```SQL
delimiter //
create procedure add_emp_salary(IN emp_id INT)
begin 
	declare emp_sal DECIMAL(10,2);
	declare hire_year DATE;
	select salary into emp_sal
	FROM employees
	where employee_id = emp_id;
	select dateiff(currdate(),hire_date)/365 INTO hire_year 
	from employees
	where employee_id = emp_id;
	
	IF emp_sal <5000 AND hire_year <5 
	THEN UPDATE employees
	SET salary =salary+500
	WHERE employee_id = emp_id;
	END IF;
END //
delimiter ; 
```


---

### 三、 总结与对比

|**维度**|**IF() 函数**|**IF ... END IF 语句**|
|---|---|---|
|**使用位置**|SELECT/UPDATE 语句中|存储过程/函数的 BEGIN...END 内部|
|**作用**|返回一个值（字符串、数字等）|控制程序的执行流程（执行哪段代码）|
|**结尾**|不需要 END IF|**必须**以 END IF; 结尾|
|**类比**|Excel 的 IF 公式|Java/Python 的 `if {} else {}`|

----
### CASE分支语句
MySQL 的 `CASE` 语句是 SQL 中最强大的**多条件分支**工具。它类似于编程语言中的 `Switch-Case` 或多重 `If-Else` 逻辑。

与 `IF` 相比，`CASE` 最大的优势在于**可读性更强**，且它是 **ANSI SQL 标准**（意味着在 Oracle、SQL Server、PostgreSQL 中也能通用，而 `IF()` 函数是 MySQL 特有的）。

`CASE` 有两种核心写法，以及两种使用场景（查询中使用 vs 存储过程中使用）。

---

### 一、 两种核心写法

无论是在查询中还是存储过程中，`CASE` 都支持以下两种语法结构：

#### 1. 简单函数模式 (Simple CASE)

**适用场景**：**等值匹配**（类似于 `switch (变量)`）。你有一个确定的字段，要拿它去和不同的值划等号。

- **语法**：
    

    ```SQL
    CASE <表达式/字段>
        WHEN <值1> THEN <结果1>
        WHEN <值2> THEN <结果2>
        ELSE <默认结果>
    END
    ```
    
- **注意**：这里不能写 `> 100` 这种范围判断，只能进行“等于”判断。
    

#### 2. 搜索模式 (Searched CASE)

**适用场景**：**范围判断**或**复杂逻辑**（类似于 `if ... else if ...`）。

- **语法**：
    
    
    ```SQL
    CASE
        WHEN <条件表达式1> THEN <结果1>
        WHEN <条件表达式2> THEN <结果2>
        ELSE <默认结果>
    END
    ```
    
- **注意**：`WHEN` 后面写的是完整的条件（如 `score > 90`）。
    

---

### 二、 场景 A：在 SQL 查询语句中使用 (`SELECT`)

这是 `CASE` 最常用的场景，用于将数据“转换”成人类易读的格式，或者进行统计。

#### 示例 1：状态码转文字 (简单模式)

假设数据库里 `gender` 存的是 1 和 2，你想显示为“男”和“女”。

```SQL
SELECT 
    name,
    CASE gender  -- 指定要判断的字段
        WHEN 1 THEN '男'
        WHEN 2 THEN '女'
        ELSE '未知'
    END AS gender_text
FROM users;
```

#### 示例 2：成绩等级划分 (搜索模式)

假设要根据分数划分等级，涉及范围判断，**必须**用搜索模式。


```SQL
SELECT 
    name,
    score,
    CASE 
        WHEN score >= 90 THEN '优秀' -- 第一条匹配后，通过！不再往下走
        WHEN score >= 60 THEN '及格'
        ELSE '挂科'
    END AS grade
FROM exams;
```

#### 示例 3：高级技巧——自定义排序 (`ORDER BY`)

这是一个非常实用的技巧。假设你想让 "VIP" 用户排在最前面，普通用户排后面，但这在字母表中 'V' 并不排在 'N' 前面。

```SQL
SELECT * FROM users
ORDER BY 
    CASE user_type
        WHEN 'VIP' THEN 1    -- VIP 赋予权重 1
        WHEN 'Normal' THEN 2 -- 普通赋予权重 2
        ELSE 3
    END ASC; -- 按权重 1, 2, 3 排序
```

#### 示例 4：行转列统计 (`SUM` + `CASE`)

这是面试常考题。如何统计“男生的总分”和“女生的总分”并显示在一行里？


```SQL
SELECT 
    SUM(CASE WHEN gender = 1 THEN score ELSE 0 END) AS male_total_score,
    SUM(CASE WHEN gender = 2 THEN score ELSE 0 END) AS female_total_score
FROM exams;
```

---

### 三、 场景 B：在存储过程中使用

在存储过程（Stored Procedure）中，`CASE` 可以用来控制程序的流程（执行不同的 SQL 语句），而不仅仅是返回一个值。

**关键区别**：

1. **结尾不同**：查询中用 `END` 结尾；存储过程中建议用 **`END CASE;`** 结尾。
    
2. **用途不同**：查询中是为了生成列；存储过程中是为了执行命令（如 `SET`, `UPDATE`）。
    

#### 示例：根据用户等级更新不同的表


```SQL
DELIMITER //

CREATE PROCEDURE update_user_benefit(IN u_id INT, IN u_type VARCHAR(20))
BEGIN
    CASE u_type
        WHEN 'VIP' THEN
            -- 如果是 VIP，更新 VIP 表，送积分
            UPDATE vip_table SET points = points + 100 WHERE user_id = u_id;
            
        WHEN 'Normal' THEN
            -- 如果是普通用户，只更新普通表
            UPDATE normal_table SET login_count = login_count + 1 WHERE user_id = u_id;
            
        ELSE
            -- 默认操作（必须要有 ELSE，否则如果匹配不到会报错）
            SELECT 'Unknown user type';
    END CASE; -- 注意这里是 END CASE;
END //

DELIMITER ;
```

---

### 四、 `CASE` 常见的一个“坑”

在存储过程中使用 `CASE` 语句时，**如果没有任何一个 `WHEN` 匹配成功，且没有写 `ELSE`**，MySQL 会抛出一个错误：

> `Case not found for CASE statement`

**解决方案**：永远养成写 `ELSE` 的习惯，哪怕在 `ELSE` 里写一个空的 `BEGIN END;` 或者记录一条错误日志。

---

### 总结

|**特性**|**CASE (简单模式)**|**CASE (搜索模式)**|
|---|---|---|
|**写法**|`CASE col WHEN val THEN ...`|`CASE WHEN col > val THEN ...`|
|**能力**|仅支持 **等于(=)** 判断|支持 **大于、小于、逻辑与或非**|
|**场景**|枚举值转换 (1->A, 2->B)|复杂逻辑分层 (分数段、工资阶梯)|

----
## LOOP语句

- **loop循环语句用来重复执行某些语句，搭配leave跳出循环。
在 MySQL 存储过程中，`LOOP` 是最基础、最灵活，但也是**最原始**的循环语句。

与 `WHILE`（先判断后执行）或 `REPEAT`（先执行后判断）不同，**`LOOP` 本身没有停止条件**。如果不加控制，它就是一个**死循环**。

因此，使用 `LOOP` 时必须配合两个关键命令：**`LEAVE`**（跳出循环）和 **`ITERATE`**（跳过当前循环）。

---

### 一、 基本语法

`LOOP` 必须配合**标签（Label）**使用，否则无法使用 `LEAVE` 退出。
```SQL
[label_name:] LOOP
    -- 这里是循环执行的语句列表
    
    -- 必须有退出逻辑，否则死循环！
    IF <结束条件> THEN
        LEAVE [label_name]; -- 跳出名为 label_name 的循环
    END IF;
    
END LOOP [label_name];
```

---

### 二、 两个关键搭档

#### 1. `LEAVE` (相当于编程语言的 `break`)

- **作用**：立即终止循环，跳到 `END LOOP` 之后的代码。
    
- **注意**：必须指定要跳出的**标签名**。
    

#### 2. `ITERATE` (相当于编程语言的 `continue`)

- **作用**：放弃当前循环中剩下的语句，直接回到循环的头部，开始下一次迭代。
    
- **注意**：也必须指定**标签名**。
    

---

### 三、 实战案例

#### 案例 1：简单的计数器（累加到 10 退出）

这是 `LOOP` 最标准的用法：手动控制退出。


```SQL
DELIMITER //

CREATE PROCEDURE test_loop()
BEGIN
    DECLARE x INT DEFAULT 0;
    DECLARE str VARCHAR(255) DEFAULT '';
    
    -- 1. 定义循环标签
    my_loop_label: LOOP
        -- 2. 逻辑处理
        SET x = x + 1;
        
        -- 3. 使用 ITERATE 跳过偶数 (假设我们要拼接奇数)
        IF x % 2 = 0 THEN
            ITERATE my_loop_label; -- 直接回头部，不执行下面的拼接
        END IF;
        
        SET str = CONCAT(str, x, ',');
        
        -- 4. 使用 LEAVE 退出循环
        IF x >= 10 THEN
            LEAVE my_loop_label; -- 彻底离开循环
        END IF;
    END LOOP my_loop_label;
    
    SELECT str; -- 输出结果: 1,3,5,7,9,
END //

DELIMITER ;
```

#### 案例 2：配合游标（Cursor）遍历数据

这是 `LOOP` 在工程中最常见的场景。虽然 `WHILE` 也能做，但 `LOOP` 写法往往更清晰（特别是处理 `NOT FOUND` 时）。


```SQL
DELIMITER //

CREATE PROCEDURE process_users()
BEGIN
    DECLARE done INT DEFAULT 0;
    DECLARE u_name VARCHAR(50);
    
    -- 声明游标
    DECLARE cur CURSOR FOR SELECT name FROM users;
    -- 声明 Handler：游标读完时将 done 设为 1
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = 1;
    
    OPEN cur;
    
    read_loop: LOOP
        -- 获取数据
        FETCH cur INTO u_name;
        
        -- 【关键步骤】检查是否读完
        -- 必须在 FETCH 之后立即检查，否则最后一行会多执行一次
        IF done = 1 THEN
            LEAVE read_loop;
        END IF;
        
        -- 业务逻辑...
        -- UPDATE ...
        
    END LOOP;
    
    CLOSE cur;
END //

DELIMITER ;
```

---

### 四、 什么时候用 LOOP？（对比 WHILE 和 REPEAT）

MySQL 提供了三种循环，它们的区别如下：

|**循环类型**|**检查时机**|**类比编程语言**|**适用场景**|
|---|---|---|---|
|**`WHILE`**|**进入前**检查|`while (cond) { ... }`|逻辑简单，可能一次都不执行的情况。|
|**`REPEAT`**|**执行后**检查|`do { ... } while (cond);`|无论如何至少要执行一次的情况。|
|**`LOOP`**|**手动**检查|`while (true) { ... }`|**最灵活**。当你需要在循环的**中间位置**判断退出（而不是开头或结尾）时，`LOOP` 是唯一的选择。|

### 总结建议

1. **标签必写**：虽然语法上标签有时可选，但为了能使用 `LEAVE`，请养成写 `label_name: LOOP` 的习惯。
    
2. **防死循环**：写下 `LOOP` 的第一件事，就是先把 `IF ... THEN LEAVE ... END IF` 写好，防止忘记。

----
## WHILE语句
### 一、 基本语法

`WHILE` 语句的结构非常清晰，它不需要手动写 `LEAVE`（除非你想中途强行退出），只要条件为真，它就会一直跑。


```SQL
[label_name:] WHILE <条件表达式> DO
    -- 这里是循环体
    statement_list;
    
END WHILE [label_name];
```

---

### 二、 核心逻辑解析

1. **执行顺序**：
    
    - 步骤 1：**先**检查 `WHILE` 后面的条件。
        
    - 步骤 2：
        
        - 如果条件为 **真 (TRUE)** -> 进入循环，执行 `DO ... END WHILE` 之间的代码。执行完后，**回到步骤 1**。
            
        - 如果条件为 **假 (FALSE)** -> 直接跳过循环，执行 `END WHILE` 后面的代码。
            
2. **安全特性**：
    
    - 因为它是“先检查”，所以它天然具备**防御性**。比如你要遍历一个可能为空的字符串或列表，用 `WHILE` 就很安全，因为它发现为空时直接就不进去了，避免了空指针或越界错误。
        

---

### 三、 实战案例

#### 案例 1：累加求和（标准用法）

计算 1 到 n 的和。

```SQL
DELIMITER //

CREATE PROCEDURE test_while(IN n INT)
BEGIN
    DECLARE i INT DEFAULT 1;
    DECLARE sum INT DEFAULT 0;
    
    -- 【重点】先判断 i 是否小于等于 n
    -- 如果传入的 n 是 0，这行代码下面的逻辑一次都不会跑
    WHILE i <= n DO
        SET sum = sum + i;
        SET i = i + 1;
    END WHILE;
    
    SELECT sum;
END //

DELIMITER ;
```

- _测试_：如果调用 `CALL test_while(0);`，输出结果是 `0`（正确，循环体没执行）。
    
- _对比_：如果用 `REPEAT` 写，同样的逻辑传入 `0`，结果会是 `1`（错误，因为它强行执行了一次 `1+0`）。
    

#### 案例 2：字符串处理（截取）

假设我们要把一个字符串 "A,B,C," 里的逗号都去掉，或者逐个处理单词。


```SQL
DELIMITER //

CREATE PROCEDURE process_string()
BEGIN
    DECLARE raw_str VARCHAR(255) DEFAULT 'Apple,Banana,Orange,';
    DECLARE item VARCHAR(50);
    DECLARE pos INT;
    
    -- 只要字符串里还有逗号，就继续循环
    WHILE INSTR(raw_str, ',') > 0 DO
        -- 1. 找到第一个逗号的位置
        SET pos = INSTR(raw_str, ',');
        
        -- 2. 截取逗号前面的单词
        SET item = LEFT(raw_str, pos - 1);
        
        -- 3. 把处理完的单词和逗号从原字符串里切掉
        SET raw_str = SUBSTRING(raw_str, pos + 1);
        
        -- (这里可以做业务逻辑，比如把 item 插入表)
        SELECT item; 
        
    END WHILE;
    
    -- 循环结束后，raw_str 可能会剩下一个空串或最后一个不带逗号的词
END //

DELIMITER ;
```

---

### 四、 三大循环终极对比

现在您已经掌握了 MySQL 的所有循环方式，让我们来做最后一次总结，帮您在工程中做决策：

|**特性**|**WHILE (推荐)**|**REPEAT**|**LOOP**|
|---|---|---|---|
|**逻辑**|**先判断**，后执行|**先执行**，后判断|**死循环**，手动退出|
|**最少执行**|**0 次**|**1 次**|0 或 1 次 (取决于 IF 的位置)|
|**类比**|`while (...) { }`|`do { } while (...);`|`while (true) { }`|
|**退出条件**|满足时**继续** (Run Condition)|满足时**停止** (Stop Condition)|使用 `LEAVE` 手动控制|
|**安全性**|⭐⭐⭐⭐⭐ (最安全)|⭐⭐⭐ (小心空数据)|⭐⭐⭐⭐ (灵活但要防遗漏)|
|**最佳场景**|90% 的常规业务逻辑，特别是处理可能为空的数据。|需要初始化变量，且初始化逻辑和后续迭代逻辑完全一致时。|逻辑极度复杂，需要在循环的“中间”或“多处”进行退出判断时。|

### 五、 总结建议

在实际开发中，**建议默认使用 `WHILE`**。

理由很简单：防御式编程。

在数据库层，数据的不确定性很高（可能是 NULL，可能是空集）。WHILE 的“门卫机制”（进门前先检查证件）能帮你规避掉绝大多数因为数据异常导致的逻辑错误。只有在非常特殊的场景下（比如你确定至少要做一次操作），才考虑用 REPEAT。


----
## REPEAT语句
### 一、 基本语法

`REPEAT` 也是标准的循环结构，它不需要像 `LOOP` 那样手动写 `LEAVE`，而是自带了一个“终止条件检查”。


```SQL
[label_name:] REPEAT
    -- 这里是循环体：先执行这些语句
    statement_list;
    
    -- 【重点】检查终止条件
    -- 注意：这里是“UNTIL”（直到...才停止），不是 WHILE
    UNTIL <退出条件表达式>
    
END REPEAT [label_name];
```

---

### 二、 核心逻辑解析

1. **执行顺序**：
    
    - 步骤 1：直接进入循环，执行 SQL 语句。
        
    - 步骤 2：判断 `UNTIL` 后面的条件。
        
    - 步骤 3：
        
        - 如果条件为 **真 (TRUE)** -> **结束循环**。
            
        - 如果条件为 **假 (FALSE)** -> 回到步骤 1 继续执行。
            
2. **关键区别（容易晕的地方）**：
    
    - **`WHILE`** 是“只要条件成立，就**继续**”。
        
    - **`REPEAT`** 是“只要条件成立，就**停止**”。
        
    - _记忆口诀：`WHILE` 是“当...时”，`REPEAT` 是“直到...为止”。_
        

---

### 三、 实战案例

#### 案例 1：累加求和（至少执行一次）

即使一开始 `x` 就满足条件，`REPEAT` 也会强行执行一次。


```SQL
DELIMITER //

CREATE PROCEDURE test_repeat()
BEGIN
    DECLARE x INT DEFAULT 0;
    DECLARE sum INT DEFAULT 0;
    
    -- 开始循环
    my_repeat: REPEAT
        SET x = x + 1;
        SET sum = sum + x;
        
    -- 终止条件：当 x 大于等于 10 时停止
    UNTIL x >= 10
    END REPEAT my_repeat;
    
    SELECT sum; -- 输出 55 (1+2+...+10)
END //

DELIMITER ;
```

#### 案例 2：验证“先执行”特性

这是一个很好的对比实验。假设初始值已经满足退出条件，看看会发生什么。

```SQL
DELIMITER //

CREATE PROCEDURE test_repeat_once()
BEGIN
    DECLARE x INT DEFAULT 100; -- 初始值就是 100
    DECLARE result VARCHAR(50) DEFAULT '';
    
    REPEAT
        -- 这句话会被执行，尽管 x 已经是 100 了
        SET result = '我被执行了!';
        SET x = x + 1;
        
    UNTIL x >= 10 -- 条件显然满足（101 >= 10）
    END REPEAT;
    
    SELECT result; -- 输出结果：'我被执行了!'
END //

DELIMITER ;
```

_注：如果同样的逻辑用 `WHILE` 写，`result` 将会是空的，因为 `WHILE` 一上来发现 `x >= 10` 就直接不进门了。_

---

### 四、 REPEAT vs WHILE：如何选择？

这是最常被问到的问题。请看下表对比：

|**特性**|**REPEAT**|**WHILE**|
|---|---|---|
|**逻辑类比**|`do ... while`|`while`|
|**检查时机**|**执行后**检查 (Post-test)|**执行前**检查 (Pre-test)|
|**最小执行次数**|**1 次**|**0 次**|
|**条件含义**|满足条件时**退出** (Exit Condition)|满足条件时**继续** (Run Condition)|
|**适用场景**|无论如何都要先做一次操作（如：先生成一个随机数，不满意再生成下一个）。|安全第一，条件不满足绝对不能执行操作（如：库存不足时完全不扣减）。|

### 五、 总结建议

1. **默认首选 `WHILE`**：在大多数业务逻辑中，为了防止错误操作（比如空指针、空数据），通常希望“不满足条件就不执行”，所以 `WHILE` 更安全。
    
2. **特定场景用 `REPEAT`**：当你需要初始化某些数据，且这个初始化逻辑和循环逻辑完全一样时，用 `REPEAT` 可以少写一遍代码。