# ✅ 一、核心设计原则（来自社区 & 官方）

---

## 1. **紧密围绕查询建立索引**

- **只为实际的 WHERE / JOIN / ORDER BY / GROUP BY 设计索引**，不常用查询不要建立。  
    多索引不等于好索引，过多索引会增加写入开销（INSERT/UPDATE/DELETE）。[Tencent Cloud](https://cloud.tencent.com/developer/article/2556004?utm_source=chatgpt.com)
    

**实战建议：**  
✔ 优先考虑 WHERE + JOIN  
✔ 再考虑 ORDER BY + GROUP BY  
✔ 不常用场景不要开索引

---

## 2. **选择性高的列放前面（左边）**

所谓 _选择性_ = `distinct_count / total_rows`，越接近 1 越好。  
高选择性列能过滤掉更多行，提高索引效率。[Cnblogs](https://www.cnblogs.com/szk123456/p/18342301?utm_source=chatgpt.com)

---

## 3. **复合索引优于多个单列索引**

单列索引组合往往无法做到最优，复合索引可以一次性满足多个筛选条件。[Medium](https://akhil-mathew.medium.com/mysql-indexing-best-practices-a-comprehensive-guide-15dc0f9b0442?utm_source=chatgpt.com)

---

## 4. **最左前缀匹配规则**

复合索引 `(a, b, c)`：

- 能用索引的前缀为：`a`、`a,b`、`a,b,c`
    
- 如果查询不包含左边的列，则无法用到该索引  
    例如：`WHERE b=.. AND c=..` **不能走 `(a,b,c)` 索引**。[Tencent Cloud](https://cloud.tencent.com/developer/article/2556004?utm_source=chatgpt.com)
    

---

## 5. **范围查询后面的列“无法完全利用索引”**

范围条件如 `> < BETWEEN` 后的列虽然还可能部分参与覆盖/排序，但不能用于定位行。[PlanetScale](https://planetscale.com/learn/courses/mysql-for-developers/indexes/composite-indexes?utm_source=chatgpt.com)

---

## 6. **避免函数/表达式索引失效**

例如：

`WHERE YEAR(created_at)=2025`

这种写法会导致不能用索引，应改写成范围查询。[Aliyun Developer Community](https://developer.aliyun.com/article/1557215?utm_source=chatgpt.com)

---

## 7. **适度索引，不要过度**

每个二级索引都需要额外空间，并在写操作时带来维护成本。  
太多索引反而让优化器选择困难，可能选错索引。[Cnblogs](https://www.cnblogs.com/szk123456/p/18342301?utm_source=chatgpt.com)

---

# ✅ 二、实用索引策略 & 模板

---

## 1. **等值条件放在前，范围条件放后**

建议顺序：

`(= 操作列) → (IN 操作列) → (范围操作 > < BETWEEN) → (排序/分组列)`

例如：

```SQL
WHERE tenant_id = ?
  AND status = ?
  AND created_at >= ?
ORDER BY created_at DESC;
```
推荐索引：

```SQL
INDEX idx_tenant_status_created (tenant_id, status, created_at)
```

这种顺序能最大程度利用索引进行查找 & 排序。[Medium](https://akhil-mathew.medium.com/mysql-indexing-best-practices-a-comprehensive-guide-15dc0f9b0442?utm_source=chatgpt.com)

---

## 2. **覆盖索引（Covering Index）**

覆盖索引指：索引中包含了所有查询需要的字段，此时查询不需要回表，效率最高。[Stack Overflow](https://stackoverflow.com/questions/8213235/mysql-covering-vs-composite-vs-column-index?utm_source=chatgpt.com)

例如：

```SQL
SELECT order_id, status, total_amount
FROM orders
WHERE order_date = '2025-12-31';
```

如果你建立：

```SQL
INDEX idx_date_status_total (order_date, status, total_amount)
```

这个索引就是覆盖索引，不需访问数据表。[DEV Community](https://dev.to/muhammmad_nawaz_d8ba895e1/best-practices-for-database-indexing-to-improve-query-performance-1k7e?utm_source=chatgpt.com)

---

## 3. **连接 (JOIN) 列必须建立索引**

JOIN 性能往往依赖索引，特别是大表关联：

```SQL
SELECT o.*, u.name
FROM orders o
JOIN users u ON o.user_id = u.id;
```
必须确保 `orders.user_id` 和 `users.id` 有索引。

---

## 4. **字符串索引设计要注意长度**

长字符串建整列索引很浪费，通常使用**前缀索引**：

`INDEX idx_email_prefix (email(32));`

比整列建索引更节省空间。[CSDN Blog](https://blog.csdn.net/xuan_lu/article/details/107871560?utm_source=chatgpt.com)

---

## 5. **避免在小表上建索引**

对于小表，查询全表扫描比走索引还快。索引要考虑成本收益比。[CSDN Blog](https://blog.csdn.net/swadian2008/article/details/124195153?utm_source=chatgpt.com)

---

## 6. **避免 NULL 值恶化索引效果**

如果一个列经常为 NULL，索引的选择性/统计数据可能不准确，影响优化器决策。可考虑：

- 使用 NOT NULL + 默认值
    
- 或调整逻辑避免 NULL
    

---

# ✅ 三、特殊索引类型 & 场景策略

---

## 1. **唯一 `UNIQUE` 索引**

如果业务逻辑允许，用唯一索引不仅筛查重复数据，还能提升性能。[Cnblogs](https://www.cnblogs.com/szk123456/p/18342301?utm_source=chatgpt.com)

---

## 2. **全文索引 (FULLTEXT)**

用于文本搜索，例如文章标题/正文搜索。适合 LIKE 模糊搜索 & MATCH() AGAINST()。[Percona](https://www.percona.com/blog/understanding-mysql-indexes-types-best-practices/?utm_source=chatgpt.com)

---

## 3. **空间索引 (Spatial Index)**

用于 GIS/geospatial 数据。用于点、线、面数据查询等场景。[Cnblogs](https://www.cnblogs.com/szk123456/p/18342301?utm_source=chatgpt.com)

---

# ✅ 四、典型索引失效场景（必须知道）

以下模式会导致 MySQL 放弃使用索引：

### ❌ 不以索引列开头

不以复合索引第一个字段开头。

### ❌ 对索引列做函数/表达式

`WHERE UPPER(name) = 'JOHN'`

### ❌ LIKE 前缀通配（不能利用 B+树）

`WHERE name LIKE '%john%'`

---

# ✅ 五、监控 & 校验方法

---

## ✔ 使用 EXPLAIN 查看执行计划

`EXPLAIN SELECT ...`

关注：

- `type`: prefer `ref`, `range` 而不是 `ALL`（全表扫描）
    
- `possible_keys` / `key`: 实际使用的索引
    
- `rows`: 扫描行数越少越好
    

---

## ✔ 使用慢查询日志定位问题

开启慢查询日志，找出耗时查询，再针对性优化索引。[Cnblogs](https://www.cnblogs.com/szk123456/p/18342301?utm_source=chatgpt.com)

---

## ✔ ANALYZE TABLE 更新统计信息

`ANALYZE TABLE table_name;`

让优化器能更准确利用索引。[Cnblogs](https://www.cnblogs.com/szk123456/p/18342301?utm_source=chatgpt.com)

---

# ✅ 六、实践总结（可执行清单）

---

### 📌 建索引前问自己：

✔ 该列是否频繁用于 WHERE/JOIN/ORDER/GROUP？  
✔ 是否可用复合索引覆盖？  
✔ 是否能避免范围条件导致后续列失效？  
✔ 是否有冗余/重复索引？

---

### 📌 常见成功索引模式

|场景|推荐索引|
|---|---|
|按用户时间线查询|`(user_id, created_at)`|
|多条件过滤|`(col1, col2, created_at)`|
|关联查询|外键单独索引|
|统计 & 分组|`(group_col, agg_col)`|
|覆盖查询|包括 SELECT 所需列|

---
## 选择合适的索引
**决策流程图**
```SQL
① 是否是精确等值 / 范围 / 排序 / JOIN？
    → 是 → B+Tree 索引（普通 / 复合 / 唯一）

② 是否需要强制唯一性？
    → 是 → UNIQUE B+Tree

③ 是否是全文模糊搜索（自然语言）？
    → 是 → FULLTEXT

④ 是否是空间/地理位置（点、线、面）？
    → 是 → SPATIAL

⑤ 是否只做等值匹配，且在 MEMORY 引擎？
    → 是 → HASH（InnoDB 不适用）

⑥ 是否是 JSON / 表达式计算结果？
    → 是 → 函数索引 / 生成列 + B+Tree
```