## 1.选择优化的数据类型
- 更小的通常更好
- 简单就好(整型比字符操作代价更低)
- 尽量避免NULL（NULL更难优化）

## 2.整数类型

**有符号整数和无符号整数使用相同的存储空间，并具有相同的性能，因此可以根据实际情况选择合适的类型**

- 但是，整数计算一般使用bigint，即便在32位环境也是如此。（一些聚合函数例外，他们使用DOUBLE或者DECIMAL进行计算）。

## 3.实数类型
实数是指带有小数的数据类型，**DECIMAL和浮点数都支持指定精度**，DECIMAL更精确一些。**但是CPU不支持DECIMAL的运算**，因此MYSQL自己实现了DECIAML的运算，**因此运算速度比原生FLOAT，DOUBLE要慢一些**，只有在需要精确计算的时候才用。

## 4.字符串类型
## 1) 优先选“能表达清楚且最小”的类型

### 固定长度 vs 变长

- **固定长度（CHAR）**：适合**长度几乎恒定**的值  
    例：国家码 `CN/US`、性别 `M/F`、固定格式的短编码（长度稳定）。  
    优点：读取/比较更简单，有时更快；缺点：浪费空间（会填充）。
    
- **变长（VARCHAR）**：适合**长度差异大**的值  
    例：用户名、邮箱、标题。  
    优点：省空间；缺点：行内需要额外长度字节（1 或 2 字节），更新变长字段更可能导致页分裂/搬移（取决于行格式与长度变化）。
    

**原则**：

- 长度稳定 → `CHAR(n)`
    
- 长度波动 → `VARCHAR(n)`
    
- 不要为了“省事”一律用 `VARCHAR(255)`：会影响统计、索引体积、以及未来约束表达。
    

## 2) `VARCHAR(n)` 的 n 要“刚好”，并基于字符集理解“长度单位”

- `VARCHAR(n)` 的 **n 是字符数**，不是字节数（但存储占字节与字符集相关）。
    
- utf8mb4 下一个字符最多 4 字节，**索引前缀长度与行大小**更容易被推高。
    

**原则**：

- `n` 用业务上限（或合理上限），别拍脑袋。
    
- 能限制就限制：它既是优化也是数据质量约束。
    
`VARCHAR` 的存储 = **长度字节 + 实际字符占用字节**

##### 长度字节

- 当 `n ≤ 255`：**1 个字节**记录长度
    
- 当 `n > 255`：**2 个字节**记录长度
    

所以 `VARCHAR(5)` → **1 字节长度信息**

## 3) 超长文本：用 `TEXT/BLOB`，但别滥用

- `TEXT`/`BLOB` 适合**很长**的内容（描述、正文、JSON 文本等）。
    
- InnoDB 对长列可能做**溢出页**存储：主记录里只保留部分/指针，读取该列可能产生额外 I/O。
    
- **索引限制**：`TEXT` 不能直接建“全长索引”，通常要**前缀索引**或改方案（全文索引 / 外置搜索 / hash 列等）。
    

**原则**：

- 频繁查询/过滤的字段尽量别用 `TEXT`（除非你有明确的索引策略）。
    
- 需要正文检索 → 考虑 `FULLTEXT`（取决于版本与场景）。
    
- `TEXT` 列尽量与热点列分离（可考虑“主表 + 扩展表”垂直拆分）。
    

## 4) 能用数字/二进制就别用字符串（尤其是主键/关联键）

### 典型坑：UUID 用字符串

- `CHAR(36)` 存 UUID（带连字符）索引大、比较慢、缓存命中差。
    
- 更优：`BINARY(16)` 存原始 16 字节，索引体积小很多，join 更快。
    

**原则**：

- 关联键/主键优先选择：`BIGINT`（自增或有序 ID）或 `BINARY(16)`（UUID/ULID 等二进制）。
    
- 需要展示格式，在应用层转换，或用生成列（视版本）做展示/查询辅助。
    

## 5) 字符集与排序规则（collation）是性能开关

- `utf8mb4` 是通用安全选择，但排序规则会影响比较/索引：
    
    - **大小写不敏感**（如 `*_ci`）比较规则更复杂
        
    - **二进制比较**（`*_bin` 或 `BINARY`）更快更确定，但不做语言学排序折叠
        

**原则**：

- 需要“严格区分大小写/字节级一致性”（如 token、hash、路径、编码）→ 用 **bin 排序规则** 或直接用 `VARBINARY/BINARY`。
    
- 用户可见的自然语言文本 → 用合适的语言排序规则（但注意索引与比较成本）。
    
- 同一张表/同一字段尽量别混用不同 collation，避免隐式转换导致索引失效。
    

## 6) 索引优化：字符串列“索引很贵”

- 字符串索引比数字索引大很多，B+Tree 体积大 → **更多 I/O、更多内存**。
    
- `LIKE '%xxx'` 这类前置通配通常无法用普通索引（可考虑倒排/全文/ES）。
    

**可操作原则**：

1. **短字段优先做索引**：例如用 `status`、`type` 等短码。
    
2. 长字符串要索引：
    
    - 能唯一识别但很长 → 试 **前缀索引**（如 `INDEX idx_email (email(16))`）
        
    - 或增加一个 **hash/指纹列**（`BINARY(16)`/`BIGINT`）做等值查找，再回表校验原文
        
3. 避免在查询中对索引列做函数/隐式转换（如不同 collation、不同字符集比较），否则可能走不了索引。
    

## 7) `ENUM/SET`：慎用，但在“极稳定小集合”里很好用

- `ENUM` 存储紧凑（内部是整数），查询也快。
    
- 风险在于：枚举值变更需要 DDL，跨语言/跨系统协作时维护成本高。
    

**原则**：

- 值集合极稳定、改动极少（如 `gender`、`order_state` 很稳定的场景）→ 可以用 `ENUM`
    
- 业务会频繁加值/改值 → 用 `TINYINT/SMALLINT` + 字典表/代码映射更稳
    

## 8) 关注行大小与页分裂：避免“热点变长列频繁更新”

- `VARCHAR` 频繁变长更新可能导致记录移动、页分裂，影响写性能。
    
- 把大字段、经常变动的字段从热点表拆出去能改善写放大。
    

**原则**：

- 高频更新表：尽量让行“短且稳定”。
    
- 大字段/可选字段：考虑单独扩展表（1:1）或 JSON 外置（但 JSON 也有权衡）。
    

## 9) 常见场景的推荐选型

- 国家码/两位码：`CHAR(2)`
    
- 手机号：**不要用 INT**（会丢前导 0、也不适合算术），一般 `VARCHAR(20)`（含国家区号、分隔符）
    
- 邮箱：`VARCHAR(254)`（上限可控），并考虑 `*_bin` 或统一大小写策略
    
- URL：`VARCHAR(2048)`（看业务），如果要索引，常配合 hash 列
    
- token / hash（md5/sha）：`BINARY(16/32)` 或 `VARBINARY`
    
- UUID：`BINARY(16)`（推荐）

------
## 1) 用“语义最准确”的类型：别用字符串存时间

- **能用 DATE/DATETIME/TIMESTAMP 就别用 VARCHAR**：字符串会让范围查询、排序、索引都变差，还容易存入脏数据。
    
- 也别用 `INT` 存 `yyyymmdd` 这类“伪日期”（除非明确做维表键且不做日期计算），因为日期函数/校验会麻烦。
    

## 2) DATE / DATETIME / TIMESTAMP 怎么选

### DATE

- 只关心“哪一天”，不关心时间：生日、账期、自然日统计。
    
- 优点：更省空间、索引更小、比较更快。
    
YYYY-MM-DD
### DATETIME 5字节

- 需要日期+时间，且**不希望受时区自动转换影响**：业务事件发生时刻（以某一固定时区或“本地时间”语义记录）、日志时间（若你想原样保存）。
    
- 常见做法：统一存 **UTC 的 DATETIME**（应用层转换展示）。
    
YYYY-MM-DD HH:MM:SS
### TIMESTAMP 4字节

- 需要日期+时间，并且**希望 MySQL 按会话时区做转换**（存储为 UTC，读取按时区显示）。
    
- 优点：通常也很省空间/快（取决于版本/精度）；缺点：**时间范围更窄**（经典限制在 1970~2038 左右；不同版本实现略有差异，但“范围窄”这个风险长期存在）。
    
- 适合：`created_at/updated_at` 这类系统字段（配合自动默认值/自动更新时要注意规则）。
    
### DATETIME / TIMESTAMP 的 fsp 规则（相同）

| fsp | 额外字节 | 总占用（DATETIME） | 总占用（TIMESTAMP） |
| --- | ---- | ------------- | -------------- |
| 0   | +0   | 5             | 4              |
| 1–2 | +1   | 6             | 5              |
| 3–4 | +2   | 7             | 6              |
| 5–6 | +3   | 8             | 7              |

**选型原则：**

- 只要日期 → `DATE`
    
- 要时间且跨系统/跨时区一致，且不想被自动转换 → `DATETIME`（常配合存 UTC）
    
- 要时间且明确希望按时区自动转换、并且范围足够 → `TIMESTAMP`
    
YYYY-MM-DD HH:MM:SS
## 3) 是否要小数秒：只在“需要”时用 `(fsp)`

MySQL 支持 `DATETIME(0..6)`、`TIMESTAMP(0..6)`。

- 只有在你真的需要毫秒/微秒（交易撮合、链路追踪、去重依赖时间戳精度）才用 `fsp>0`。
    
- 否则用 `DATETIME(0)` / `TIMESTAMP(0)`：更省空间，索引也更小。
    

## 4) 存 UTC 还是存本地时间：统一策略最重要

推荐两种稳健策略（二选一，别混用）：

### 策略 A：库里统一存 UTC（推荐最多）

- `DATETIME` 存 UTC 或 `TIMESTAMP`（天然 UTC 存储）
    
- 展示时按用户时区转换
    
- 好处：跨地域一致，避免夏令时/时区变更导致“同一时刻两种解释”
    

### 策略 B：库里存“业务本地时间”

- 用 `DATETIME`，并**额外存一个时区/地区字段**（或明确约定该列含义）
    
- 适合：排班、门店营业时间、日历类业务（本地时间语义强）
    

**禁忌：**

- 一会儿 UTC，一会儿本地；或者同一列含义不固定。
    

## 5) 默认值与自动更新时间：别让“隐式行为”背刺你

- `created_at`：用 `DEFAULT CURRENT_TIMESTAMP`（如需要）
    
- `updated_at`：用 `DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP`（如需要）
    
- 但要注意：应用层也可能会写入它们，确保一致策略（要么 DB 自动管，要么应用管）。
    

## 6) 索引与查询写法：让范围查询吃到索引

时间字段最常见是范围过滤，优化要点：

- 给典型查询加索引：`WHERE created_at >= ? AND created_at < ?` 非常友好
    
- 以“天”为维度过滤时，避免对列做函数：
    
    - ✅ `created_at >= '2026-01-11 00:00:00' AND created_at < '2026-01-12 00:00:00'`
        
    - ❌ `DATE(created_at) = '2026-01-11'`（容易导致索引失效）
        
- 排序/分页：`ORDER BY created_at` 可以用索引（配合合适的复合索引）
    

## 7) 复合索引：把“过滤最强”的放前面

常见模式：

- 按用户看时间线：`INDEX(user_id, created_at)`
    
- 按状态统计一段时间：`INDEX(status, created_at)` 或 `INDEX(created_at, status)`（取决于过滤选择性）
    
- 多租户：`INDEX(tenant_id, created_at)`
    

原则：优先让索引前缀匹配你最常用的 `WHERE` 条件。

## 8) 分区不是万能，但时间表常用

- 超大日志/流水表，按时间做 `RANGE` 分区能让“按月删数据/归档”非常快（`DROP PARTITION`）。
    
- 但分区会影响索引策略和查询写法；中小表不要盲上。
    

## 9) 只存“时间点”还是存“时间段”

- 时间点：`created_at` 用 `DATETIME/TIMESTAMP`
    
- 时间段：用 `start_at` + `end_at` 两列（别用单列拼接字符串）
    
- 做区间冲突查询（预约/会议室）时，索引与写法更讲究：通常需要 `(resource_id, start_at)` / `(resource_id, end_at)` 等组合，并用规范的 overlap 条件。