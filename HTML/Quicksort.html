<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>快速排序可视化 (Quick Sort)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* 核心样式 */
        #visualizer-container {
            display: flex;
            align-items: flex-end;
            justify-content: center;
            height: 100%;
            min-height: 300px;
        }
        
        .bar {
            background-color: #3B82F6; /* Blue-500: 默认 */
            transition: height 0.2s ease-in-out, background-color 0.2s;
            flex: 1;
            margin: 0 1px;
            border-top-left-radius: 4px;
            border-top-right-radius: 4px;
            min-width: 4px;
            position: relative;
        }

        /* 状态颜色类 */
        .bar-pivot { background-color: #EAB308 !important; box-shadow: 0 0 15px rgba(234, 179, 8, 0.8); z-index: 10; } /* Yellow: 基准 Pivot */
        .bar-active { background-color: #EF4444 !important; } /* Red: 正在比较 j */
        .bar-less { background-color: #A855F7 !important; } /* Purple: 小于Pivot区 (i) */
        .bar-sorted { background-color: #22C55E !important; } /* Green: 已归位 */
        .bar-range { background-color: #60A5FA !important; } /* Light Blue: 当前递归范围 */
        .bar-dim { opacity: 0.3 !important; } /* Dim: 非当前范围 */

        /* 代码高亮样式 */
        .highlight-line {
            background-color: #374151;
            border-left: 4px solid #F59E0B;
            color: #FBBF24;
        }
        
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: #1f2937; }
        ::-webkit-scrollbar-thumb { background: #4b5563; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #6b7280; }
    </style>
</head>
<body class="bg-gray-900 text-white min-h-screen flex flex-col font-sans">

    <!-- 头部 -->
    <header class="p-6 bg-gray-800 shadow-lg border-b border-gray-700 flex flex-col md:flex-row justify-between items-center z-10">
        <div>
            <h1 class="text-2xl font-bold text-blue-400">快速排序可视化 (Quick Sort)</h1>
            <p class="text-gray-400 text-sm mt-1">基于分区交换 (Partitioning) 的递归排序</p>
        </div>
        <div class="flex items-center gap-4 mt-4 md:mt-0">
            <div class="flex flex-col items-end">
                <label for="speedRange" class="text-xs text-gray-400 mb-1">自动播放速度</label>
                <input type="range" id="speedRange" min="1" max="100" value="40" class="w-32 h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-blue-500">
            </div>
            <div class="flex flex-col items-end ml-4">
                 <label for="sizeRange" class="text-xs text-gray-400 mb-1">数组大小</label>
                 <input type="range" id="sizeRange" min="5" max="50" value="20" class="w-32 h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-green-500">
            </div>
        </div>
    </header>

    <!-- 主内容区 -->
    <main class="flex-1 flex flex-col lg:flex-row overflow-hidden h-[calc(100vh-100px)]">
        
        <!-- 左侧：可视化区域 -->
        <section class="flex-1 p-4 flex flex-col relative bg-gray-900">
            <!-- 状态图例 -->
            <div class="absolute top-4 left-4 z-10 bg-gray-800/90 backdrop-blur p-3 rounded border border-gray-700 text-xs shadow-xl pointer-events-none">
                <div class="flex items-center gap-2 mb-1">
                    <span class="w-3 h-3 bg-blue-500 rounded-full"></span>
                    <span>待排序</span>
                </div>
                <div class="flex items-center gap-2 mb-1">
                    <span class="w-3 h-3 bg-yellow-500 rounded-full"></span>
                    <span>基准 (Pivot)</span>
                </div>
                <div class="flex items-center gap-2 mb-1">
                    <span class="w-3 h-3 bg-purple-500 rounded-full"></span>
                    <span>&lt; Pivot 区 (i)</span>
                </div>
                <div class="flex items-center gap-2 mb-1">
                    <span class="w-3 h-3 bg-red-500 rounded-full"></span>
                    <span>当前比较 (j)</span>
                </div>
                <div class="flex items-center gap-2">
                    <span class="w-3 h-3 bg-green-500 rounded-full"></span>
                    <span>已归位</span>
                </div>
            </div>

            <!-- 动态信息 -->
            <div class="mt-2 mb-2 text-center h-8 shrink-0">
                <span id="status-text" class="text-lg font-mono text-yellow-300 transition-all">准备就绪</span>
            </div>

            <!-- 柱状图容器 -->
            <div class="flex-1 border-b-2 border-gray-700 pb-1 px-2 w-full relative">
                 <div id="visualizer-container"></div>
            </div>

            <!-- 控制按钮 -->
            <div class="mt-4 flex justify-center gap-4 shrink-0 pb-4">
                <button id="btn-generate" class="px-5 py-2 bg-gray-700 hover:bg-gray-600 rounded text-white font-medium transition active:scale-95 border border-gray-600">
                    <span class="mr-1">↻</span> 重置数组
                </button>
                
                <div class="w-px h-10 bg-gray-700 mx-2"></div>

                <button id="btn-play" class="px-6 py-2 bg-blue-600 hover:bg-blue-500 rounded text-white font-medium transition active:scale-95 shadow-lg shadow-blue-900/50 flex items-center">
                    <svg class="w-4 h-4 mr-2" fill="currentColor" viewBox="0 0 20 20"><path d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z"/></svg>
                    自动播放
                </button>
                
                <button id="btn-pause" class="px-6 py-2 bg-yellow-600 hover:bg-yellow-500 rounded text-white font-medium transition active:scale-95 hidden flex items-center">
                    <svg class="w-4 h-4 mr-2" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zM7 8a1 1 0 012 0v4a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v4a1 1 0 102 0V8a1 1 0 00-1-1z" clip-rule="evenodd"/></svg>
                    暂停
                </button>

                <button id="btn-step" class="px-5 py-2 bg-purple-600 hover:bg-purple-500 disabled:opacity-50 disabled:cursor-not-allowed rounded text-white font-medium transition active:scale-95 shadow-lg shadow-purple-900/50 flex items-center" disabled>
                    <svg class="w-4 h-4 mr-2" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z" clip-rule="evenodd"/></svg>
                    单步执行
                </button>
            </div>
        </section>

        <!-- 右侧：代码对照区域 -->
        <aside class="w-full lg:w-1/3 bg-gray-950 border-l border-gray-800 flex flex-col">
            <div class="p-4 border-b border-gray-800 bg-gray-900 flex justify-between items-center">
                 <h3 class="text-gray-400 font-bold">C++ 逻辑追踪</h3>
                 <span class="text-xs text-gray-500 bg-gray-800 px-2 py-1 rounded">Recursive</span>
            </div>
            
            <div class="flex-1 overflow-y-auto p-4 font-mono text-sm relative">
                <pre class="text-gray-300"><code id="code-block">
<div id="line-1" class="p-1">void quickSort(int arr[], int low, int high) {</div>
<div id="line-2" class="p-1 pl-4">if (low < high) {</div>
<div id="line-3" class="p-1 pl-8">// 1. 划分数组，找到 Pivot 位置</div>
<div id="line-4" class="p-1 pl-8">int pi = partition(arr, low, high);</div>
<div id="line-5" class="p-1 pl-8">// 2. 递归排序左半部分</div>
<div id="line-6" class="p-1 pl-8">quickSort(arr, low, pi - 1);</div>
<div id="line-7" class="p-1 pl-8">// 3. 递归排序右半部分</div>
<div id="line-8" class="p-1 pl-8">quickSort(arr, pi + 1, high);</div>
<div id="line-9" class="p-1 pl-4">}</div>
<div id="line-10" class="p-1">}</div>
<div id="line-11" class="p-1 mt-2 text-gray-500">// 分区函数 (Lomuto Partition)</div>
<div id="line-12" class="p-1">int partition(int arr[], int low, int high) {</div>
<div id="line-13" class="p-1 pl-4">int pivot = arr[high]; // 选最后元素为基准</div>
<div id="line-14" class="p-1 pl-4">int i = low - 1;       // i 指向小于pivot的区域末尾</div>
<div id="line-15" class="p-1 pl-4">for (int j = low; j < high; j++) {</div>
<div id="line-16" class="p-1 pl-8">if (arr[j] < pivot) {</div>
<div id="line-17" class="p-1 pl-12">i++;</div>
<div id="line-18" class="p-1 pl-12">swap(arr[i], arr[j]);</div>
<div id="line-19" class="p-1 pl-8">}</div>
<div id="line-20" class="p-1 pl-4">}</div>
<div id="line-21" class="p-1 pl-4">swap(arr[i + 1], arr[high]);</div>
<div id="line-22" class="p-1 pl-4">return (i + 1);</div>
<div id="line-23" class="p-1">}</div>
                </code></pre>
            </div>
            
            <div class="p-4 bg-gray-800 border-t border-gray-700 shrink-0">
                <h4 class="font-bold text-blue-400 mb-2 text-xs uppercase tracking-wider">Current Recursion State</h4>
                <div class="grid grid-cols-2 gap-2 text-center font-mono">
                    <div class="bg-gray-700 rounded p-2 flex justify-between px-4">
                        <span class="text-xs text-gray-400">Range [Low, High]</span>
                        <span id="var-range" class="text-white font-bold">[- , -]</span>
                    </div>
                    <div class="bg-gray-700 rounded p-2 flex justify-between px-4 border border-yellow-500/30">
                        <span class="text-xs text-yellow-400">Pivot Value</span>
                        <span id="var-pivot" class="text-yellow-400 font-bold">-</span>
                    </div>
                    <div class="bg-gray-700 rounded p-2 flex justify-between px-4">
                        <span class="text-xs text-purple-300">i (Swap Target)</span>
                        <span id="var-i" class="text-purple-300 font-bold">-</span>
                    </div>
                    <div class="bg-gray-700 rounded p-2 flex justify-between px-4">
                        <span class="text-xs text-red-300">j (Scan)</span>
                        <span id="var-j" class="text-red-300 font-bold">-</span>
                    </div>
                </div>
            </div>
        </aside>

    </main>

    <script>
        // DOM Elements
        const container = document.getElementById('visualizer-container');
        const btnGenerate = document.getElementById('btn-generate');
        const btnPlay = document.getElementById('btn-play');
        const btnPause = document.getElementById('btn-pause');
        const btnStep = document.getElementById('btn-step');
        
        const speedRange = document.getElementById('speedRange');
        const sizeRange = document.getElementById('sizeRange');
        const statusText = document.getElementById('status-text');
        
        // Variables Display
        const varRange = document.getElementById('var-range');
        const varPivot = document.getElementById('var-pivot');
        const varI = document.getElementById('var-i');
        const varJ = document.getElementById('var-j');

        // State Variables
        let array = [];
        let bars = [];
        let isSorting = false;
        let isPaused = false;
        let abortController = null;
        let stepResolve = null;

        // ----------------------
        // Control Logic
        // ----------------------
        
        async function checkControlState(signal) {
            if (signal.aborted) throw new Error('Aborted');

            if (isPaused) {
                updateStatus("暂停中 - 点击“单步”或“继续”", "text-yellow-500");
                await new Promise(resolve => { stepResolve = resolve; });
                stepResolve = null;
            } else {
                await sleep(getDelay());
            }
        }

        function triggerStep() {
            if (stepResolve) stepResolve();
        }

        function togglePause(pause) {
            isPaused = pause;
            if (isPaused) {
                btnPlay.classList.remove('hidden');
                btnPause.classList.add('hidden');
                btnStep.disabled = false;
                btnStep.classList.remove('opacity-50', 'cursor-not-allowed');
            } else {
                btnPlay.classList.add('hidden');
                btnPause.classList.remove('hidden');
                btnStep.disabled = true;
                btnStep.classList.add('opacity-50', 'cursor-not-allowed');
                if (stepResolve) stepResolve();
            }
        }

        function stopSorting() {
            if (abortController) abortController.abort();
            isSorting = false;
            isPaused = false;
            stepResolve = null;
            
            btnPlay.classList.remove('hidden');
            btnPause.classList.add('hidden');
            btnGenerate.disabled = false;
            btnPlay.disabled = false;
            btnStep.disabled = true;
            sizeRange.disabled = false;
            highlightLine(-1);
        }

        // ----------------------
        // Visual Helpers
        // ----------------------
        
        function sleep(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }

        function getDelay() {
            const speed = parseInt(speedRange.value);
            return Math.max(20, 1000 - (speed * 9));
        }

        function generateArray() {
            const size = parseInt(sizeRange.value);
            container.innerHTML = '';
            array = [];
            bars = [];

            for (let i = 0; i < size; i++) {
                const value = Math.floor(Math.random() * 85) + 10;
                array.push(value);

                const bar = document.createElement('div');
                bar.classList.add('bar');
                bar.style.height = `${value}%`;
                bar.title = `Index: ${i}, Value: ${value}`;
                
                if (size <= 25) {
                    bar.textContent = value;
                    bar.style.display = 'flex';
                    bar.style.alignItems = 'flex-end';
                    bar.style.justifyContent = 'center';
                    bar.style.fontSize = '12px';
                    bar.style.paddingBottom = '4px';
                    bar.style.color = 'rgba(255,255,255,0.9)';
                }

                container.appendChild(bar);
                bars.push(bar);
            }
            
            updateStatus("准备就绪", "text-yellow-300");
            resetVars();
        }

        function updateBarVisual(index, type) {
            if (!bars[index]) return;
            const bar = bars[index];
            
            // Remove temp classes
            bar.classList.remove('bar-active', 'bar-pivot', 'bar-less', 'bar-range', 'bar-dim');
            // 'bar-sorted' is permanent until reset

            if (type === 'pivot') bar.classList.add('bar-pivot');
            else if (type === 'compare') bar.classList.add('bar-active');
            else if (type === 'less') bar.classList.add('bar-less');
            else if (type === 'range') bar.classList.add('bar-range');
            else if (type === 'dim') bar.classList.add('bar-dim');
        }
        
        function markSorted(index) {
            if(bars[index]) bars[index].classList.add('bar-sorted');
        }

        function resetBarVisual(index) {
            if(!bars[index]) return;
            // Remove all temporary status classes, keep sorted if present
            bars[index].classList.remove('bar-active', 'bar-pivot', 'bar-less', 'bar-range', 'bar-dim');
        }

        // Swap visual function
        async function swapVisual(i, j, signal) {
            if (i === j) return;
            
            // Visual Swap
            const valI = array[i];
            const valJ = array[j];
            
            bars[i].style.height = `${valJ}%`;
            bars[j].style.height = `${valI}%`;
            
            if(bars.length <= 25) {
                bars[i].textContent = valJ;
                bars[j].textContent = valI;
            }

            // Logic Swap
            array[i] = valJ;
            array[j] = valI;
        }

        function highlightLine(lineNum) {
            document.querySelectorAll('.highlight-line').forEach(el => el.classList.remove('highlight-line'));
            if (lineNum > 0) {
                const el = document.getElementById(`line-${lineNum}`);
                if (el) {
                    el.classList.add('highlight-line');
                    el.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                }
            }
        }

        function updateStatus(text, colorClass) {
            statusText.textContent = text;
            statusText.className = `text-lg font-mono transition-all ${colorClass}`;
        }

        function updateVars(rangeText, pivot, iVal, jVal) {
            if(rangeText !== null) varRange.innerText = rangeText;
            if(pivot !== null) varPivot.innerText = pivot;
            if(iVal !== null) varI.innerText = iVal;
            if(jVal !== null) varJ.innerText = jVal;
        }

        function resetVars() {
            updateVars('[- , -]', '-', '-', '-');
            highlightLine(-1);
        }

        // ----------------------
        // Quick Sort Logic
        // ----------------------

        async function quickSortVisual(signal) {
            highlightLine(1);
            await checkControlState(signal);
            
            await quickSortRecursive(0, array.length - 1, signal);
            
            updateStatus("排序完成！", "text-green-500 font-bold");
            highlightLine(-1);
            resetVars();
        }

        async function quickSortRecursive(low, high, signal) {
            highlightLine(2);
            
            // 更新范围显示
            updateVars(`[${low}, ${high}]`, '-', '-', '-');

            // 视觉：高亮当前递归处理的范围
            for (let k = 0; k < array.length; k++) {
                if (k >= low && k <= high) {
                    // 保持正常
                    resetBarVisual(k); 
                } else {
                    // 变暗，非当前关注区
                    if (!bars[k].classList.contains('bar-sorted')) {
                        updateBarVisual(k, 'dim');
                    }
                }
            }
            await checkControlState(signal);

            if (low < high) {
                highlightLine(4);
                // Partition
                let pi = await partition(low, high, signal);
                
                // 标记基准归位
                markSorted(pi);
                updateStatus(`基准值 ${array[pi]} 已归位 (Index ${pi})`, "text-green-400");
                await checkControlState(signal);

                highlightLine(6);
                // Recursion Left
                await quickSortRecursive(low, pi - 1, signal);
                
                highlightLine(8);
                // Recursion Right
                await quickSortRecursive(pi + 1, high, signal);
            } else {
                // Base case: single element is sorted
                if (low >= 0 && low < array.length) {
                    markSorted(low);
                }
            }
        }

        async function partition(low, high, signal) {
            highlightLine(12);
            
            let pivot = array[high];
            let i = low - 1;
            
            // Visual: Set Pivot
            updateBarVisual(high, 'pivot');
            updateVars(`[${low}, ${high}]`, pivot, i, '-');
            updateStatus(`分区开始: Pivot=${pivot}, Range=[${low}, ${high}]`, "text-yellow-400");
            highlightLine(13);
            await checkControlState(signal);

            highlightLine(14); // int i = low - 1

            highlightLine(15); // Loop j
            for (let j = low; j <= high - 1; j++) {
                if (signal.aborted) throw new Error('Aborted');
                
                updateVars(null, null, i, j);
                
                // Visual: Compare j
                updateBarVisual(j, 'compare');
                updateStatus(`比较: arr[${j}]=${array[j]} 与 Pivot=${pivot}`, "text-blue-300");
                highlightLine(16);
                await checkControlState(signal);

                if (array[j] < pivot) {
                    highlightLine(17); // i++
                    i++;
                    updateVars(null, null, i, j);
                    
                    // Visual: Found smaller element
                    updateBarVisual(j, 'less'); // 标记为小于pivot
                    updateStatus(`发现小于 Pivot 的元素: ${array[j]}，准备交换到左侧`, "text-purple-300");
                    await checkControlState(signal);

                    // Swap
                    highlightLine(18);
                    if (i !== j) {
                        updateStatus(`交换: arr[${i}] <-> arr[${j}]`, "text-purple-400");
                        await swapVisual(i, j, signal);
                        // Swap后 j位置的颜色还是 less (因为是从i换过来的)，i位置也是less
                        updateBarVisual(i, 'less');
                        // j 位置的值现在是大值(或相等)，重置为普通range色等待下次循环
                        resetBarVisual(j); 
                        await checkControlState(signal);
                    } else {
                         // i==j, no swap needed visually but mark logic
                         updateBarVisual(i, 'less');
                    }
                } else {
                    // Greater than pivot, do nothing
                    resetBarVisual(j); // Restore color
                }
            }

            // Final Swap Pivot
            highlightLine(21);
            updateStatus(`分区结束: 将 Pivot 放到位置 ${i+1}`, "text-yellow-500");
            await swapVisual(i + 1, high, signal);
            
            // Reset colors in range for next steps
            for(let k=low; k<=high; k++) resetBarVisual(k);
            
            highlightLine(22);
            return (i + 1);
        }

        // ----------------------
        // Event Listeners
        // ----------------------
        
        btnGenerate.addEventListener('click', () => {
            if (isSorting) stopSorting();
            generateArray();
            btnPlay.disabled = false;
            btnStep.disabled = false;
        });

        btnPlay.addEventListener('click', async () => {
            if (isSorting) {
                togglePause(false);
                return;
            }
            if (array.length === 0) generateArray();
            
            isSorting = true;
            btnGenerate.disabled = true;
            sizeRange.disabled = true;
            togglePause(false);
            
            abortController = new AbortController();
            try {
                await quickSortVisual(abortController.signal);
            } catch (e) {
                if (e.message !== 'Aborted') console.error(e);
            } finally {
                stopSorting();
            }
        });

        btnPause.addEventListener('click', () => {
            if (isSorting) togglePause(true);
        });

        btnStep.addEventListener('click', () => {
            if (!isSorting) {
                if (array.length === 0) generateArray();
                isSorting = true;
                btnGenerate.disabled = true;
                sizeRange.disabled = true;
                abortController = new AbortController();
                togglePause(true);
                quickSortVisual(abortController.signal)
                    .catch(e => { if (e.message !== 'Aborted') console.error(e); })
                    .finally(() => stopSorting());
                return;
            }
            if (isPaused) triggerStep();
            else togglePause(true);
        });

        sizeRange.addEventListener('input', () => {
            if (!isSorting) generateArray();
        });

        // Init
        generateArray();
        btnStep.disabled = false;

    </script>
</body>
</html>