<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>最长回文子串 - 中心扩展法演示</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        body { font-family: 'Consolas', 'Monaco', monospace; background-color: #1e1e1e; color: #d4d4d4; }
        
        /* Character Box */
        .char-box {
            width: 50px; height: 50px;
            display: flex; flex-direction: column; align-items: center; justify-content: flex-end;
            margin: 2px; position: relative;
            transition: all 0.3s;
        }
        .char-val {
            width: 40px; height: 40px;
            border: 2px solid #555;
            border-radius: 8px;
            display: flex; align-items: center; justify-content: center;
            font-size: 1.2rem; font-weight: bold;
            background-color: #252526;
            z-index: 10;
            transition: all 0.2s;
        }
        .char-idx {
            font-size: 0.7rem; color: #666; margin-bottom: 2px;
        }

        /* Pointers */
        .pointer {
            position: absolute;
            font-size: 0.8rem; font-weight: bold;
            transition: all 0.3s;
            opacity: 0;
            z-index: 20;
        }
        .ptr-i { top: -25px; color: #3b82f6; } /* Blue */
        .ptr-l { bottom: -25px; color: #22c55e; } /* Green */
        .ptr-r { bottom: -25px; color: #ef4444; } /* Red (initially, usually R is paired with L) */
        
        /* Highlights */
        .hl-center { border-color: #3b82f6; background-color: rgba(59, 130, 246, 0.2); box-shadow: 0 0 10px rgba(59, 130, 246, 0.3); }
        .hl-match { border-color: #22c55e; background-color: rgba(34, 197, 94, 0.2); }
        .hl-mismatch { border-color: #ef4444; background-color: rgba(239, 68, 68, 0.2); }
        .hl-best { border-color: #eab308; background-color: rgba(234, 179, 8, 0.1); box-shadow: 0 0 5px rgba(234, 179, 8, 0.5) inset; }

        /* Code Trace */
        .code-line { padding: 2px 8px; border-left: 3px solid transparent; opacity: 0.6; font-size: 13px; white-space: pre; }
        .code-active { background-color: #37373d; border-left-color: #f59e0b; opacity: 1; color: #fff; font-weight: bold; }
    </style>
</head>
<body class="h-screen flex flex-col overflow-hidden">

    <!-- Header -->
    <header class="bg-[#2d2d30] p-3 border-b border-[#333] shrink-0 flex justify-between items-center">
        <h1 class="text-lg font-bold text-white"><i class="fa-solid fa-expand text-amber-500 mr-2"></i>最长回文子串 - 中心扩展法</h1>
        <div class="text-xs text-gray-500">LeetCode 5. Longest Palindromic Substring</div>
    </header>

    <div class="flex-1 flex overflow-hidden">
        
        <!-- Left: Controls & Trace -->
        <div class="w-1/3 bg-[#252526] flex flex-col border-r border-[#333]">
            
            <!-- Controls -->
            <div class="p-4 border-b border-[#333] shrink-0 bg-[#1e1e1e]">
                <label class="text-xs text-gray-500 block mb-1">输入字符串 (Input String)</label>
                <div class="flex gap-2 mb-4">
                    <input id="in-str" type="text" value="babad" maxlength="15" class="flex-1 bg-[#333] border border-[#555] text-white text-sm px-2 py-1.5 rounded font-mono tracking-widest text-center uppercase">
                </div>
                <div class="flex gap-2">
                    <button id="btn-reset" class="bg-blue-600 hover:bg-blue-700 text-white px-3 py-1.5 rounded text-sm font-bold flex-1 transition"><i class="fa-solid fa-rotate-right mr-1"></i> 重置 (Reset)</button>
                    <button id="btn-step" class="bg-green-600 hover:bg-green-700 text-white px-3 py-1.5 rounded text-sm font-bold flex-1 transition disabled:opacity-50 disabled:cursor-not-allowed" disabled><i class="fa-solid fa-play mr-1"></i> 单步 (Step)</button>
                    <button id="btn-auto" class="bg-purple-600 hover:bg-purple-700 text-white px-3 py-1.5 rounded text-sm font-bold w-12 transition disabled:opacity-50"><i class="fa-solid fa-forward"></i></button>
                </div>
            </div>

            <!-- Stats -->
            <div class="p-3 border-b border-[#333] bg-[#1e1e1e] font-mono text-xs grid grid-cols-2 gap-2">
                <div>Center (i): <span id="var-i" class="text-blue-400 font-bold">-</span></div>
                <div>Max Len: <span id="var-maxlen" class="text-amber-400 font-bold">0</span></div>
                <div class="col-span-2 text-gray-400 mt-1 pb-1 border-b border-[#333]">Current Expansion:</div>
                <div>Type: <span id="var-type" class="text-white">-</span></div>
                <div>Length: <span id="var-curlen" class="text-white">0</span></div>
                <div>Left: <span id="var-l" class="text-green-400">-</span></div>
                <div>Right: <span id="var-r" class="text-green-400">-</span></div>
            </div>

            <!-- Code Trace -->
            <div class="flex-1 overflow-y-auto bg-[#1e1e1e] p-2 select-none font-mono">
                <div id="code-0" class="code-line text-gray-500">// 主循环: 遍历每个中心点</div>
                <div id="code-1" class="code-line">for (int i = 0; i < s.length(); i++) {</div>
                <div id="code-2" class="code-line">  // 1. 奇数扩展 (中心是一个字符)</div>
                <div id="code-3" class="code-line">  expand(s, i, i);</div>
                <div id="code-4" class="code-line">  // 2. 偶数扩展 (中心是空隙)</div>
                <div id="code-5" class="code-line">  expand(s, i, i + 1);</div>
                <div id="code-6" class="code-line">}</div>
                <div id="code-7" class="code-line"></div>
                <div id="code-8" class="code-line text-gray-500">// 核心函数: 向两边扩展</div>
                <div id="code-9" class="code-line">void expand(left, right) {</div>
                <div id="code-10" class="code-line">  while (left >= 0 && right < n </div>
                <div id="code-11" class="code-line">         && s[left] == s[right]) {</div>
                <div id="code-12" class="code-line">     if (currLen > maxLen) {</div>
                <div id="code-13" class="code-line">       updateMax(left, right);</div>
                <div id="code-14" class="code-line">     }</div>
                <div id="code-15" class="code-line">     left--; right++;</div>
                <div id="code-16" class="code-line">  }</div>
                <div id="code-17" class="code-line">}</div>
            </div>

            <!-- Log -->
            <div id="log-panel" class="h-24 bg-[#1e1e1e] border-t border-[#333] p-2 overflow-y-auto font-mono text-xs text-gray-400">
                <div>> Ready.</div>
            </div>
        </div>

        <!-- Right: Visualization -->
        <div class="w-2/3 bg-[#252526] p-6 relative flex flex-col items-center justify-center">
            
            <!-- Best Result Display -->
            <div class="absolute top-6 w-full text-center">
                <div class="text-xs text-gray-500 uppercase tracking-widest mb-1">Current Longest Palindrome</div>
                <div id="best-str" class="text-2xl font-bold text-amber-400 h-8"></div>
            </div>

            <!-- String Container -->
            <div id="str-container" class="flex items-end justify-center h-40 mb-10 relative">
                <!-- Chars injected by JS -->
            </div>

            <!-- Legend -->
            <div class="flex gap-6 text-xs text-gray-400 mt-8">
                <div class="flex items-center"><div class="w-3 h-3 border-2 border-blue-500 bg-blue-500/20 mr-2 rounded"></div> 当前中心 (i)</div>
                <div class="flex items-center"><div class="w-3 h-3 border-2 border-green-500 bg-green-500/20 mr-2 rounded"></div> 匹配 (Match)</div>
                <div class="flex items-center"><div class="w-3 h-3 border-2 border-red-500 bg-red-500/20 mr-2 rounded"></div> 不匹配 (Mismatch)</div>
                <div class="flex items-center"><div class="w-3 h-3 border-2 border-amber-500 bg-amber-500/20 mr-2 rounded"></div> 最长记录 (Best)</div>
            </div>

        </div>
    </div>

    <script>
        // --- State Enum ---
        const State = {
            INIT: 0,
            NEW_CENTER: 1,      // Loop i
            PREPARE_ODD: 2,     // Call expand(i, i)
            PREPARE_EVEN: 3,    // Call expand(i, i+1)
            EXPAND_CHECK: 4,    // check while condition
            EXPAND_SUCCESS: 5,  // update len, move pointers
            EXPAND_FAIL: 6,     // break loop
            DONE: 99
        };

        // --- Data (Renamed to avoid global conflict) ---
        let palStr = "";
        let strLen = 0;   // Renamed from n
        let centerIdx = 0; // Renamed from i
        let leftPtr = 0, rightPtr = 0; // Renamed from l, r
        let maxLen = 0;
        let startIdx = 0;
        let currState = State.INIT;
        let expandType = "ODD"; // "ODD" or "EVEN"
        let autoPlayTimer = null;

        // --- DOM ---
        const els = {
            input: document.getElementById('in-str'),
            btnReset: document.getElementById('btn-reset'),
            btnStep: document.getElementById('btn-step'),
            btnAuto: document.getElementById('btn-auto'),
            container: document.getElementById('str-container'),
            log: document.getElementById('log-panel'),
            bestStr: document.getElementById('best-str'),
            
            vI: document.getElementById('var-i'),
            vMax: document.getElementById('var-maxlen'),
            vType: document.getElementById('var-type'),
            vCurLen: document.getElementById('var-curlen'),
            vL: document.getElementById('var-l'),
            vR: document.getElementById('var-r')
        };

        // --- Init ---
        els.btnReset.addEventListener('click', init);
        els.btnStep.addEventListener('click', step);
        els.btnAuto.addEventListener('click', toggleAuto);
        els.input.addEventListener('input', () => {
            stopAuto();
            els.btnStep.disabled = true;
            els.btnStep.innerHTML = '<i class="fa-solid fa-rotate-right mr-1"></i> 重置';
        });

        function init() {
            stopAuto();
            palStr = els.input.value.toUpperCase();
            if(!palStr) palStr = "BABAD";
            els.input.value = palStr;
            strLen = palStr.length;

            centerIdx = 0;
            leftPtr = 0; rightPtr = 0;
            maxLen = 0; startIdx = 0;
            currState = State.NEW_CENTER; // Start at first center loop

            // Render Chars
            els.container.innerHTML = "";
            for(let k=0; k<strLen; k++) {
                const box = document.createElement('div');
                box.className = 'char-box';
                box.id = `box-${k}`;
                
                const val = document.createElement('div');
                val.className = 'char-val';
                val.innerText = palStr[k];
                val.id = `val-${k}`;
                
                const idx = document.createElement('div');
                idx.className = 'char-idx';
                idx.innerText = k;

                // Pointers
                const ptrI = createPtr('i', 'i', 'ptr-i');
                const ptrL = createPtr('l', 'L', 'ptr-l');
                const ptrR = createPtr('r', 'R', 'ptr-r'); // Use green for R usually, separate if mismatch

                box.appendChild(ptrI);
                box.appendChild(ptrL);
                box.appendChild(ptrR);
                box.appendChild(idx);
                box.appendChild(val);
                els.container.appendChild(box);
            }

            els.log.innerHTML = "";
            log("初始化完成. String length: " + strLen);
            updateUI();
            els.btnStep.disabled = false;
            els.btnStep.innerHTML = '<i class="fa-solid fa-play mr-1"></i> 单步 (Step)';
            highlightCode('code-1');
        }

        function createPtr(idSuffix, text, colorClass) {
            const d = document.createElement('div');
            d.className = `pointer ${colorClass}`;
            d.id = `ptr-${idSuffix}-dynamic`; // will be moved around? No, cloned into boxes
            d.innerText = text;
            return d;
        }

        // --- Step Logic ---
        function step() {
            switch(currState) {
                case State.NEW_CENTER:
                    // Loop condition check
                    resetPointers();
                    if (centerIdx >= strLen) {
                        currState = State.DONE;
                        step(); // auto finish
                        return;
                    }
                    
                    highlightCode('code-1');
                    updatePointers(centerIdx, -1, -1); // Show i
                    highlightBox(centerIdx, 'hl-center');
                    log(`>>> New Center i = ${centerIdx} ('${palStr[centerIdx]}')`);
                    currState = State.PREPARE_ODD;
                    break;

                case State.PREPARE_ODD:
                    expandType = "ODD";
                    leftPtr = centerIdx; 
                    rightPtr = centerIdx;
                    highlightCode('code-3');
                    log(`准备奇数扩展 (Odd Expand): Center '${palStr[centerIdx]}'`);
                    currState = State.EXPAND_CHECK;
                    break;

                case State.PREPARE_EVEN:
                    expandType = "EVEN";
                    leftPtr = centerIdx;
                    rightPtr = centerIdx + 1;
                    highlightCode('code-5');
                    log(`准备偶数扩展 (Even Expand): Gap between ${centerIdx} & ${centerIdx+1}`);
                    currState = State.EXPAND_CHECK;
                    break;

                case State.EXPAND_CHECK:
                    updatePointers(centerIdx, leftPtr, rightPtr);
                    highlightCode(['code-10', 'code-11']);
                    
                    // Check bounds and match
                    if (leftPtr >= 0 && rightPtr < strLen) {
                        // Highlight comparison
                        highlightBox(leftPtr, 'hl-match', true); // Tentative
                        highlightBox(rightPtr, 'hl-match', true);
                        
                        if (palStr[leftPtr] === palStr[rightPtr]) {
                            log(`比较 s[${leftPtr}] vs s[${rightPtr}]: '${palStr[leftPtr]}' == '${palStr[rightPtr]}' -> <span class="text-green-400">Match</span>`);
                            currState = State.EXPAND_SUCCESS;
                        } else {
                            log(`比较 s[${leftPtr}] vs s[${rightPtr}]: '${palStr[leftPtr]}' != '${palStr[rightPtr]}' -> <span class="text-red-400">Mismatch</span>`);
                            highlightBox(leftPtr, 'hl-mismatch');
                            highlightBox(rightPtr, 'hl-mismatch');
                            currState = State.EXPAND_FAIL;
                        }
                    } else {
                        log(`边界检查: L=${leftPtr}, R=${rightPtr} -> <span class="text-gray-400">Out of bounds</span>`);
                        currState = State.EXPAND_FAIL;
                    }
                    break;

                case State.EXPAND_SUCCESS:
                    // Calc len
                    const curLen = rightPtr - leftPtr + 1;
                    highlightCode(['code-12', 'code-13', 'code-15']);
                    
                    if (curLen > maxLen) {
                        maxLen = curLen;
                        startIdx = leftPtr;
                        log(`New Max Found! Length = ${maxLen} ("${palStr.substring(leftPtr, rightPtr+1)}")`, "text-amber-400 font-bold");
                        markBest(leftPtr, rightPtr);
                    } else {
                        log(`Match extended. Length = ${curLen} (Max is ${maxLen})`);
                    }
                    
                    // Move pointers
                    leftPtr--;
                    rightPtr++;
                    currState = State.EXPAND_CHECK; // Loop back
                    break;

                case State.EXPAND_FAIL:
                    // Break loop
                    log("停止扩展.");
                    resetHighlights(); // clear green/red, keep yellow/blue
                    
                    if (expandType === "ODD") {
                        currState = State.PREPARE_EVEN;
                    } else {
                        // Even done, move to next center
                        centerIdx++;
                        currState = State.NEW_CENTER;
                    }
                    break;

                case State.DONE:
                    highlightCode([]);
                    log(`算法结束. 最长回文: "${palStr.substr(startIdx, maxLen)}"`, "text-green-400 font-bold text-lg");
                    els.btnStep.disabled = true;
                    stopAuto();
                    // Final highlight
                    clearAllVisuals();
                    for(let k=startIdx; k<startIdx+maxLen; k++) {
                        document.getElementById(`val-${k}`).classList.add('hl-best');
                    }
                    els.bestStr.innerText = palStr.substr(startIdx, maxLen);
                    return;
            }
            updateUI();
        }

        // --- Visual Helpers ---

        function updatePointers(idxI, idxL, idxR) {
            // Hide all first
            document.querySelectorAll('.pointer').forEach(el => el.style.opacity = '0');
            
            // Show I
            if(idxI < strLen) {
                const box = document.getElementById(`box-${idxI}`);
                box.querySelector('.ptr-i').style.opacity = '1';
            }

            // Show L
            if(idxL >= 0 && idxL < strLen) {
                const box = document.getElementById(`box-${idxL}`);
                box.querySelector('.ptr-l').style.opacity = '1';
                box.querySelector('.ptr-l').innerText = 'L';
            }

            // Show R
            if(idxR >= 0 && idxR < strLen) {
                const box = document.getElementById(`box-${idxR}`);
                const ptrR = box.querySelector('.ptr-r'); // Normally red class
                ptrR.style.opacity = '1';
                ptrR.innerText = 'R';
                
                // If L == R (odd center start), adjust display?
                if (idxL === idxR) {
                    ptrR.style.display = 'none'; // Hide R if same as L, L implies both
                } else {
                    ptrR.style.display = 'block';
                    if (currState === State.EXPAND_SUCCESS) {
                         ptrR.className = "pointer ptr-r !text-green-500";
                    } else {
                         ptrR.className = "pointer ptr-r";
                    }
                }
            }
        }

        function highlightBox(idx, className, append = false) {
            if (idx < 0 || idx >= strLen) return;
            const el = document.getElementById(`val-${idx}`);
            if (!append) {
                // Keep hl-best if it exists?
                const isBest = el.classList.contains('hl-best');
                el.className = 'char-val'; // reset
                if(isBest) el.classList.add('hl-best');
            }
            el.classList.add(className);
        }

        function resetHighlights() {
            // Remove match/mismatch/center, keep best
            for(let k=0; k<strLen; k++) {
                const el = document.getElementById(`val-${k}`);
                if (el.classList.contains('hl-best')) {
                    el.className = 'char-val hl-best';
                } else {
                    el.className = 'char-val';
                }
            }
        }
        
        function clearAllVisuals() {
             for(let k=0; k<strLen; k++) {
                document.getElementById(`val-${k}`).className = 'char-val';
            }
        }

        function markBest(l, r) {
            // Clear previous best
            document.querySelectorAll('.hl-best').forEach(el => el.classList.remove('hl-best'));
            // Mark new
            for(let k=l; k<=r; k++) {
                document.getElementById(`val-${k}`).classList.add('hl-best');
            }
            els.bestStr.innerText = palStr.substring(l, r+1);
        }

        function resetPointers() {
             document.querySelectorAll('.pointer').forEach(el => el.style.opacity = '0');
        }

        function highlightCode(ids) {
            document.querySelectorAll('.code-active').forEach(el => el.classList.remove('code-active'));
            if(!ids) return;
            if (Array.isArray(ids)) {
                ids.forEach(id => document.getElementById(id)?.classList.add('code-active'));
            } else {
                document.getElementById(ids)?.classList.add('code-active');
            }
        }

        function updateUI() {
            els.vI.innerText = centerIdx < strLen ? centerIdx : '-';
            els.vMax.innerText = maxLen;
            els.vType.innerText = expandType;
            els.vType.className = expandType === 'ODD' ? 'text-blue-400 font-bold' : 'text-purple-400 font-bold';
            
            // Only show L/R/Len during check/expand
            if (currState >= State.EXPAND_CHECK && currState <= State.EXPAND_FAIL) {
                // Length if matched = R - L + 1
                els.vCurLen.innerText = Math.max(0, rightPtr - leftPtr + 1);
                els.vL.innerText = leftPtr;
                els.vR.innerText = rightPtr;
            } else {
                els.vCurLen.innerText = '-';
                els.vL.innerText = '-';
                els.vR.innerText = '-';
            }
        }

        function log(msg, classes="") {
            const d = document.createElement('div');
            d.innerHTML = `> ${msg}`;
            if(classes) d.className = classes;
            els.log.appendChild(d);
            els.log.scrollTop = els.log.scrollHeight;
        }

        // --- Auto Play ---
        function toggleAuto() {
            if (autoPlayTimer) {
                stopAuto();
            } else {
                startAuto();
            }
        }

        function startAuto() {
            if (currState === State.DONE) return;
            els.btnAuto.innerHTML = '<i class="fa-solid fa-pause"></i>';
            els.btnStep.disabled = true;
            autoPlayTimer = setInterval(() => {
                step();
                if(currState === State.DONE) stopAuto();
            }, 600);
        }

        function stopAuto() {
            if(autoPlayTimer) clearInterval(autoPlayTimer);
            autoPlayTimer = null;
            els.btnAuto.innerHTML = '<i class="fa-solid fa-forward"></i>';
            if (currState !== State.DONE) els.btnStep.disabled = false;
        }

        // Start
        init();

    </script>
</body>
</html>