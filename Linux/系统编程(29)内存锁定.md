你说的“内存锁定”一般是指：把进程的某些内存页**锁在物理内存(RAM)**里，**禁止被 swap 到磁盘**，也尽量避免被内核回收/置换，用于 **安全**（密钥不落盘）或 **实时性**（避免缺页带来抖动）。

在 Linux 上主要就是 `mlock/munlock/mlockall`（以及更新一点的 `mlock2`）。


## 1) Linux 内存锁定的核心 API（<sys/mman.h>）

### mlock / munlock：锁一段地址范围

```C
#include <sys/mman.h>

int mlock(const void *addr, size_t len);
int munlock(const void *addr, size_t len);
```

- **作用**：把 `[addr, addr+len)` 覆盖到的页锁住 / 解锁
    
- **返回值**：成功 0；失败 -1 并设置 `errno`
    
- **注意**：内核会按**页大小**向下/向上取整（不需要你手动页对齐，但理解这一点很重要）
    

### mlockall / munlockall：锁整个进程地址空间

```C
int mlockall(int flags);
int munlockall(void);
```

`flags` 常用：

- `MCL_CURRENT`：锁住当前已映射的所有页
    
- `MCL_FUTURE`：以后新映射的页也自动锁住（常用于实时程序启动时）
    

### mlock2：更细粒度（Linux 较新）

```C
int mlock2(const void *addr, size_t len, int flags);
```

常见 `flags`：

- `MLOCK_ONFAULT`：**按需锁定**（首次访问触发缺页时再锁），避免 `mlock` 一次性把很多页都 fault-in 造成启动抖动。

---

## 2) 为什么会失败：权限与上限（非常常见）

内存锁定受 **RLIMIT_MEMLOCK** 限制（可锁住的字节数上限）：

- 普通用户通常默认只有几十 KB 或几 MB
    
- 超过上限会 `errno=ENOMEM`
    

检查/修改：

- 查看：`ulimit -l`（单位通常是 KB）
    
- 临时提高：`ulimit -l unlimited`（需要权限/系统允许）
    
- systemd 服务：设置 `LimitMEMLOCK=infinity`
    
- 或需要 `CAP_IPC_LOCK` 能力（容器/服务常用）

-------
## 3) 典型用途

### A. 安全：防止密钥/敏感数据被 swap 到磁盘

流程通常是：

1. 用 `mmap` 分配一块内存（便于控制）
    
2. `mlock` 锁住
    
3. 可选：`madvise(MADV_DONTDUMP)` 防止进 core dump
    
4. 用完 `explicit_bzero` 清零
    
5. `munlock` + `munmap`
    

示例（可直接编译）：
```C
#define _GNU_SOURCE
#include <sys/mman.h>
#include <string.h>
#include <stdio.h>
#include <errno.h>
#include <unistd.h>

int main() {
    size_t n = 4096; // 1页
    unsigned char *p = mmap(NULL, n, PROT_READ|PROT_WRITE,
                            MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
    if (p == MAP_FAILED) { perror("mmap"); return 1; }

    if (mlock(p, n) != 0) {
        perror("mlock");   // 可能是 RLIMIT_MEMLOCK 不够
        munmap(p, n);
        return 1;
    }

    // 建议：防止写进 core dump
    madvise(p, n, MADV_DONTDUMP);

    // 假装这里存了密钥
    memcpy(p, "SECRET_KEY", 10);

    // 使用完毕：清零（避免被优化掉，优先 explicit_bzero）
    explicit_bzero(p, n);

    munlock(p, n);
    munmap(p, n);
    return 0;
}

```

```C
madvise(p, n, MADV_DONTDUMP);
```
意思是：**告诉内核**“当这个进程崩溃生成 core dump（崩溃转储文件）时，不要把这段内存 `[p, p+n)` 的内容写进 core 文件里”。

### 为什么要这么做？

如果你的内存里放的是**密钥、口令、token、隐私数据**，进程一旦崩溃生成 core dump，这些敏感内容可能会被**完整落盘**（core 文件通常在磁盘上）。`MADV_DONTDUMP` 可以降低这个风险。


-----
## 该页在物理内存中吗？

`mincore` 用来**查询一段虚拟地址范围内，每一页是否“在内存里驻留(resident)”**——也就是这页当前是否在 RAM 里（而不是还没被 fault-in，或被回收/换出）。它不改变内存内容，只是“问一下内核”。

```C
#include <sys/mman.h>

int mincore(void *addr, size_t length, unsigned char *vec);
```

### 参数

- `addr`：要查询的起始地址（**必须页对齐**，否则 `EINVAL`）
    
- `length`：查询长度（会覆盖到的页数为 `ceil(length / pagesize)`）
    
- `vec`：输出数组，长度至少等于“页数”，每个字节对应一页
    
    - `vec[i] & 1` 为 1 表示该页 resident（在内存里）
        

### 返回值

- 成功：0
    
- 失败：-1，并设置 `errno`  
    常见：`EINVAL`（addr 不页对齐 / vec 不可写）、`ENOMEM`（范围不在进程映射里）
    

---

## 用途

- 判断某段 mmap 的文件/匿名内存是否已被 **prefault** 到 RAM
    
- 做性能诊断：哪些页常驻、哪些页可能频繁缺页
    
- 配合 `mlock/mlockall` 或 `madvise` 验证效果（注意：它只能告诉“现在在不在”，不保证未来）

-----
**例子：mmap 一块内存，触碰前后用 mincore 看驻留变化
```C
#define _GNU_SOURCE
#include <sys/mman.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>

static void show_mincore(void *p, size_t len) {
    long ps = sysconf(_SC_PAGESIZE);
    size_t pages = (len + ps - 1) / ps;

    unsigned char *vec = calloc(pages, 1);
    if (!vec) { perror("calloc"); exit(1); }

    // mincore 要求 addr 页对齐
    if (mincore(p, len, vec) != 0) {
        perror("mincore");
        free(vec);
        return;
    }

    size_t resident = 0;
    for (size_t i = 0; i < pages; i++) {
        if (vec[i] & 1) resident++;
    }
    printf("resident %zu/%zu pages\n", resident, pages);

    free(vec);
}

int main() {
    long ps = sysconf(_SC_PAGESIZE);
    size_t len = (size_t)ps * 4; // 4页

    void *p = mmap(NULL, len, PROT_READ | PROT_WRITE,
                   MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
    if (p == MAP_FAILED) { perror("mmap"); return 1; }

    puts("Before touching:");
    show_mincore(p, len);

    // 触碰每一页，触发缺页，把页带入内存
    for (size_t off = 0; off < len; off += (size_t)ps) {
        ((volatile char*)p)[off] = 1;
    }

    puts("After touching:");
    show_mincore(p, len);

    munmap(p, len);
    return 0;
}

```

-----
## 投机性内存分配

“投机性内存分配策略”（speculative allocation）可以理解为：**先按“很可能会用到”的假设把内存提前分配/保留好**，哪怕当前还不一定真的需要；等到真正需要时就能立刻用，省掉当下的分配/扩容/系统调用开销。若最后没用上，再延后释放或批量回收。

它的核心是用**空间换时间**，以及用**更平滑的延迟**换取吞吐/响应稳定性。

## 典型形式

1. **预分配（pre-allocation / pooling）**  
    启动时或空闲时先申请一批块，后续请求直接从池里拿。
    

- 例：对象池、固定大小 slab、连接对象池、请求上下文池。
    

2. **提前扩容（over-allocation / growth factor）**  
    容器扩容时不只扩到“刚够”，而是多扩一些（比如 x1.5/x2），赌后面还会继续增长。
    

- 例：`std::vector` 的 capacity 增长策略。
    

3. **本地缓存/线程缓存（tcache / per-thread cache）**  
    每个线程先“囤”一批小块，避免频繁跨线程/全局锁竞争。
    

- 例：tcmalloc/jemalloc 的线程本地缓存思想。
    

4. **投机保留虚拟地址空间（reserve VA, commit later）**  
    先 `mmap` 一大段地址空间（不一定立刻物理分配），用到哪页再触碰触发缺页分配。
    

- 例：大数组、arena 先 reserve，逐步 commit（Linux 上常见）。
    

## 为什么要这么做

- **降低 P99/P999 延迟抖动**：把昂贵的 `malloc/mmap/扩容` 挪到“更不敏感”的时刻。
    
- **减少系统调用与锁竞争**：批量拿、批量还，比频繁小额分配更便宜。
    
- **提升局部性**：从池里拿到的内存往往更连续、cache 更友好。
    

## 代价/风险

- **内存占用更高**：可能分配了但没用上。
    
- **更容易产生“看起来 free 了也不降 RSS”**：池/arena 不急着归还 OS。
    
- **错误的“投机”会放大问题**：负载变化时可能导致内存膨胀或碎片。
    
- **需要上限与回收策略**：否则会变成“无脑囤货”。
    

## 一个很直观的例子：vector 的提前扩容

你每次 `push_back` 如果都刚好扩 1 个元素，会频繁 `realloc + memcpy`。所以容器会投机性地多留容量：

```C
std::vector<int> v;
for (int i = 0; i < 1000000; i++) v.push_back(i);
// v.capacity() 通常会远大于 v.size()（为未来增长“投机”）
```

这就是典型的投机策略：**相信你还会继续 push，所以先多拿一点**。
