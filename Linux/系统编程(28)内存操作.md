C语言提供了很多函数，可以执行对内存原始字节的操作。这些函数的功能和字符串操作函数如strcmp()和strcpy()的功能类似，但是它们处理的是用户提供的缓存大小，而不是以NULL结尾的字符串。要注意的是，这些函数都不会返回错误。因此，编程人员需要自己实现错误防范——如果传递错误的内存区域而没有防范措施，将毫无疑问会得到段错误！

------
## 1.字节设置

**memset函数：
```C
#include <string.h>

void* memset(void* s,int c,size_t n);
```
**返回值**：`void*`，等于 `s`。
调用memset()，会把s指向区域开始的前n个字节设置为c，并返回s。该函数经常用来清零一块内存：
```C
memset(s,'\0',256);
```
**只要可以使用calloc()分配内存，就坚决不要使用memset()！** 
 如果要获取一块清零的内存，不要采用这种方式：先用malloc()分配了内存，再马上使用 memset()来进行清零。相反，应该调用calloc()函数，可以一次调用直接返回已经清零了的空间。调用calloc()的好处不仅在于少了一次函数调用，而且calloc()是直接从内存中获取已经清零了的内存，这显然比手工将每个字节清零更高效。

----
## 2.字节比较

和strcmp()类似，memcmp()会比较两块内存是否相等：
```C
#include <string.h>
int memcmp(void* s1,void* s2,size_t n);
```
调用memcmp()会比较s1和s2的前n个字节，如果两块内存相同就返回0，如果s1小于s2就返回一个小于0的数，反之则返回大于0的数。

-----
## 3.字节移动
memmove()会把src的前n个字节复制到dst，并返回dst：
```C
#include <string.h>
void* memmove(void* dst,const void* src,size_t n);
```


bcopy()和 memmove()都可以安全处理内存区域重叠问题（也就是说，dst的一部分是在src 里面）。通过这种方式，可以允许内存块在一个给定区域内向上或下移动。

你这个疑惑点非常关键：**“src 是 const，为什么还能发生覆盖？”**  
答案是：`const` 只限制**通过 `src` 这个指针去写**，并不意味着这块内存“物理上只读”，更不意味着**同一块内存不能通过别的指针写**。

虽然这种情况很少见，但是如果出现这种情况，编程人员应该了解。C标准定义了memmove()变体，它不支持内存区域覆盖。这个变体可能会更快一些： 
```C
#include <string.h>
void* memcpy(void* dst,const void* src,size_t n);
```
除了dst和src间不能重叠，这个函数基本和memmove()一样。如重叠了，函数的结果是未被定义的。另外一个安全的复制函数是memccpy()：
```C
#include <string.h>
void* memccpy(void* dst,const void* src,int c,size_t n);
```

memccpy()和memcpy()类似，区别在于对于memccpy()，当它在src指向的前n个字节中找到字节c时，就会停止拷贝。它返回指向dst中字节c的下一个字节的指针，没有找到c时，返回NULL。

----
## 4.字节查找

函数memchr()和memrchr()可以在内存块中查找一个给定的字节：

```C
#include <string.h>
void* memchr(const void* s,int c,size_t n);
```
### 参数

- `s`：要搜索的内存起始地址
    
- `c`：要找的字节值（**只取低 8 位**，等价于 `(unsigned char)c`）
    
- `n`：在 `s` 开始的前 `n` 个字节中搜索
### 返回值

- 找到：返回指向**第一次匹配字节**的指针（类型 `void*`）
    
- 没找到：返回 `NULL`

## 关键点（很容易踩坑）

1. **按字节找，不关心类型**：哪怕 `s` 指向 `int[]`，也只是把它当作字节序列扫描。
    
2. **不会因为遇到 `\0` 停止**：和 `strchr` 不同，`memchr` 只看 `n` 个字节。
    
3. **`c` 是 int，但只比较一个字节**：所以 `c=0x1234` 实际比较的是 `0x34`。
    
4. **返回值要注意类型转换**：常把结果转回 `unsigned char*` 或原类型指针再做偏移。
例子：
```C
#include <string.h>
#include <stdio.h>

int main() {
    const char buf[] = "abc\ndef";
    const void *p = memchr(buf, '\n', sizeof(buf)); // sizeof 包含 '\0'

    if (p) {
        size_t pos = (const char*)p - buf;
        printf("found at %zu\n", pos); // 3
    }
}
```


对于更加复杂的搜索，有个名字很糟糕的函数memmem()，它可以在一块内存中搜索任意的字节数组： 
```C
#define _GNU_SOURCE
#include <string.h>

void *memmem(const void *haystack, size_t haystacklen,
             const void *needle,   size_t needlelen);
```
`memmem` 用来在**一段原始内存**（可含 `\0`）里查找**另一段内存子串**第一次出现的位置，相当于“二进制版的 `strstr`。

### 参数

- `haystack` / `haystacklen`：被搜索的内存块及长度
    
- `needle` / `needlelen`：要查找的“模式”内存块及长度
### 返回值

- 找到：返回指向 `haystack` 中**第一次匹配起点**的指针
    
- 没找到：返回 `NULL`
### 常见边界

- `needlelen == 0`：通常返回 `haystack`（视实现，glibc 是这样）
    
- `needlelen > haystacklen`：必然 `NULL`

```C
#define _GNU_SOURCE
#include <stdio.h>
#include <string.h>

int main() {
    unsigned char buf[] = {0x11, 0x22, 0x00, 0x33, 0x44, 0x55};
    unsigned char pat[] = {0x00, 0x33, 0x44};

    unsigned char *p = memmem(buf, sizeof(buf), pat, sizeof(pat));
    if (p) {
        printf("found at index %zu\n", (size_t)(p - buf)); // 2
    } else {
        puts("not found");
    }
    return 0;
}
```

----
## 5.字节加密

`memfrob` 是 **glibc/Linux 的 GNU 扩展函数**（不是 C 标准库），作用很“奇怪但简单”：

> 把一段内存里的每个字节都 **异或 (XOR) 42**（十进制 42，十六进制 `0x2A`），并返回原指针。  
> 再对同一段内存调用一次 `memfrob`，会**还原**（因为 XOR 两次同一个值会回到原值）。

```C
#define _GNU_SOURCE
#include <string.h>

void *memfrob(void *s, size_t n);
```
### 参数 / 返回值

- `s`：要处理的内存起始地址（会被原地修改）
    
- `n`：处理的字节数
    
- 返回：`s`

