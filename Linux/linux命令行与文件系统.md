# 二、命令行与文件系统：详细讲解

## 1. 路径与目录结构（/、/home、/etc、/var、/usr 等）

### 1.1 Linux 是“单根”树形文件系统

和 Windows 有 `C: D:` 这些盘符不同，Linux 只有一个“根”：

- 根目录：`/`

从 `/` 开始向下是一棵树，所有磁盘、分区、U 盘、网络文件系统，最终都会“挂载（mount）”到这棵树上的某个目录下。

可以类比：
> 整个系统只有一棵巨大文件树，`/` 是树根。

### 1.2 常见顶层目录含义

不同发行版会略有差别，但大体类似：

- `/`：根目录，一切的起点。
- `/home`：普通用户的“家目录”根，每个用户一个子目录。
  - 例如用户 `alice` 的 home：`/home/alice`
- `/root`：root（超级用户）的家目录。
- `/etc`：系统**配置文件**集中地，绝大多数服务和系统配置都在这里。
  - 例如：`/etc/passwd`（用户信息）、`/etc/ssh/sshd_config`（SSH 服务配置）。
- `/var`：存放“可变数据”（variable），例如日志、缓存、邮件队列等。
  - `/var/log`：系统和服务的日志文件几乎都在这里。
  - `/var/www`：常用作 Web 服务根目录（视发行版与配置而定）。
- `/usr`：最容易被误解的目录之一：
  - `/usr/bin`：大部分用户级可执行文件；
  - `/usr/lib`：库文件；
  - `/usr/share`：与架构无关的共享数据；
  - `/usr/local`：本机手动安装的软件（不通过包管理器）；
  
  可以粗略理解 `/usr` 为“系统提供的用户空间程序和库的集合”。

- `/bin`、`/sbin`：传统上用于存放基本命令和系统管理命令（可执行文件）。
  - 如 `ls`、`cp` 等在一些系统中可能位于 `/bin` 或 `/usr/bin`。
- `/tmp`：临时文件目录，重启后可能被清空。
- `/dev`：各种设备文件（磁盘、终端、随机数设备等），一切皆文件的体现。
- `/proc`：虚拟文件系统，内核将进程和系统状态暴露为一堆“文件”。
  - 例如 `/proc/cpuinfo`、`/proc/meminfo`。
- `/mnt`、`/media`：常用作挂载额外存储（U 盘、网络盘等）的挂载点。

**学习建议**：

- 经常 `cd /` 然后 `ls` 一眼，看熟这几个目录；
- 然后分别 `cd /etc`、`cd /var/log` 浏览内容，逐渐形成直觉。

### 1.3 路径再复习

- 绝对路径：以 `/` 开头，例如 `/etc/ssh/sshd_config`；
- 相对路径：相对当前目录，例如当前在 `/home/alice`，`../bob` 就是 `/home/bob`；
- 特殊符号：
  - `.`：当前目录
  - `..`：上一级目录
  - `~`：当前用户的 home 目录

实操例子：

```bash
cd /etc
pwd           # /etc
cd ..         # 回到 /
pwd           # /
cd ~          # 回到自己的 home
pwd           # /home/yourname
```

---

## 2. 常用文件与目录操作命令（ls、cd、cp、mv、rm、mkdir、find 等）

这一部分基本是日常操作的“基础工具箱”，尽量通过练习记住。

### 2.1 `ls`：列出目录内容

常用形式：

```bash
ls              # 列出当前目录
ls -a           # 显示隐藏文件（以 . 开头）
ls -l           # 以长格式显示（权限、所有者、大小、时间）
ls -lh          # 长格式 + 人类友好大小（KB/MB/GB）
ls -R           # 递归列出子目录内容
```

长格式示例：

```bash
ls -l
-rw-r--r-- 1 alice staff   1200 Jan  1 10:00 file.txt
```

字段大致含义：
- `-rw-r--r--`：权限（后面讲权限时详细说）；
- `1`：硬链接数；
- `alice`：所有者；
- `staff`：所属用户组；
- `1200`：大小（字节数）；
- `Jan 1 10:00`：最后修改时间；
- `file.txt`：文件名。

### 2.2 `cd`：切换目录

```bash
cd /etc          # 切换到 /etc
cd ~             # 切换到当前用户 home
cd               # 不带参数，默认到 home
cd -             # 回到上一次所在目录（常用）
```

### 2.3 `mkdir` / `rmdir`：创建/删除目录

```bash
mkdir test             # 创建目录 test
mkdir -p a/b/c         # 按层级创建，如果上层不存在就一并创建
rmdir empty_dir        # 删除“空目录”（里面不能有文件）
```

实际上更多时候我们用 `rm -r` 来删除目录。

### 2.4 `rm`：删除文件/目录（危险命令）

```bash
rm file.txt            # 删除一个文件
rm -i file.txt         # 删除前询问确认
rm -r dir              # 递归删除目录及其内容
rm -rf dir             # 强制递归删除（不询问）
```

**强烈建议**：刚开始学习时，对重要目录（尤其不是很确定路径时），先用：

```bash
ls 要删的路径
```
确认里面是什么，再 `rm`。

### 2.5 `cp`：复制文件/目录

```bash
cp a.txt b.txt         # 复制文件
cp a.txt /tmp/         # 复制到另一个目录
cp -r dir1 dir2        # 递归复制目录
cp -i a.txt b.txt      # 覆盖前询问确认
cp -v a.txt b.txt      # 显示复制过程（verbose）
```

### 2.6 `mv`：移动/重命名

```bash
mv a.txt b.txt         # 重命名
mv a.txt /tmp/         # 移动到 /tmp
mv dir1 dir2           # 给目录改名/移动目录
```

注意：同一文件系统内移动文件时，`mv` 通常只是改“目录项”，非常快；跨文件系统则类似于“复制+删除”。

### 2.7 `find`：在文件树中搜索

`find` 非常强大，但初学阶段记几个常见模式就够用了：

```bash
# 在当前目录及子目录中查找名为 test.txt 的文件
find . -name "test.txt"

# 忽略大小写查找
find . -iname "test.txt"

# 查找某种后缀的文件
find . -name "*.log"

# 找修改时间在 7 天内的文件
find . -mtime -7

# 找到后对每个结果执行命令（例如删除）
find . -name "*.tmp" -delete
# 或
find . -name "*.tmp" -exec rm {} \;
```

基本语法结构：

```bash
find [起点路径...] [匹配条件] [对匹配结果的操作]
```

> 当你目录结构层次复杂、文件很多时，`find` 会比“到处 cd + ls”高效很多。

---

## 3. 文件查看与搜索（cat、less、head、tail、grep、wc 等）

### 3.1 `cat`：快速查看小文件

```bash
cat file.txt
```

适用于文件不大、只想“一眼看完”的情况。文件很大时会一股脑刷屏，不适合。

还可以用于组合文件：

```bash
cat a.txt b.txt > c.txt   # 拼接两个文件
```

### 3.2 `less`：分页查看（推荐）

```bash
less file.txt
```

常用按键：
- 上下键 / PgUp / PgDn：翻页；
- `g`：跳到文件开头；
- `G`：跳到文件结尾；
- `/关键字`：向下搜索；
- `?关键字`：向上搜索；
- `n` / `N`：下一个/上一个匹配；
- `q`：退出。

> 看配置、看日志、看大文件时，`less` 基本是默认选择。

### 3.3 `head` / `tail`：看开头 / 结尾

```bash
head file.txt        # 默认看前 10 行
head -n 20 file.txt  # 看前 20 行

tail file.txt        # 默认看后 10 行
tail -n 50 file.txt  # 看后 50 行
```

监控日志（实时刷新）常用：

```bash
tail -f /var/log/syslog
# 或
tail -f app.log
```

`-f` 会一直“追踪”文件增长，新写入的内容会不断打印出来。

### 3.4 `grep`：文本搜索神器

基本用法：

```bash
grep "pattern" file.txt
```

常见选项：

```bash
grep -n "error" app.log     # 显示行号
grep -i "error" app.log     # 忽略大小写
grep -r "TODO" .            # 在当前目录递归搜索
```

结合 `pipe`（管道）使用更强大（管道后面可以再系统讲）：

```bash
ps aux | grep nginx        # 从 ps 输出中筛选包含 nginx 的行
journalctl | grep "ERROR"  # 从系统日志中筛选错误
```

### 3.5 `wc`：统计行数、单词数、字节数

```bash
wc file.txt      # 输出：行数 单词数 字节数 文件名
wc -l file.txt   # 只看行数

# 配合其他命令：统计当前目录下 .c 文件总行数
cat *.c | wc -l
```

### 3.6 常用“组合拳”示例

1. 在代码中找某个函数定义：

```bash
grep -rn "my_function" src/
```

2. 观察日志末尾，筛选关键字：

```bash
tail -f app.log | grep "ERROR"
```

3. 看最近生成的日志文件，找出含关键词的行数：

```bash
ls -lt *.log | head        # 先看最近的日志
grep -c "timeout" latest.log
```

---

## 4. 硬链接、软链接与 inode

这一部分稍微抽象些，但对理解 Linux 文件系统“本质”很重要。

### 4.1 inode：文件的“身份证”

在 Linux 文件系统里，“文件名”并不是文件本体，而是一个“目录项”；
真正描述文件数据和元信息的是 **inode（索引节点）**。

你可以这样想：

- inode 就像一个“身份证记录”：
  - 里面写着：文件类型（普通文件、目录、管道等）、权限、所有者、大小、磁盘块位置、时间戳等；
- 目录（文件夹）其实就是“文件名 → inode 编号”的一个表。

几个概念：

- **inode 号（号码牌）**：每个 inode 有唯一编号；
- 同一个 inode 可以被多个“文件名”指向，这就是“硬链接”。

查看 inode：

```bash
ls -i file.txt
# 输出类似：123456 file.txt
# 其中 123456 就是 inode 号
```

### 4.2 硬链接（hard link）

硬链接可以理解为：
> 再给同一个“文件的 inode”起一个新名字。

创建硬链接：

```bash
ln existing newname
```

特点：
- `existing` 和 `newname` 的 inode 号相同；
- 删除其中任意一个“名字”，另一个仍可用，只有“指向该 inode 的名字数量”为 0 时，系统才会回收数据块；
- 硬链接**不能跨文件系统**（不能跨不同的分区、不同挂载盘）；
- 对目录通常禁止创建硬链接（避免形成环形结构）。

查看硬链接数：

```bash
ls -l file
-rw-r--r-- 2 alice staff  ... file
# 权限后面的那个“2”就是硬链接计数
```

场景举例：
- `cp -al` 用硬链接方式“复制”大目录，可以快速创建多个视图而不占用额外空间（但有风险，需要理解共享同一数据）。

### 4.3 软链接（符号链接，symbolic link / symlink）

软链接更像 Windows 里的“快捷方式”：

```bash
ln -s target linkname
```

特点：
- 软链接本身是一个小文件，里面存的是“目标路径”的字符串；
- 可以跨文件系统、可以指向目录；
- `ls -l` 输出中，软链接会显示箭头：`linkname -> target`；
- 如果目标被删除，软链接就“悬空”（broken link）。

例子：

```bash
ln -s /var/log logs
ls -l
# logs -> /var/log

cd logs   # 实际进入 /var/log
```

对比硬链接：

| 特性           | 硬链接 (hard link)                       | 软链接 (symbolic link)              |
|----------------|-------------------------------------------|-------------------------------------|
| 指向对象       | 直接指向 inode                            | 指向路径（字符串）                  |
| inode 是否相同 | 相同                                     | 不同                                |
| 是否可跨文件系统 | 否                                      | 是                                  |
| 可指向目录     | 一般不允许（root 用户强行也很少用）      | 可以                                |
| 目标删除影响   | 只要还有一个硬链接在，数据就不丢         | 目标被删则软链接失效（变“死链”）    |

### 4.4 “删除文件”的真实含义

当你运行：

```bash
rm file.txt
```

其实做的事情是：

1. 从所在目录中，删掉 `file.txt -> inodeX` 这条“名字 → inode”的映射；
2. inodeX 的“链接计数 -1”；
3. 如果链接计数变成 0，且没有进程打开这个 inode，对应的数据块就被标记可重用。

所以会出现这样的现象：

- 日志文件正在被某个服务写入，你用 `rm` 删掉它，但磁盘空间没有立刻释放；
- 因为进程仍然打开着那个 inode，只是目录名不在了；
- 通常要重启服务或让它重新打开日志文件，空间才真正释放。

这也是为什么排查磁盘满时，可以用工具（如 `lsof | grep deleted`）查出“被删除但仍占空间的打开文件”。

---

## 小结

这一节你需要掌握的几个关键点：

1. **目录结构直觉**：知道 `/`、`/home`、`/etc`、`/var`、`/usr` 大致干什么。
2. **熟练基本命令**：`ls / cd / mkdir / rm / cp / mv / find`，可以配合 `man` 自己试。
3. **文本操作组合拳**：`cat / less / head / tail / grep / wc` 组合使用，尤其是配合管道时的威力。
4. **理解 inode & 链接**：知道“文件名 ≠ 文件本体”，“硬链接是同一个 inode 的多个名字”，“软链接是指向路径的小文件”。

掌握这些之后，你在 Linux 文件系统下走路就基本不迷路了，后面讲权限（rwx）、用户/用户组、挂载磁盘等，会更容易