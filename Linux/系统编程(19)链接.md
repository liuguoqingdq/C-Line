# Linux 系统编程：链接与删除（hard link / symlink / unlink / remove）

这份讲解聚焦 **Linux/Unix 文件系统语义**：什么是链接、系统调用怎么用、返回值/参数含义、常见错误、以及“删除文件到底发生了什么”。

---

## 1. 基础概念：路径名、目录项、inode、链接计数

在典型 Unix 文件系统里：

- **路径名（pathname）**：例如 `/home/chen/a.txt`，只是“从某个目录开始查找”的字符串。
- **目录项（directory entry, dentry）**：目录里的一条记录：`文件名 -> inode号`。
- **inode**：文件的“真实身份”（权限、属主、大小、时间戳、数据块位置等）。
- **链接计数（st_nlink）**：有多少个目录项指向同一个 inode（**硬链接数**）。

因此：

- **硬链接（hard link）**：新增一个“目录项”，让另一个文件名也指向同一个 inode。
- **符号链接（symbolic link / symlink）**：创建一个“特殊文件”（它有自己的 inode），内容是“目标路径字符串”。访问 symlink 时，内核会把它解析成目标路径再去找。

你可以把硬链接理解为：**同一个人有两个身份证名字**；而符号链接理解为：**一张写着“去找某人”的纸条**。

---

## 2. 硬链接：`link` / `linkat`

### 2.1 `link` 系统调用做什么

`link` 用于创建 **硬链接**：让 `newpath` 成为 `oldpath` 指向的同一文件（同一 inode）的另一个名字。

#### 函数签名

```c
#include <unistd.h>

int link(const char *oldpath, const char *newpath);
```

#### 参数含义

- `oldpath`：已存在的路径（目标文件）。
- `newpath`：要创建的新路径（新的名字）。

#### 返回值

- 成功：返回 `0`
- 失败：返回 `-1`，并设置 `errno`

#### 最关键的语义点

- **不会复制文件内容**：两个名字共享同一份数据。
- **链接计数 +1**：`stat(oldpath).st_nlink` 会增加。
- **不能跨文件系统**：`oldpath` 和 `newpath` 必须在同一个挂载点/文件系统上，否则 `EXDEV`。
- **通常不能给目录创建硬链接**（为避免目录环路），非特权用户会得到 `EPERM`。

#### 常见 errno

- `EEXIST`：`newpath` 已存在
- `ENOENT`：`oldpath` 不存在，或 `newpath` 的父目录不存在
- `EXDEV`：跨文件系统硬链接
- `EPERM`：尝试对目录做硬链接（或文件系统策略禁止）
- `EACCES` / `EPERM`：权限不足

### 2.2 为什么要用 `link`

典型用途：

1. **给同一份数据多个名字**（如版本别名、多个路径引用同一文件）。
2. **原子性“备份/快照”小技巧**：给重要文件加一条硬链接，作为“引用计数保护”，防止误删。只要任一硬链接存在，数据就不会真正释放。
3. **某些应用的原子更新模式**：生成新文件后 `rename` 替换，必要时配合硬链接保留旧版本（注意目录组织）。

### 2.3 `linkat`（更现代/更安全）

如果你在系统编程里经常使用 `openat` 风格（目录 fd + 相对路径）来避免 TOCTOU 问题，那么你会更常用：

```c
#include <unistd.h>

int linkat(int olddirfd, const char *oldpath,
           int newdirfd, const char *newpath,
           int flags);
```

- `olddirfd/newdirfd`：用来解释相对路径的“目录 fd”，也可以传 `AT_FDCWD` 表示用当前工作目录。
- `flags`：常见是 `AT_SYMLINK_FOLLOW`（决定 oldpath 若是 symlink 是否跟随）。

---

## 3. 符号链接：`symlink` / `symlinkat`

### 3.1 `symlink` 系统调用做什么

`symlink` 创建一个 **符号链接文件**，该文件内容是 `target` 字符串。

#### 函数签名

```c
#include <unistd.h>

int symlink(const char *target, const char *linkpath);
```

#### 参数含义

- `target`：目标路径字符串（可以是相对路径或绝对路径；也可以暂时不存在）
- `linkpath`：要创建的符号链接的路径名

#### 返回值

- 成功：返回 `0`
- 失败：返回 `-1` 并设置 `errno`

### 3.2 最关键的语义点

- symlink **有自己独立的 inode**：它不是目标文件本体。
- symlink **可以跨文件系统**：因为它只是保存路径字符串。
- symlink 的 `target` **可以不存在**：这叫“悬空链接（dangling symlink）”，创建时不要求目标存在。
- symlink 的权限位通常不影响访问，访问控制发生在“解析后的目标文件”上（但系统调用层面仍有一些细节，比如删除 symlink 看父目录权限）。

### 3.3 `stat` vs `lstat`

当路径是 symlink 时：

- `stat("link")`：返回 **目标文件**的信息（跟随链接）
- `lstat("link")`：返回 **链接本身**的信息（不跟随）

这是系统编程里非常常见的坑。

### 3.4 `symlinkat`

```c
#include <unistd.h>

int symlinkat(const char *target, int newdirfd, const char *linkpath);
```

同样是“目录 fd + 相对路径”的安全接口。

### 3.5 为什么要用 symlink

- **为目录建立别名**（硬链接通常不能指向目录）
- **跨文件系统引用**（硬链接不行）
- **构建“指针”语义**：例如 `current -> v3.2.1/`，升级只需改一次链接

---

## 4. 解除链接：`unlink` / `unlinkat`

### 4.1 `unlink` 系统调用做什么

`unlink` 的本质是：

> **从目录中删除一个名字（目录项）**。

它不等于“立即把数据从磁盘抹掉”。是否释放数据取决于：

- 是否还有其他硬链接（链接计数是否变为 0）
- 是否还有进程打开着该文件（引用计数/打开计数）

#### 函数签名

```c
#include <unistd.h>

int unlink(const char *pathname);
```

#### 参数含义

- `pathname`：要解除链接（删除目录项）的路径

#### 返回值

- 成功：`0`
- 失败：`-1` 并设置 `errno`

### 4.2 “删除中的文件”还能读写吗？（非常重要）

如果一个文件：

1. 被某进程 `open()` 得到 fd
2. 之后别人对该路径 `unlink()`

那么：

- 该路径名消失（`ls` 看不到了）
- **但打开着的 fd 仍然可用**：进程仍可读写
- 真正释放数据发生在：**最后一个硬链接消失 + 最后一个打开引用关闭**

这就是为什么临时文件经常这样写：

- 创建后立刻 `unlink()`，只用 fd 访问，进程结束自动回收（安全/避免泄露）。

### 4.3 `unlink` 不能删目录

- 删除目录要用：`rmdir()`（或 `unlinkat(..., AT_REMOVEDIR)`）
- 对目录调用 `unlink` 通常会 `EISDIR` 或 `EPERM`（依实现/内核策略）。

### 4.4 常见 errno

- `ENOENT`：路径不存在
- `EACCES` / `EPERM`：权限不足（通常是对父目录无写权限，或开启了 sticky bit 等策略）
- `EISDIR`：是目录
- `ENOTEMPTY`：目录不为空（若用 `unlinkat + AT_REMOVEDIR` 或 `rmdir` 时）

### 4.5 `unlinkat`

```c
#include <unistd.h>

int unlinkat(int dirfd, const char *pathname, int flags);
```

- `dirfd`：解释相对路径的目录 fd（或 `AT_FDCWD`）
- `flags`：
  - `0`：删除普通文件/符号链接（解除目录项）
  - `AT_REMOVEDIR`：删除目录（等价于 `rmdir` 的语义）

---

## 5. `remove`：它是“系统调用”吗？

### 5.1 `remove` 的本质

`remove` 不是内核系统调用名称，而是 **C 标准库函数**（ISO C）。在 Linux 上通常由 libc 实现，内部会根据路径类型选择调用：

- 如果是普通文件/符号链接：走 `unlink()`
- 如果是目录：走 `rmdir()`

#### 函数签名

```c
#include <stdio.h>

int remove(const char *pathname);
```

#### 返回值

- 成功：`0`
- 失败：非 `0`（通常也是 `-1`），并设置 `errno`

### 5.2 使用建议

- **写系统级代码**（需要精确控制语义、目录 fd、安全属性）时：优先 `unlink/unlinkat/rmdir`。
- **写普通应用**（只想“删掉这个路径，不管是文件还是目录”）时：`remove` 简洁。

---

## 6. 用命令直观看差异：`ls -li` 与 `readlink`

### 6.1 硬链接演示（观察 inode 相同）

```bash
echo hello > a.txt
ln a.txt b.txt          # 硬链接
ls -li a.txt b.txt      # inode 号相同，链接计数 st_nlink=2
rm a.txt                # 等价于 unlink("a.txt")
cat b.txt               # 仍然能看到内容
```

### 6.2 符号链接演示（inode 不同，link 内容是路径）

```bash
echo hello > a.txt
ln -s a.txt s.txt       # 符号链接
ls -li a.txt s.txt      # inode 不同
readlink s.txt          # 输出 a.txt
rm a.txt
cat s.txt               # 失败：悬空链接
```

---

## 7. 系统编程示例（C）：link / symlink / unlink / remove

> 下面示例尽量贴近“你在写系统程序时会遇到的真实点”：检查错误码、区分语义。

```c
#include <stdio.h>
#include <unistd.h>
#include <errno.h>
#include <string.h>

static void die(const char *msg) {
    fprintf(stderr, "%s: %s\n", msg, strerror(errno));
}

int main(void) {
    // 1) 创建硬链接
    if (link("a.txt", "b.txt") == -1) {
        die("link a.txt -> b.txt failed");
    }

    // 2) 创建符号链接（target 可不存在）
    if (symlink("a.txt", "s.txt") == -1) {
        die("symlink a.txt -> s.txt failed");
    }

    // 3) 解除链接（删除目录项）
    if (unlink("b.txt") == -1) {
        die("unlink b.txt failed");
    }

    // 4) remove：文件/目录都能删（库函数）
    if (remove("s.txt") != 0) {
        die("remove s.txt failed");
    }

    return 0;
}
```

编译：

```bash
gcc -Wall -Wextra -O2 demo.c -o demo
```

---

## 8. 常见坑与工程建议

### 8.1 “删不掉文件”通常不是文件权限，而是父目录权限

- 删除一个名字，本质是修改“父目录”的目录项。
- 所以需要对 **父目录** 有写权限 + 执行权限（进入目录）。

### 8.2 sticky bit（`/tmp` 常见）

在带 sticky bit 的目录（如 `/tmp`）中，即使你有目录写权限，也只能删除：

- 自己拥有的文件
- 或目录拥有者的文件

否则 `unlink` 可能 `EPERM`。

### 8.3 symlink 安全：避免“跟随链接”导致被劫持

如果你在特权程序里打开/删除用户可控路径，symlink 可用来做攻击。

常见对策：

- 用 `openat(dirfd, name, O_NOFOLLOW | ...)`
- 或先 `lstat` 确认不是 symlink
- 尽量使用“目录 fd + 相对路径”的 *at 系列接口（`linkat/unlinkat/symlinkat/openat`）

### 8.4 `rename` 与删除/替换

- `rename(old, new)` 在同一文件系统内是原子替换（非常常用）。
- 但它和硬链接/解除链接是不同语义：
  - `unlink`：删除一个名字
  - `rename`：把一个名字移动/替换为另一个名字

---

## 9. 一句话总结（帮你在面试/笔试里抓重点）

- **硬链接**：同 inode 多名字，`link()` 创建，不能跨文件系统。
- **符号链接**：保存路径字符串的特殊文件，`symlink()` 创建，可跨文件系统，可悬空。
- **unlink**：删除目录项，文件数据是否释放取决于链接计数与打开引用。
- **remove**：C 库函数，内部选择 `unlink` 或 `rmdir`。

---

如果你希望更“系统编程味道”一点（例如：再加上 `stat/lstat/readlink`、`openat` 风格的安全删除、以及一个“临时文件创建后立即 unlink”的经典模式），我可以在这份文档后面补一个更完整的工程示例。

