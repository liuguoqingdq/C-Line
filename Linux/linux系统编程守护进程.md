# 5.8.1 守护进程是什么（详细讲解）

你可以把“守护进程（daemon）”理解为：
> **不依赖用户登录会话/终端、在后台长期运行、以服务形式对外提供能力的进程。**

它和“在 shell 里加 `&` 放到后台跑”的进程看起来都在后台，但**本质差别很大**：守护进程的生命与管理方式，应该**独立于任何终端/交互式用户**。

---

## 1. 守护进程的典型特征（逐条解释“为什么需要”）

### 1) 后台长期运行（long-running）
- 守护进程不是“跑完就结束”的批处理程序，而是常驻：
  - 持续监听端口（例如 sshd 监听 22）
  - 定时触发任务（cron）
  - 监控系统状态（各种 agent）

**为什么要长期运行？**
- 外界请求随时可能到达。
- 系统功能需要持续可用，不应依赖某个用户是否登录。

---

### 2) 脱离终端（no controlling terminal）

这是守护进程和“后台 job”最关键的分水岭。

#### 什么是“控制终端”（controlling terminal）？
- 当你登录并打开一个终端（tty/pts），shell 会建立一个会话（session）。
- 该会话通常绑定一个控制终端：
  - 终端输入（键盘）会送到会话的“前台进程组”
  - Ctrl+C/Ctrl+Z 这类按键会产生信号（SIGINT/SIGTSTP）发给前台进程组

#### 终端关闭会发生什么？
- 当用户退出登录/关闭终端时，内核会对该会话/相关进程投递 **SIGHUP（挂断）**。
- 很多程序默认收到 SIGHUP 会终止。

**守护进程必须不依赖控制终端**，否则：
- 你退出登录，它也可能被“顺带杀掉”；
- 或者输出写到已断开的终端导致错误；
- 甚至后台进程读终端会触发 SIGTTIN 被暂停。

所以守护进程通常要做到：
- **不在任何控制终端下运行**（常用 `setsid()` 创建新会话并脱离）
- 标准输入/输出/错误不指向终端

---

### 3) 生命周期由“系统/管理器”而不是用户决定

守护进程的启动、停止、重启、日志、资源限制，通常由：
- 传统：init 脚本 / rc
- 现代：systemd

这意味着守护进程要能：
- 接受停止信号（通常 SIGTERM）并优雅退出
- 支持 reload（常见用 SIGHUP 或 SIGUSR1 来触发重新加载配置）
- 发生故障时可被监督者重启（supervision）

---

### 4) 自己管理日志/配置/权限

守护进程没有终端可用，因此必须解决“可观测性与可控性”。

#### 日志（logging）
- 不能依赖 `printf` 打到终端。
- 常见做法：
  - 写到日志文件（注意权限、轮转 logrotate）
  - 走 syslog（`syslog()`）
  - 交给 systemd journald（stdout/stderr 被接管也可以）

#### 配置（configuration）
- 配置文件（/etc/xxx/xxx.conf）
- 支持 reload：不停机更新配置

#### 权限（privilege）
- 能不以 root 跑就不要以 root 跑。
- 必须用 root 的场景（绑定 <1024 端口、操作特权资源）：
  - 启动时 root → 完成必要操作后 `setuid/setgid` 降权

---

## 2. 守护进程 vs “后台进程（&）”

### `./a.out &` 只是 job control，不等于 daemon
- `&` 只是让 shell 不阻塞；进程通常仍在原会话里，往往仍绑定控制终端。
- 终端关闭时：这个后台进程仍可能收到 SIGHUP 而退出。

### `nohup ./a.out &` 更接近但仍不完整
- `nohup` 会让进程忽略 SIGHUP，并把输出重定向到 `nohup.out`。
- 但它未必处理：工作目录、umask、fd、守护化规范、监督管理等。

真正的守护进程：
- 通常要创建新会话（`setsid`），并处理好 fd、工作目录、权限等。
- 更重要：它应该是“系统服务”，而不是“用户临时跑的后台任务”。

---

## 3. 守护进程常见例子（你提到的这些为什么是 daemon）

### sshd
- 常驻监听 22 端口，随时接受连接。
- 每来一个连接再派生/线程化处理。
- 不能依赖某个用户终端存在。

### cron
- 常驻，按计划触发任务。
- 需要系统级持续运行。

### systemd 管理的各种 service
- systemd 负责启动/停止、自动重启、资源限制、日志收集。
- 许多服务在 systemd 下甚至不需要自己 double-fork（由 systemd 管）。

---

## 4. “守护进程”在操作系统层面长什么样（你如何观察它）

### 典型观察点
- `ps -ef` / `ps -o pid,ppid,sid,pgid,tty,stat,cmd -p <pid>`
  - **TTY 通常为 ?**（表示没有控制终端）
  - SID/PGID 往往等于某个守护进程的 pid（取决于是否为会话首领/进程组组长）

### /proc
- `/proc/<pid>/fd/`：它打开了哪些 fd（0/1/2 是否指向终端）
- `/proc/<pid>/status`：可看到 TTY、信号掩码等

---

## 5. 守护进程需要具备的“工程能力清单”（非常实用）

你写一个真正可上线的守护进程，至少要考虑：

1) **启动**
- 前台/后台模式切换（便于调试：前台打印；生产：后台运行）
- systemd 方式启动（更现代）

2) **停止**
- 收到 SIGTERM：优雅退出（停止接入、清理资源、flush）
- 超时机制（如果收不到响应，管理员可能 SIGKILL）

3) **配置变更**
- SIGHUP / SIGUSR1：reload 配置

4) **日志**
- 日志级别、格式
- 轮转或交给日志系统

5) **资源与健壮性**
- 限制打开文件数（ulimit/systemd LimitNOFILE）
- 内存泄漏监控
- 子进程回收（SIGCHLD + waitpid，避免僵尸）

6) **安全**
- 最小权限原则（能降权就降权）
- 输入验证、路径安全

---

## 6. 为后续 5.8.2 做铺垫：为什么“守护化”需要特定步骤

你在 5.8.2 会看到经典 daemonize：
- `fork → setsid → fork → chdir/umask → 重定向 fd → 信号处理`

这些步骤并不是“仪式感”，每一步都对应上面某个目标：
- 脱离控制终端（防 SIGHUP / 防终端读写问题）
- 确保不会重新获得控制终端
- 避免占用挂载点（工作目录）
- 权限可控（umask）
- 可观测与可控（日志/信号/退出）

---

## 7. 小结（一句话背诵版）

守护进程 = **后台常驻服务进程**：
- **不依赖终端与用户会话**
- **长期运行、提供服务**
- **自己处理日志、配置、信号与生命周期**
- 在现代 Linux 上通常由 **systemd** 监督管理

