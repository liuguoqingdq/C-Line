# Linux 目录相关 API 详解：getcwd/chdir/fchdir/mkdir/rmdir/opendir/dirfd/readdir/dirent/closedir

下面把你点名的这些目录相关函数按“**作用 → 原型 → 参数 → 返回值/errno → 典型用法/坑点**”完整讲清楚，并给可直接抄的例子。

---

## 1) `getcwd`：获取当前工作目录

### 1.1 原型
```c
#include <unistd.h>

char *getcwd(char *buf, size_t size);
```

### 1.2 作用
获取当前进程的 **当前工作目录（CWD, Current Working Directory）** 的绝对路径。
- CWD 会影响**所有相对路径**的解析（如 `open("a.txt")`）。

### 1.3 参数含义
- `buf`：接收路径字符串的缓冲区。
- `size`：缓冲区大小（字节数）。

常见两种用法：
1) **自己提供缓冲区**：`buf != NULL` 且 `size > 0`
2) **让库帮你分配**（glibc 常见行为）：`buf == NULL` 且 `size == 0`
   - 成功时返回一个 `malloc` 出来的指针，你需要 `free()`。
   - 这个行为是 glibc 的扩展/实现细节，跨 libc 时要谨慎。

### 1.4 返回值
- 成功：返回指向路径字符串的指针（通常就是 `buf`，或是 glibc 分配的新指针）。
- 失败：返回 `NULL`，并设置 `errno`。

### 1.5 常见 errno
- `ERANGE`：缓冲区太小（最常见）。
- `EACCES`：某级目录无权限（路径无法解析出来）。

### 1.6 示例
```c
char buf[4096];
if (!getcwd(buf, sizeof(buf))) {
    perror("getcwd");
} else {
    printf("cwd=%s\n", buf);
}
```

---

## 2) `chdir`：修改当前工作目录

### 2.1 原型
```c
#include <unistd.h>

int chdir(const char *path);
```

### 2.2 作用
把当前进程的 CWD 改为 `path` 指向的目录。

### 2.3 参数
- `path`：要切换到的目录路径（绝对或相对均可）。

### 2.4 返回值
- 成功：0
- 失败：-1，并设置 `errno`

### 2.5 常见 errno
- `ENOENT`：目录不存在
- `ENOTDIR`：path 不是目录
- `EACCES`：缺少权限（注意：进入目录需要 **x** 权限）

### 2.6 重要坑点（系统编程很关键）
- `chdir` 修改的是**进程的全局状态**（对该进程内后续所有相对路径都生效）。
- 多线程程序里随意 `chdir` 很危险：别的线程也会受影响，导致“相对路径解析错目录”。

> 工程建议：多线程/安全场景尽量用 `openat/fstatat/mkdirat` 这种 *at 系列（基于目录 fd），少用 `chdir`。

---

## 3) `fchdir`：用目录 fd 修改当前工作目录

### 3.1 原型
```c
#include <unistd.h>

int fchdir(int fd);
```

### 3.2 作用
把 CWD 切换到 **文件描述符 `fd` 所指向的目录**。

### 3.3 参数
- `fd`：必须是一个打开的目录 fd（通常通过 `open(path, O_RDONLY|O_DIRECTORY)` 获得）。

### 3.4 返回值
- 成功：0
- 失败：-1，设置 `errno`

### 3.5 常见 errno
- `EBADF`：fd 无效
- `ENOTDIR`：fd 指向的不是目录
- `EACCES`：权限不足（同样需要目录的 x 权限）

### 3.6 典型用法
常见用途：
- 先保存“原 CWD”的目录 fd，做完工作后再切回去（避免路径字符串变动/被删除）。

示例：
```c
int old = open(".", O_RDONLY | O_DIRECTORY);
if (old == -1) perror("open .");

// chdir 到别处
if (chdir("/tmp") == -1) perror("chdir");

// 切回原目录
if (fchdir(old) == -1) perror("fchdir");
close(old);
```

---

## 4) `mkdir`：创建目录

### 4.1 原型
```c
#include <sys/stat.h>

int mkdir(const char *path, mode_t mode);
```

### 4.2 作用
创建一个新目录：
- 在父目录里新增一个目录项
- 为新目录分配 inode

### 4.3 参数
- `path`：新目录路径
- `mode`：权限位（八进制常用 `0755`、`0700` 等）

**注意：umask 会影响最终权限**
- 最终权限通常是：`mode & ~umask` （异或运算）
- 例如 umask=022 时，`mkdir(path, 0777)` 实际变成 0755。

### 4.4 返回值
- 成功：0
- 失败：-1，设置 `errno`

### 4.5 常见 errno
- `EEXIST`：已存在同名文件/目录
- `ENOENT`：父目录不存在
- `ENOTDIR`：路径中某段不是目录
- `EACCES`：父目录没有写/执行权限（通常需要对父目录有 `wx`）
- `ENOSPC`：空间/ inode 不足

---

## 5) `rmdir`：删除空目录

### 5.1 原型
```c
#include <unistd.h>

int rmdir(const char *path);
```

### 5.2 作用
删除一个目录**本身的目录项**，并释放目录资源。

### 5.3 关键限制
- 目录必须是**空目录**（除 `.`、`..` 以外没有其他条目）。

### 5.4 返回值
- 成功：0
- 失败：-1，设置 `errno`

### 5.5 常见 errno
- `ENOTEMPTY` / `EEXIST`：目录非空
- `ENOTDIR`：path 不是目录
- `ENOENT`：不存在
- `EACCES`：权限不足（对父目录通常需要 `wx`）

---

## 6) `opendir`：打开目录流（DIR*)

### 6.1 原型
```c
#include <dirent.h>

DIR *opendir(const char *name);
```

### 6.2 作用
把一个目录打开成“目录流”对象 `DIR*`，用于 `readdir()` 逐条读取目录项。

### 6.3 参数
- `name`：目录路径

### 6.4 返回值
- 成功：返回 `DIR*`
- 失败：返回 `NULL`，设置 `errno`

### 6.5 常见 errno
- `ENOENT`：目录不存在
- `ENOTDIR`：不是目录
- `EACCES`：无权限（要列目录通常需要 `r`，要穿越通常还需要 `x`）

### 6.6 重要说明
- `opendir/readdir/closedir` 是 libc API，不是你直接写 syscall；但它们内部通常用 `open` + `getdents64` 等实现。

---

## 7) `dirfd`：从 DIR* 取出底层 fd

### 7.1 原型
```c
#include <dirent.h>

int dirfd(DIR *dirp);
```

### 7.2 作用
返回与 `DIR*` 目录流关联的**底层文件描述符**。

### 7.3 参数
- `dirp`：opendir 返回的目录流指针

### 7.4 返回值
- 成功：返回一个非负 fd
- 失败：返回 -1（并可能设置 errno，视实现）

### 7.5 重要坑点
- **不要手动 close(dirfd(dp))**：
  - `DIR*` 的 fd 归目录流管理。
  - 正确关闭方式是 `closedir(dp)`。
  - 你手动 close 了，`readdir/closedir` 之后可能崩或返回 EBADF。

### 7.6 常见用途
- 结合 `fstatat/openat/unlinkat` 做“基于目录 fd 的安全操作”。
# `openat` / `fstatat` 怎么用（推荐写法）

## 1）`openat`：相对“某个目录 fd”打开文件/子目录

### 原型

```C
#include <fcntl.h>

int openat(int dirfd, const char *pathname, int flags, ... /* mode_t mode */);
```

### 关键语义

- `dirfd`：一个**目录**的文件描述符（比如通过 `open("/etc", O_RDONLY|O_DIRECTORY)` 得到）
    
- `pathname`：
    
    - 如果是**绝对路径**（以 `/` 开头），`dirfd` 被忽略
        
    - 如果是**相对路径**，就以 `dirfd` 指向的目录作为“基准目录”来解析
        
- `flags`：和 `open()` 一样（可加 `O_DIRECTORY` 表示必须打开目录）
    

### 最小例子

```C
int dfd = open("/etc", O_RDONLY | O_DIRECTORY);
int fd  = openat(dfd, "hosts", O_RDONLY);              // 等价于 open("/etc/hosts", O_RDONLY)
int sfd = openat(dfd, "ssh", O_RDONLY | O_DIRECTORY);  // 打开 /etc/ssh 目录
```

---

## 2）`fstatat`（也叫 `newfstatat`）：相对目录 fd 做 stat

### 原型

```C
#include <sys/stat.h>

int fstatat(int dirfd, const char *pathname, struct stat *st, int flags);
```

### 关键语义

- `dirfd`：基准目录 fd（同 `openat`）
    
- `pathname`：
    
    - 绝对路径：忽略 `dirfd`
        
    - 相对路径：相对 `dirfd`
        
- `flags` 常用：
    
    - `0`：跟随符号链接（类似 `stat`）
        
    - `AT_SYMLINK_NOFOLLOW`：不跟随符号链接（类似 `lstat`）
        

### 等价关系（记住这个就够了）

- `fstatat(AT_FDCWD, path, &st, 0)` ≈ `stat(path, &st)`
    
- `fstatat(AT_FDCWD, path, &st, AT_SYMLINK_NOFOLLOW)` ≈ `lstat(path, &st)`
---

## 8) `readdir`：读取目录项

### 8.1 原型
```c
#include <dirent.h>

struct dirent *readdir(DIR *dirp);
```

### 8.2 作用
从目录流中读取**下一条目录项**。

### 8.3 参数
- `dirp`：目录流 `DIR*`

### 8.4 返回值（非常重要，考试/面试高频）
- 成功：返回指向 `struct dirent` 的指针（下一条目录项）
- 到末尾：返回 `NULL`（EOF）
- 出错：也返回 `NULL`

**如何区分“末尾”还是“出错”？**
- 在调用 `readdir` 前把 `errno = 0;`
- 若返回 NULL：
  - `errno == 0` → 正常结束
  - `errno != 0` → 出错

### 8.5 线程/内存语义（坑点）
- `readdir` 返回的 `struct dirent*` 指向**内部静态缓冲**，下一次 `readdir` 可能覆盖它。
- 如果你要保存条目名字，必须 `strdup(e->d_name)` 或拷贝到自己的缓冲区。

---

## 9) `struct dirent`：目录项结构体（字段解释 + 注意事项）

### 9.1 常见定义（实现可能略有差别）
```c
#include <dirent.h>

struct dirent {
    ino_t          d_ino;     // inode 号（有时可能为 0 或不可靠，取决于 FS）
    off_t          d_off;     // 下一个 dirent 的偏移（实现相关）
    unsigned short d_reclen;  // 本条记录长度（字节）
    unsigned char  d_type;    // 条目类型（可能为 DT_UNKNOWN）
    char           d_name[256]; // 文件名（以 '\0' 结尾，长度上限实现相关）
};
```

### 9.2 `d_name`
- 最重要字段：目录项名字。
- 会返回 `"."` 和 `".."`，遍历时通常需要跳过。

### 9.3 `d_type`（非常关键的坑点）
- `d_type` 可能是：
  - `DT_REG` 普通文件
  - `DT_DIR` 目录
  - `DT_LNK` 符号链接
  - ……
  - `DT_UNKNOWN` 不知道（很多文件系统/场景会出现）

**结论：不要完全依赖 d_type 判断类型**。
- 如果 `d_type == DT_UNKNOWN`，正确做法是配合 `fstatat`/`stat` 再确认：
  - `fstatat(dirfd(dp), e->d_name, &st, AT_SYMLINK_NOFOLLOW)`

---

## 10) `closedir`：关闭目录流

### 10.1 原型
```c
#include <dirent.h>

int closedir(DIR *dirp);
```

### 10.2 作用
- 关闭 `DIR*` 目录流
- **同时关闭其内部持有的 fd**
- 释放相关资源

### 10.3 返回值
- 成功：0
- 失败：-1，设置 `errno`

### 10.4 坑点
- 因为 `closedir` 会 close 底层 fd，所以你不要对 `dirfd(dirp)` 再 close。

---


## 11) 综合示例：实现一个最小版 `ls`

```c
#include <dirent.h>
#include <errno.h>
#include <stdio.h>
#include <string.h>

int main(int argc, char **argv) {
    const char *path = (argc > 1) ? argv[1] : ".";

    DIR *dp = opendir(path);
    if (!dp) {
        perror("opendir");
        return 1;
    }

    for (;;) {
        errno = 0;
        struct dirent *e = readdir(dp);
        if (!e) {
            if (errno) perror("readdir");
            break;
        }

        if (strcmp(e->d_name, ".") == 0 || strcmp(e->d_name, "..") == 0)
            continue;

        printf("%s\n", e->d_name);
    }

    if (closedir(dp) == -1) {
        perror("closedir");
        return 1;
    }

    return 0;
}
```

---

## 12) 你需要牢牢记住的“考试级”要点

1) `getcwd` 可能 `ERANGE`；`chdir`/`fchdir` 改变 CWD，会影响所有相对路径。
2) 多线程程序里随意 `chdir` 容易出事故；能用 *at 系列就别用全局 CWD。
3) `mkdir` 的 `mode` 会被 `umask` 影响。
4) `rmdir` 只能删除空目录。
5) `readdir` 返回 NULL 既可能 EOF 也可能 error：靠 `errno` 区分。
6) `readdir` 返回的 `dirent*` 可能被下一次调用覆盖；要保存名字必须拷贝。
7) `d_type` 可能是 `DT_UNKNOWN`，别完全依赖；需要时用 `fstatat/stat` 确认。
8) `dirfd` 只是取底层 fd，fd 的生命周期归 `DIR*` 管，正确关闭是 `closedir`。

---

如果你希望我再把它们串成一个“递归遍历目录”的标准模板（安全版：不跟随符号链接、用 `dirfd + fstatat`），我也可以继续写一份。

