**带外通信**”一般有两种常见含义，得看你是在**系统/网络编程**语境里，还是在**运维/安全**语境里说的。

## 1）概念：带外 vs 带内

- **带内通信（in-band）**：控制信息和数据走**同一条通道/同一个连接/同一协议数据流**。  
    例：HTTP 请求里既传业务数据，也传控制信息（Header/Body）。
    
- **带外通信（out-of-band, OOB）**：控制信息走**另一条独立通道**，不占用（或不依赖）主数据通道。  
    例：登录网页时主通道是 HTTPS，但验证码通过短信/邮箱/Authenticator 发，这就是典型 OOB。
    

---

## 2）Linux 系统编程里最经典的“带外”：TCP 紧急数据（Urgent / OOB）

在 socket 编程中，“带外数据”通常特指 **TCP 的 urgent 机制**（历史上 Telnet 用来发送中断/控制信号）。

### 2.1 关键点（务必知道）

- TCP 的 OOB **不是“独立的第二条数据流”**，它仍然在同一个 TCP 连接里，只是标记了“紧急指针（urgent pointer）”，接收端可以把它当作“特殊事件”来处理。
    
- 实际上很多系统把它当成**“紧急位置”**而不是一段真正独立的消息；并且**语义在不同实现/应用里很坑**。
    
- 在 Linux 上常见行为是：OOB 通知更多像“有紧急数据/紧急指针到了”，应用通常只拿到 **1 字节** OOB 数据（历史兼容性原因）。
    

### 2.2 发送/接收接口

- 发送：`send(fd, buf, len, MSG_OOB)`
    
- 接收：`recv(fd, buf, len, MSG_OOB)`
    

```C
ssize_t send(int sockfd, const void *buf, size_t len, int flags);
ssize_t recv(int sockfd, void *buf, size_t len, int flags);
```

返回值：

- `>=0`：实际发送/接收字节数
    
- `-1`：失败并设置 `errno`（如 `EWOULDBLOCK/EAGAIN`、`EINVAL` 等）
    

### 2.3 怎么“等到”OOB 事件？

- `select()`：把 fd 放到 **exceptfds**（异常集合）里
    
- `poll()`：关注 `POLLPRI`
    
- `epoll()`：关注 `EPOLLPRI`（优先级数据/紧急数据）
    

> 直觉：OOB 更像“优先级事件/异常事件”，所以出现在 exceptfds / PRI 里。

---
## ioctl函数
## 1) `ioctl` 是什么？什么时候用？

- **`read/write`**：传输数据（字节流/块数据）
    
- **`ioctl`**：传输“控制/配置/查询”命令  
    典型：设置串口波特率、查询终端窗口大小、网卡 up/down、查询块设备大小、文件系统特殊功能（reflink 克隆等）。
    

很多设备/子系统都把“非通用操作”放在 ioctl 里，所以它是一个 **“万能扩展口”**。

---

## 2) 函数签名、参数、返回值

### 2.1 用户态调用接口（libc 暴露）

```C
#include <sys/ioctl.h>

int ioctl(int fd, unsigned long request, ...);
```

- `fd`：你要控制的对象（设备文件、socket、tty、普通文件等）的文件描述符
    
- `request`：命令码（决定你要干什么 + 数据方向/大小等信息）
    
- `...`：可变参数，通常传 **指针**（让内核读/写一块结构体），也可能传整数
    

### 2.2 返回值

- **成功**：返回值**依 request 而定**
    
    - 很多 ioctl 成功返回 `0`
        
    - 也有很多会返回一个 **非负值**（比如返回数量/状态）
        
- **失败**：返回 `-1`，并设置 `errno`
    

常见 `errno`：

- `ENOTTY`：这个 fd 不支持该 ioctl（名字很怪，历史原因，“Not a typewriter”）
    
- `EINVAL`：参数不合法/命令不支持
    
- `EFAULT`：用户态指针无效（传参错/越界）
    
- `EPERM/EACCES`：权限不足
    
- `EBADF`：fd 无效
    

---

## 3) `request`（命令码）怎么来的？

`ioctl` 的 request 通常来自头文件宏定义，例如：

- 终端：`TIOCGWINSZ`（get window size）
    
- socket：`FIONREAD`、`SIOCGIFFLAGS` 等
    
- 块设备：`BLKGETSIZE64`
    
- 文件系统：`FICLONE`（reflink clone）、`FS_IOC_GETFLAGS` 等
    

### 3.1 自定义 ioctl 的编码宏（驱动/内核接口常用）

你会看到这些宏：

- `_IO(type, nr)`：不传数据
    
- `_IOR(type, nr, data_type)`：内核 → 用户（read）
    
- `_IOW(type, nr, data_type)`：用户 → 内核（write）
    
- `_IOWR(type, nr, data_type)`：双向
    

它们会把“类型(type)、编号(nr)、方向、数据大小”编码进 `request`。

---

## 4) 三个常见用户态例子（可直接跑）

### 4.1 查询终端窗口大小：`TIOCGWINSZ`

```C
#include <sys/ioctl.h>
#include <unistd.h>
#include <stdio.h>

int main() {
    struct winsize ws;
    if (ioctl(STDIN_FILENO, TIOCGWINSZ, &ws) == -1) {
        perror("ioctl TIOCGWINSZ");
        return 1;
    }
    printf("rows=%u cols=%u\n", ws.ws_row, ws.ws_col);
    return 0;
}
```

### 4.2 查询“当前可读字节数”（常用于非阻塞/管道/终端等）：`FIONREAD`

```C
#include <sys/ioctl.h>
#include <unistd.h>
#include <stdio.h>

int main() {
    int n = 0;
    if (ioctl(STDIN_FILENO, FIONREAD, &n) == -1) {
        perror("ioctl FIONREAD");
        return 1;
    }
    printf("bytes available now: %d\n", n);
    return 0;
}
```

### 4.3 查询块设备容量：`BLKGETSIZE64`（例如 `/dev/sda`、`/dev/nvme0n1`）

```C
#include <sys/ioctl.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>
#include <stdint.h>
#include <linux/fs.h>

int main(int argc, char **argv) {
    const char *dev = (argc > 1) ? argv[1] : "/dev/sda";
    int fd = open(dev, O_RDONLY);
    if (fd < 0) { perror("open"); return 1; }

    uint64_t bytes = 0;
    if (ioctl(fd, BLKGETSIZE64, &bytes) == -1) {
        perror("ioctl BLKGETSIZE64");
        close(fd);
        return 1;
    }
    printf("%s size = %llu bytes\n", dev, (unsigned long long)bytes);
    close(fd);
    return 0;
}
```

---

## 5) 工程里怎么用 ioctl 才“稳”

- **优先用更标准的接口**：如果有 `fcntl`、`getsockopt/setsockopt`、`termios` API 等，通常比 ioctl 更可移植、语义更清晰。
    
- **明确数据方向**：大多数 ioctl 都是“传结构体指针”。你要保证结构体大小、对齐、初始化正确。
    
- **强烈建议查头文件/手册**：ioctl 是“每个子系统一套规则”，不查文档很容易传错。
    
- **兼容性注意**：32/64 位、结构体版本变化、`compat_ioctl`（驱动侧）都可能踩坑。
    

---