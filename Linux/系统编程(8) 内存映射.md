# Linux 存储映射（mmap）从零到工程用法

> 目标：你看完能回答 4 件事：
> 1) **mmap 是什么、解决什么痛点**  
> 2) mmap 相关函数的**函数签名 + 参数含义**  
> 3) 能写出**读文件/写文件/共享内存**的最小可运行代码  
> 4) 知道 mmap 的**常见坑**（对齐、SIGBUS、一致性、性能误区）

---

## 1. 先从问题出发：mmap 解决什么？

### 1.1 传统 `read/write` 的典型成本
你用 `read(fd, buf, n)` 时，会发生：
- 内核从磁盘/页缓存拿数据
- 拷贝到你的用户态缓冲 `buf`

当你：
- **随机访问**大文件（例如索引、数据库、日志检索）
- 或频繁小块读写（大量 syscalls + memcpy）

会出现瓶颈：
- syscall 次数多
- 你需要自己维护“窗口/缓存/预读”

### 1.2 mmap 的核心价值（直觉）
`mmap` 把“文件的一段”映射到你的虚拟地址空间：

> **文件 ≈ 一段内存数组**  
> 你像访问内存一样 `p[i]` 读取/修改；
> 缺页时内核自动把对应页面加载进来（按需分页 demand paging）。

## 1) 映射建立时：只是建立“虚拟地址 → 文件页”的关系

调用 `mmap()` 成功返回一个指针 `p` 时，通常还**没有**真的把文件内容读进 RAM。  
内核只是记下：`p..p+len` 这段虚拟地址，对应文件 `[offset, offset+len)`。

## 2) 真正读到数据时：发生缺页 → 读磁盘到页缓存 → 映射进来

当你第一次访问 `p[i]`（CPU 读内存）：

1. 发现该页不在内存（缺页 page fault）
    
2. 内核把对应文件页**读入内核的页缓存 page cache**（如果本来就在 cache 里就不读磁盘）
    
3. 把这页的**物理页**映射到你的进程页表里
    
4. 返回用户态，CPU 重新执行那条读指令，你就读到了数据
    

所以它的路径是：

**磁盘（必要时） → 内核页缓存(page cache) → 直接映射到用户虚拟内存（无额外拷贝）**

它主要解决：
1) **随机访问更自然**：不用 `lseek + read` 反复移动 offset
2) **减少用户态 memcpy**：你不需要把数据再拷贝一份到用户缓冲再解析
3) **减少 syscall 次数**：一次 `mmap` 后，很多读操作变成普通内存访问
4) **进程间共享**（MAP_SHARED / shm）：多个进程共享同一段内存视图

> 注意：mmap 不是“无条件更快”。它把成本从 `read` 的 syscalls/拷贝，换成了 **页错误（page fault）+ TLB/cache 行为**。随机访问模式下经常很赚；极端顺序大吞吐下，有时 `read` + 大 buffer 也很强。

---

## 2. mmap 的心智模型（非常重要）

把文件映射后，你得到一个指针 `p`：
- `p` 指向你进程虚拟内存的一段区域
- 这段区域背后“绑定”到文件的某个偏移 `offset`
- 你访问 `p + k` 相当于访问文件的 `offset + k`

如果某一页还没加载到内存：
- CPU 触发缺页异常
- 内核把对应文件页读入页缓存并映射
- 返回到用户态继续执行

---

## 3. 核心 API：函数签名与参数解释

### 3.1 `mmap`
```c
#include <sys/mman.h>

void *mmap(void *addr, size_t length,
           int prot, int flags,
           int fd, off_t offset);
```
- 返回：成功返回映射起始地址；失败返回 `MAP_FAILED`（即 `(void*)-1`）并设置 `errno`

参数含义：
- `addr`：期望映射到的地址
  - 通常传 `NULL` 让内核自己挑地址
- `length`：映射长度（字节）
  - 映射范围是 `[addr, addr+length)`
- `prot`：这段内存的权限
  - `PROT_READ` 读
  - `PROT_WRITE` 写
  - `PROT_EXEC` 执行
  - `PROT_NONE` 无访问
- `flags`：映射类型/行为
  - `MAP_PRIVATE`：私有写时拷贝（COW）。你写不会回写文件（常用于只读解析、或“改一份副本”）
  - `MAP_SHARED`：共享映射。你的写会反映到文件/其他进程视图（可配合 msync）
  - `MAP_ANONYMOUS`：匿名映射（不关联文件），fd 传 -1，offset 传 0（常用于大块内存/共享内存配合 fork 等）
  - `MAP_FIXED`：强制映射到 addr（高风险，非必要不要用）
- `fd`：文件描述符
  - 由 `open()` 得到；匿名映射时 `-1`
- `offset`：文件内偏移（字节）
  - **必须是页大小的整数倍**（非常常见的坑）

---

### 3.2 `munmap`
```c
int munmap(void *addr, size_t length);
```
- 解除映射。成功返回 0，失败 -1。

---

### 3.3 `msync`（把脏页刷回文件 / 同步一致性）
```c
int msync(void *addr, size_t length, int flags);
```
- `flags`：
  - `MS_SYNC`：阻塞直到写回完成（更强）
  - `MS_ASYNC`：异步发起写回
  - `MS_INVALIDATE`：使其他映射失效（较少用）

> 注意：`MAP_SHARED` 下写入**并不等于立即落盘**。落盘语义需要 `msync` 或 `fsync(fd)`（语义略不同）。

## `MS_SYNC`：同步写回（阻塞等待）

- 含义：把 `[addr, addr+length)` 这段映射中**脏页**安排写回，并且**一直等到写回完成**才返回。
    
- 典型用途：
    
    - 你用 `mmap(MAP_SHARED)` 修改了文件内容，接下来要“尽可能确保已经写到存储系统”（至少写到内核认为的 backing store）再继续做下一步。
        
    - 做类似“写完就要立刻对外可见/尽量持久”的场景。
        

`memcpy(p, data, len); msync(p, len, MS_SYNC);   // 等写回完成`

> 注意：`MS_SYNC` 强，但仍不等于“电源瞬断也一定不丢”。严格崩溃一致性通常还会结合 `fsync(fd)`、日志/双写等策略。

---

## `MS_ASYNC`：异步写回（不等待）

- 含义：发起写回（把脏页交给内核/回写线程去处理），**立刻返回**，不等它写完。
    
- 典型用途：
    
    - 后台“定期刷新”脏页，减少瞬时脏页堆积
        
    - 性能更友好，但你不能假设返回时数据已经落下去
        

`msync(p, len, MS_ASYNC);  // 只发起，不等完成`

---

## `MS_INVALIDATE`：使缓存失效/重新取最新内容（更偏“读一致性”）

- 含义：让内核把这段映射对应的页缓存视图“作废/失效”，从而**之后访问时更倾向于重新从底层文件拿最新数据**（尤其当文件可能被别的进程用 `write()` 改过）。
    
- 典型用途：
    
    - 你映射了文件，但文件内容可能被其它路径修改（比如另一个进程 `write()` 更新），你希望自己的映射别老看“旧页缓存”，想尽量刷新视图。
        

常见组合：

- `MS_SYNC | MS_INVALIDATE`：既写回（如果你也写了），又让视图失效以便重新获取
    
- `MS_ASYNC | MS_INVALIDATE`：异步发起 + 让视图失效
    

> 现实提醒：进程间一致性/同步不靠 `msync` 单独解决。多进程同时读写同一文件时，仍需要锁（`flock/fcntl`）或明确的协议，否则你即使 invalidate 也可能读到中间态。

---

## 你该怎么选

- **想“写完立刻尽量安全”**：`MS_SYNC`
    
- **想“后台刷一刷，不阻塞”**：`MS_ASYNC`
    
- **担心别人改了文件，我想尽量看到最新**：加上 `MS_INVALIDATE`（并配合同步/锁）

---

### 3.4 `mprotect`（改映射页权限）
```c
int mprotect(void *addr, size_t len, int prot);
```
常用：先 `PROT_READ|PROT_WRITE` 初始化，之后改成 `PROT_READ` 防止误写。

---

### 3.5 `madvise`（告诉内核你的访问模式，帮助预读/回收）
```c
int madvise(void *addr, size_t length, int advice);
```
常见 `advice`：
- `MADV_SEQUENTIAL` 顺序访问（更积极预读）
- `MADV_RANDOM` 随机访问（减少预读）
- `MADV_WILLNEED` 预热（可能触发预读）
- `MADV_DONTNEED` 告诉内核这段不需要了（可能回收页缓存）


## 1) `madvise` 到底在“建议”什么？

你 `mmap` 之后访问 `p[i]` 会触发缺页，内核会：

- 把对应文件页放进 **page cache**
    
- 可能做 **预读**（猜你接下来会读哪几页）
    
- 在内存压力下选择**回收哪些页缓存**
    

`madvise(addr, len, advice)` 就是在告诉内核：

> 这段映射你打算怎么访问？顺序还是随机？要不要提前预读？用完能不能尽快丢？

注意：效果**依赖内核版本、内存压力、文件系统、I/O 调度**，所以它是“提示”，不是保证。

---

## 2) `MADV_SEQUENTIAL`：顺序访问（鼓励预读 + 更快回收旧页）

**适用场景**：你会从头到尾按顺序扫一遍（日志扫描、解析大文件、流式处理）。

内核可能做的优化：

- **更积极的 readahead**：你读第 1 页时，内核可能顺带读后面一串页进 page cache
    
- **更倾向丢弃已经读过的旧页**：因为你不太可能回头再读
    

直觉：像看书从第一页翻到最后一页，内核帮你“提前翻几页到桌面上”，看完前面的页就“收走”。

用法：

`madvise(p, len, MADV_SEQUENTIAL);`

---

## 3) `MADV_RANDOM`：随机访问（减少预读）

**适用场景**：你会跳着访问（索引查找、二分、哈希访问、数据库点查）。

为什么需要它：

- 默认内核可能会根据“你刚访问了某页”推测你会继续访问相邻页并预读
    
- 但随机访问下，这些预读大概率是浪费：读了不用，占内存/占 I/O
    

`MADV_RANDOM` 的作用就是：

- **降低/关闭 readahead 的倾向**，减少无用 I/O 和缓存污染
    

用法：

`madvise(p, len, MADV_RANDOM);`

---

## 4) `MADV_WILLNEED`：我马上要用（尝试预热/预读）

**适用场景**：

- 你马上要扫描一段大映射，希望减少“边读边缺页”的抖动
    
- 你要做延迟敏感操作（例如接下来要快速响应查询），希望提前把热数据拉进内存
    

它“可能”触发：

- 对应页的 **readahead / 异步读入 page cache**
    
- 或至少把这些页标记得更“热”
    

但要注意两点：

1. 它**不保证**所有页马上都在 RAM（内存不足时做不到）
    
2. 对超大范围盲目 `WILLNEED` 可能适得其反（把别的热页挤掉）
    

用法（推荐对“你确定马上会用”的那一段做）：

`madvise(p + off, win_len, MADV_WILLNEED);`

---

## 5) `MADV_DONTNEED`：我用完了（尽量丢掉这些页，释放缓存压力）

**适用场景**：

- 你顺序扫过一段数据，确认不会再访问
    
- 你做“分块处理”，希望处理完一块就让内核回收该块的页缓存，避免 RSS/page cache 膨胀
    

它通常意味着：

- 这段地址的页在内核里会被标成“可回收/不太重要”
    
- 下次你再访问这段，可能会重新触发缺页从文件读（性能会下降，但省内存）
    

一个常见模式（滑动窗口处理）：

```C
// 处理完 [p, p+chunk)
process(p, chunk);
madvise(p, chunk, MADV_DONTNEED); // 告诉内核：这一块可以扔了
```

**重要澄清（很容易误解）**：

- 对文件映射来说，`DONTNEED` 更像是“丢掉缓存/下次再读”，不是“把文件内容清零”
    
- 对 `MAP_SHARED` 且你修改了脏页的情况，内核可能需要先写回/处理一致性（不同内核行为细节不完全一样），所以别把它当作可靠的“刷盘”手段——刷盘用 `msync`/`fsync`。
    

---

## 6) 该怎么选（口诀）

- **从头读到尾**：`SEQUENTIAL`（可配合 `WILLNEED` 预热一小段）
    
- **跳着查**：`RANDOM`
    
- **马上要用**：`WILLNEED`（别对整个超大文件用）
    
- **用完就丢**：`DONTNEED`（适合分块处理，控内存）
    

---

## 7) 一个“由浅入深”的组合例子

**场景：顺序扫描超大日志文件，分块处理，尽量不卡顿也不吃内存**

```C
madvise(p, len, MADV_SEQUENTIAL);

size_t chunk = 64 * 1024 * 1024; // 64MB 一块
for (size_t off = 0; off < len; off += chunk) {
    size_t n = (off + chunk <= len) ? chunk : (len - off);

    madvise((char*)p + off, n, MADV_WILLNEED);  // 预热当前块（可选）
    process((char*)p + off, n);
    madvise((char*)p + off, n, MADV_DONTNEED);  // 用完就丢，控内存
}

```



---

## 4. 最小可运行：只读映射（解析文件最常用）


## 1) `stat` 是什么？

在 Linux/Unix 里，**stat = 文件状态信息**。内核为每个文件维护一份“属性”，比如：

- 文件大小（`st_size`）
    
- 文件类型（普通文件/目录/符号链接…）
    
- 权限（rwx）
    
- 所属用户/组（uid/gid）
    
- 最后访问/修改时间（atime/mtime/ctime）
    
- inode 编号等
    

这些信息用一个结构体装起来，就是：

`#include <sys/stat.h>  struct stat {     // 里面字段很多，最常用的之一是：     off_t st_size;  // 文件大小（字节数）     // 还有 st_mode(类型+权限), st_mtime 等 };`

---

## 2) `fstat(fd, &st)` 做什么？

`fstat` 用**文件描述符 fd** 去问内核：“这个 fd 对应的文件状态信息是什么？”，把结果填到 `st` 里。

`struct stat st; if (fstat(fd, &st) < 0) { perror("fstat"); close(fd); return 1; }`

- 返回值 `< 0` 表示失败（比如 fd 无效），`perror("fstat")` 打印错误原因。
    
- 失败后关闭 fd 并退出。
    

> 对比：`stat("path", &st)` 是用路径查；`fstat(fd, &st)` 是用已打开的 fd 查。
> 

```c
#include <sys/mman.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>

int main() {
    int fd = open("data.bin", O_RDONLY);
    if (fd < 0) { perror("open"); return 1; }

    struct stat st;
    if (fstat(fd, &st) < 0) { perror("fstat"); close(fd); return 1; }
    if (st.st_size == 0) { fprintf(stderr, "empty file\n"); close(fd); return 1; }

    size_t len = (size_t)st.st_size;
    void *p = mmap(NULL, len, PROT_READ, MAP_PRIVATE, fd, 0);
    if (p == MAP_FAILED) { perror("mmap"); close(fd); return 1; }

    // 像访问内存一样访问文件内容
    unsigned char *b = (unsigned char*)p;
    printf("first byte: %u\n", (unsigned)b[0]);

    munmap(p, len);
    close(fd);
    return 0;
}
```

要点：
- 只读解析通常用 `MAP_PRIVATE + PROT_READ`
- 不需要 `msync`

---

## 5. 最小可运行：写文件（MAP_SHARED）

写映射的关键点：
1) 文件必须先扩展到你要写的大小（`ftruncate`）
2) 用 `MAP_SHARED | PROT_WRITE`
3) 需要持久化语义时用 `msync` / `fsync`

```c
#include <sys/mman.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

int main() {
    int fd = open("out.txt", O_RDWR | O_CREAT | O_TRUNC, 0644);
    if (fd < 0) { perror("open"); return 1; }

    const char *msg = "hello mmap\n";
    size_t len = strlen(msg);

    // 关键：扩展文件大小，否则写入可能 SIGBUS
    if (ftruncate(fd, (off_t)len) < 0) { perror("ftruncate"); close(fd); return 1; }

    char *p = mmap(NULL, len, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
    if (p == MAP_FAILED) { perror("mmap"); close(fd); return 1; }

    memcpy(p, msg, len);

    // 需要确保写回（可选，取决于你对持久化的要求）
    if (msync(p, len, MS_SYNC) < 0) perror("msync");

    munmap(p, len);
    close(fd);
    return 0;
}
```

---
获取页大小：
## `sysconf(_SC_PAGESIZE)`（推荐）

```C
#include <unistd.h>
#include <stdio.h>

int main() {
    long ps = sysconf(_SC_PAGESIZE);  // 或 _SC_PAGE_SIZE
    printf("page size = %ld\n", ps);
}
```


## 6. 进阶：映射大文件（滑动窗口 + offset 对齐）

当文件很大，你不想一次 mmap 全部，或地址空间/内存压力很大：
- 只映射一段窗口
- 访问完 `munmap`
- 再映射下一段

关键坑：`offset` 必须页对齐：

```c
long pagesz = sysconf(_SC_PAGESIZE);

off_t off = ...; // 你想从文件的 off 处开始
off_t off_aligned = (off / pagesz) * pagesz;
size_t delta = (size_t)(off - off_aligned);

size_t map_len = delta + want_len;
char *base = mmap(NULL, map_len, PROT_READ, MAP_PRIVATE, fd, off_aligned);

char *data = base + delta; // 这才是你真正想要的起点
```

---

## 7. 常见坑（工程里最容易炸的点）

### 7.1 `offset` 不页对齐 → `EINVAL`
- `mmap` 的 `offset` 必须是页大小倍数。

### 7.2 写超出文件大小 → 可能 `SIGBUS`
- `MAP_SHARED` 写入超过文件当前大小，常见结果是 `SIGBUS`。
- 正确做法：先 `ftruncate` 到足够大。

### 7.3 以为写了就“立刻落盘”
- `MAP_SHARED` 写通常只保证“脏页进入页缓存”，不等于落盘。
- 落盘：`msync(MS_SYNC)` 或 `fsync(fd)`。

### 7.4 文件被其他人截断/替换
- 如果文件在映射期间被截断，你访问被截断部分可能触发 `SIGBUS`。
- 如果你做日志/热更新文件解析，需要更谨慎的策略（比如重开 fd、版本号、或复制到临时文件）。

### 7.5 并发一致性（多进程共享写）
- `MAP_SHARED` 让多个进程看到同一份页缓存，但并不提供“事务/锁”。
- 你仍需要 `fcntl/flock` 或进程间同步原语（mutex/sem/eventfd 等）。

### 7.6 性能误区
- 顺序大吞吐：`read` + 大 buffer + `posix_fadvise` 可能一样快甚至更快
- mmap 更适合：随机访问、结构化解析、需要共享、减少用户态拷贝

---

## 8. 你什么时候该选 mmap？（快速选型）

强烈推荐 mmap：
- 大文件随机访问（索引、倒排、LSM 的 SSTable 部分场景）
- 只读解析（ELF/PE/大型二进制格式、日志检索）
- 多进程共享只读数据（字典、模型、配置）

不建议/谨慎：
- 需要严格写入落盘事务语义（要自己补 msync/fsync + 日志）
- 文件会频繁被截断/替换且你还要持续读
- 你不想处理 SIGBUS/一致性问题


## mmap 的优点

- **减少一次用户态拷贝**：`read()` 需要把页缓存数据 memcpy 到用户缓冲；`mmap()` 直接把页缓存页映射到进程地址空间，读数据就是普通内存访问。
    
- **减少系统调用次数**：一次 `mmap` 后，很多读取变成内存访问；对“频繁小块访问/解析”更友好。
    
- **随机访问更自然**：不用反复 `lseek + read`，按指针偏移访问即可，适合索引、二分、跳读等模式。
    
- **按需加载（demand paging）**：只在真正访问到某页时才触发读入，天然懒加载。
    
- **便于共享**：`MAP_SHARED` 可用于多进程共享同一文件页缓存视图；匿名映射/`shm_open` 可做共享内存。
    

## mmap 的不足

- **错误模型更“硬”**：访问被截断的映射区域可能触发 **SIGBUS**，不像 `read()` 那样返回错误码，调试/容错更难。
    
- **一致性与持久化语义复杂**：`MAP_SHARED` 写入不等于落盘；需要 `msync/fsync`，并发读写还要锁/协议。
    
- **页大小对齐限制**：`offset` 必须页对齐；大文件滑动窗口映射需要处理对齐与偏移。
    
- **性能不一定更快**：顺序大吞吐时，`read()` + 大 buffer + 预读可能同样快甚至更好；mmap 在随机访问/解析场景更占优。
    
- **内存压力与抖动**：大量随机访问会产生大量缺页与页缓存占用，可能导致抖动（page fault 开销、cache/TLB 压力）。
    
- **不适合某些 I/O 场景**：例如严格实时、文件频繁被替换/截断、或需要精确控制 I/O 调度与回收策略的场景，mmap 反而更难控。


## 它解决了什么问题？

如果你用 `mmap` 得到一块很大的连续内存（或文件映射），后面发现要变大/变小，传统做法往往是：

1. `munmap(old)`
    
2. `mmap(new)`
    
3. （匿名映射时）还得 `memcpy` 把旧数据拷过去
    

这在大内存场景很重。

`mremap` 解决的是：

- **扩容/缩容映射区**（释放尾部或扩大长度）
    
- 如果原地址后面没空间了，内核可以**把整段映射移动到别处**（并保持内容一致）
    
- 可能只是调整页表映射，通常比“重新申请 + 拷贝”更省
函数签名：
```C
#include <sys/mman.h>

void *mremap(void *old_address, size_t old_size,
             size_t new_size, int flags, ... /* void *new_address */);
```

---

## 9. 下一步：把 mmap 和你前面的 epoll/网络串起来

典型工程组合：
- **静态文件服务器**：`mmap` 映射文件 + `writev/sendfile` 发送
- **日志检索服务**：mmap 只读映射 + 自己做索引结构
- **共享内存队列**：`shm_open` + `ftruncate` + `mmap(MAP_SHARED)` + 原子/锁

---

如果你告诉我你具体场景是：
1) “只读解析大文件”
2) “写入并要持久化/崩溃一致性”
3) “多进程共享内存通信”

我可以把对应的代码模板（含同步策略、错误处理、测试方法）写成你可以直接跑的版本。

