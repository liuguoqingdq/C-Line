到目前为止，我们所讨论的所有动态内存分配机制都是使用堆和内存映射来实现的。由于堆和匿名映射本身就是动态的，所以想到使用它们是很自然的。在程序地址空间中常用的另一个结构体是栈，它用来存放程序的自动变量（automatic variables）。

 然而，认为编程人员不能使用栈来进行动态内存分配是毫无理由的。**只要分配不会导致栈溢出，使用栈分配的解决方式是简单而完美的。** 要在一个栈中实现动态内存分配，可以使用系统调用alloca()：
 
 ```C
 #include <alloca.h>
 
 void* alloca(size_t size);
 ```
 - 成功时，alloca()调用会返回一个指向size字节大小的内存指针。这块内存是在栈中的，当调用它的函数返回时，这块内存会被自动释放。
 
- 失败时，某些该函数的实现会返回NULL，但是alloca()在大多数情况下是不会失败或者无法报告失败。失败表现在出现栈溢出。 

alloca()的用法和malloc()一样，但不需要（实际上，不允许）释放分配到的内存。以下示例函数，会打开系统配置目录（可能是/etc）下一个给定的文件，该目录可能是/etc，在编译时就确定了。该函数必须申请一块新的缓冲区，把系统配置路径复制到这个缓冲区中，然后将缓冲区和指定文件名关联起来： 

```C
int open_sysconf(const char* file,int flags,int mode){
	const char* etc = SYSCONF_DIR;
	char* name = alloca(strlen(name)+strlen(file)+1);//+1是因为c风格字符串要以\0结尾
	strcpy(name,etc);
	//`strcpy(dest, src)` 会把 `src` 从头开始复制到 `dest`，**包括最后的 `'\0'` 终止符**，所以复制结束后 `dest` 一定以 `'\0'` 结尾。
	strcat(name,file);
	//`strcat(dest, src)` 会把 `src` 的内容复制到 `dest` **末尾那个 `'\0'` 的位置**开始，并且**在追加后的新字符串末尾写入一个 `'\0'`**（终止符）。所以结果一定是以 `'\0'` 结尾的 C 字符串。
	return open(name,flags,mode);
}
```
在open_sysconf函数返回时，从alloca()分配到的内存会随着栈的释放而被自动释放。这意味着当调用alloca()的函数返回后，就不能再使用由alloca()得到的那块内存！然而，由于这种方式不需要调用free()来完成释放工作，所以最终代码会简洁一些。
```C
char a[10] = "hi";   // h i \0
char b[] = "abc";    // a b c \0
strcat(a, b);        // a 变成 "hiabc\0"
```

alloca()接口有着曲折的历史。在许多系统中，它表现很不好，可能出现未定义行为。在某些系统中，栈大小较小而且固定，使用alloca()很容易导致栈溢出，进而导致程序崩溃。在另外一些系统中，根本就不提供alloca()接口。由于经常出错和版本不一致，人们对alloca()总是没有一个好的印象。

因此，如果希望代码具有可移植性，应该避免使用alloca()。但是，在Linux系统上，alloca()却是一个非常好用的工具，但没有被充分利用。在Linux上，它表现很出色（在很多体系结构下，通过alloca()进行内存分配就和增加栈指针一样简单，性能比malloc()要好很多）。在Linux下，对于较小的内存分配，使用alloca()可以得到很大的性能提升。

----
## 把字符串复制到栈中

**原型、头文件
```C
#define _GNU_SOURCE
#include <string.h>

char *strdupa(const char *s);
char *strndupa(const char *s, size_t n);
```
- 需要 `<string.h>`
    
- 需要特性宏 `_GNU_SOURCE` 才会声明出来（glibc）

## 2) `strdupa(s)` 做什么？

### 功能

- 在**当前函数的栈帧**里分配一块足够大的缓冲区（`strlen(s)+1`），把 `s` 复制进去，并保证以 `'\0'` 结尾。
    
- 返回指向这块栈内存的指针。[manpages.ubuntu.com+1](https://manpages.ubuntu.com/manpages/focal/en/man3/strdup.3.html)
    

### 参数

- `s`：源 C 字符串（必须以 `'\0'` 结尾，否则会越界读）。
    

### 返回值 / 失败行为

- 返回 `char*` 指向复制后的字符串。
    
- **没有像 `strdup` 那样的“ENOMEM 返回 NULL”保证**：因为它用的是 `alloca`，一旦分配太大导致**栈溢出，行为未定义**（常见是直接崩溃）。[manpages.ubuntu.com+1](https://manpages.ubuntu.com/manpages/focal/en/man3/strdup.3.html)
    

### 生命周期（最关键）

- 这块内存会在“调用 `strdupa()` 的那个函数返回时”自动失效（随栈帧回收）。[Arch Manual Pages](https://man.archlinux.org/man/alloca.3.en?utm_source=chatgpt.com)
    
- **绝对不能 `free()`**，也不能把指针返回到函数外长期持有（会变悬空指针）。
    

---

## 3) `strndupa(s, n)` 和它有什么不同？

### 功能

- 类似 `strndup`：最多复制 `n` 个字节；如果 `s` 比 `n` 长，只复制前 `n` 字节，并**额外补一个终止符 `'\0'`**。
    
- 但内存依然是用 `alloca` 放在栈上。[manpages.ubuntu.com+1](https://manpages.ubuntu.com/manpages/focal/en/man3/strdup.3.html)
    

### 参数

- `s`：源字符串
    
- `n`：最多复制的字节数（不含额外的 `'\0'`，实际会分配 `min(strlen(s), n)+1` 量级）
    

### 返回值 / 失败行为

- 同 `strdupa`：返回栈上的指针；分配过大导致栈溢出 → 未定义行为。[manpages.ubuntu.com+1](https://manpages.ubuntu.com/manpages/focal/en/man3/strdup.3.html)
    

---

## 4) 什么时候用、什么时候别用

**适合：**

- 很短生命周期、确定不会太大的临时字符串（例如拼路径、格式化短日志）。
    

**不适合：**

- `s` 或 `n` 来自不可信输入、可能很大（网络包/文件/用户输入）——容易把栈打爆。
    
- 需要跨函数保存结果。
    

---

## 5) 小例子（推荐写法）

```C
#define _GNU_SOURCE
#include <string.h>
#include <stdio.h>

void f(const char *name) {
    char *tmp = strndupa(name, 128);   // 给一个上限，别无界
    printf("name=%s\n", tmp);
} // 这里 tmp 自动失效
```

---

## 6) 更稳的替代

- 需要可控失败处理/大字符串：用 `strdup/strndup`（堆上分配，记得 `free`）。[manpages.ubuntu.com+1](https://manpages.ubuntu.com/manpages/focal/en/man3/strdup.3.html)
    
- C++：优先用 `std::string`（更安全）。