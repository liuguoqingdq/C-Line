# 5.6 用户 ID / 组 ID：实际、有效、保留（saved）与系统调用

> 目标：把“进程身份”这件事讲清楚，并能在实战中正确写出：
> - setuid 程序如何 **临时降权** 再 **恢复特权**
> - root 守护进程如何 **永久降权**
> - 兼容不同 Unix（BSD / HP-UX）时如何选择 API

---

## 0. 先把 3 个 ID 的角色说透（UID 与 GID 同理）

每个进程至少有 3 份“用户身份凭据”（组也一样）：

1) **实际用户 ID** `ruid`（real UID）
- “这个进程从谁来”：通常是启动它的登录用户。
- 很多审计/归属语义会用它。

2) **有效用户 ID** `euid`（effective UID）
- **权限检查主要看它**：打开文件、绑定特权端口、发送信号等。
- setuid 程序就是通过改变 euid 来获得（或放弃）特权。

3) **保留（保存的）用户 ID** `suid`（saved set-user-ID）
- 作用：给 setuid 程序留一个“后门钥匙”。
- 典型场景：setuid-root 程序启动时 `euid=0, suid=0, ruid=普通用户`。
  - 程序可以 `seteuid(ruid)` 暂时降权做不敏感工作
  - 需要特权时再 `seteuid(suid)` 恢复
setresuid这个函数在调用的时候，有三个参数分别是ruid euid suid。suid是后门防止永久降权。
> 组 ID 同理：`rgid` / `egid` / `sgid`。

### 0.1 exec(setuid/setgid 文件)时发生什么？
当你 `exec` 一个 **设置了 setuid 位** 的可执行文件：
- `euid` 会变成该文件所有者 UID
- `suid` 也会被设置为该所有者 UID
- `ruid` 通常保持为“启动者的 UID”

同理：setgid 文件会影响 `egid/sgid`。

---

# 5.6.1 改变“实际(ruid/rgid) + 保留(suid/sgid)”的方式

这一类调用的共同点：**能影响 ruid/rgid 和 suid/sgid**（至少在“具备权限”时）。

## 5.6.1.1 `setuid()` / `setgid()`（最常见、但语义要分两种身份）

```c
#include <unistd.h>
int setuid(uid_t uid);
int setgid(gid_t gid);
```

### A) 你是特权进程（通常 euid==0，或具备相应 capability）
- `setuid(uid)` 会把 **ruid、euid、suid** 全部设为 `uid`
- `setgid(gid)` 会把 **rgid、egid、sgid** 全部设为 `gid`

**实战含义**：
- root 调 `setuid(1000)` 是“永久降权”：
  - 之后通常就无法再恢复 root（因为 suid 也改掉了）
  - 这正是守护进程常用的安全做法

### B) 你是非特权进程
- 通常只能把 euid 改成 “ruid / euid / suid 中的一个”（不同系统的细节略有差异）
- ruid 和 suid 通常不会被你随意改成陌生 UID

> 重要结论：
> - **想永久放弃特权**：用 `setuid()`（root→普通用户）
> - **想临时切换特权**：更适合用 `seteuid()`（下一节）

---

## 5.6.1.2 `setresuid()` / `setresgid()`（现代、语义最清晰）

```c
#include <unistd.h>
int setresuid(uid_t ruid, uid_t euid, uid_t suid);
int setresgid(gid_t rgid, gid_t egid, gid_t sgid);
```

- 可以一次性明确设置 **real / effective / saved** 三者
- 参数可用 `-1` 表示“不改变该项”

### 为什么它很重要？
因为 `setuid/setreuid` 在不同 Unix 里存在历史包袱，而 `setresuid` 让你：
- 明确写出“我要改哪些，不改哪些”
- 避免被平台差异坑

例：临时降权但保留恢复通道（常见于 setuid 程序）
```c
// 假设当前 euid=0, suid=0, ruid=1000
setresuid(-1, 1000, 0); // 只把 euid 降到 1000，suid 仍保留 0
```

例：永久降权（同时清掉 suid）
```c
setresuid(1000, 1000, 1000);
```

---

# 5.6.2 改变“有效(euid/egid)”的方式（临时切换首选）

## 5.6.2.1 `seteuid()` / `setegid()`

```c
#include <unistd.h>
int seteuid(uid_t uid);
int setegid(gid_t gid);
```

- **只改变 euid/egid**（real 和 saved 不动）
- 非特权进程通常只能把 euid 改成：`ruid/euid/suid` 中的一个

### 典型用法：setuid 程序的“最小特权”模式

**场景**：setuid-root 工具只在需要特权的一小段代码里用 root。

```c
uid_t r = getuid();   // 启动者
uid_t e = geteuid();  // setuid 文件 owner（可能是 0）

// 1) 默认先降权
seteuid(r);

// 2) 做大量普通工作（解析参数、读用户文件、网络协议…）

// 3) 只有在需要时恢复特权
seteuid(e);
//    执行需要特权的操作

// 4) 操作完立刻再降权
seteuid(r);
```

> 关键点：
> - handler/回调里不要意外长期保持 euid=0
> - 特权段越短越好

---

# 5.6.3 BSD 改变用户/组 ID 的方式（历史风格：`setreuid/setregid`）

## 5.6.3.1 `setreuid()` / `setregid()`

```c
#include <unistd.h>
int setreuid(uid_t ruid, uid_t euid);
int setregid(gid_t rgid, gid_t egid);
```

- 可以同时设置 real 和 effective
- 参数 `-1` 表示不改变对应项

### BSD 传统语义的核心思想（你要理解它“为什么出现”）
早期 BSD 把 `setuid()` 的语义改得更灵活：
- 允许在一定规则下对 ruid/euid 做交换或设置
- 以支持 setuid 程序“临时降权再恢复”的需求

### 为什么今天不太推荐它当首选？
- `setreuid` 在不同系统上允许的组合不完全一致（历史兼容 + 标准化差异）
- 在 Linux 上也明确提示：POSIX 没有规定所有细节，各家差异存在

**工程建议**：
- 能用 `setresuid/setresgid` 就用它
- 需要“只改 euid”时用 `seteuid/setegid`
- 只有为了兼容旧系统时才使用 `setreuid/setregid`

---

# 5.6.4 HP-UX 中改变用户/组 ID 的方式

HP-UX 作为商业 Unix，一般也提供：
- `setreuid/setregid`
- `seteuid/setegid`
- `setresuid/setresgid`
- `getresuid/getresgid`（可直接取出 r/e/s 三者）

## 5.6.4.1 HP-UX 的 `setresuid/setresgid`
思路与 Linux/BSD 一致：
- 明确设置 real/effective/saved
- `-1` 表示不改变

## 5.6.4.2 HP-UX 的 `setreuid`
同样支持 `-1` 保持不变，并且对非特权进程有“只能切换到当前已有 ID 集合”一类限制。

> 你在做“跨 Unix 可移植”时：
> - 优先写 `setresuid` 路径
> - 回退到 `setreuid` 作为兼容分支

---

# 5.6.5 操作用户 ID/组 ID 的首选方法（生产可用的选择策略）

把需求分成 3 类，你就永远不会乱：

## 1) **永久降权（最安全）**
典型：root 守护进程启动后，绑定端口/打开特权资源完成 → 降权到普通用户运行。

首选：
- `setgid(target_gid)` + `initgroups(user, target_gid)`（或 `setgroups`）
- 再 `setuid(target_uid)`

要点：
- 先改 gid 再改 uid（避免降权后没权限改组）
- 使用 `setuid`（会清掉 suid），确保不能恢复 root

## 2) **临时切换（setuid 程序最常见）**
目标：大部分时间以普通用户权限跑，必要时短暂提升。

首选：
- `seteuid(ruid)` 降权
- `seteuid(suid/euid)` 恢复

如果你需要同时控制保存 ID：
- `setresuid(-1, new_euid, keep_suid)`

## 3) **跨平台、语义清晰**
首选：
- `setresuid/setresgid`（一把梭）

回退：
- `seteuid/setegid` 只改有效 ID
- 最后才考虑 `setreuid/setregid`

---

# 5.6.6 对“保留(saved) 用户 ID”的支持：为什么它重要？

## 5.6.6.1 没有 saved ID 会怎样？
如果系统只有 ruid/euid，没有 saved：
- setuid 程序想“降权再恢复”会非常别扭，甚至做不到
- 安全上也更容易写错

## 5.6.6.2 saved ID 带来什么能力？
- 允许 setuid 程序把“特权身份”保存起来（suid）
- 再把 euid 暂时改成 ruid 去做普通工作
- 需要特权时再把 euid 改回 suid

这直接支持了“最小特权原则”的工程落地。

## 5.6.6.3 关键安全结论：
- **seteuid** 适合临时切换（保留恢复通道）
- **setuid**（root→普通用户）适合永久降权（清掉恢复通道）

---

# 5.6.7 获取用户 ID / 组 ID

## 5.6.7.1 获取 real/effective（POSIX 通用）

```c
#include <unistd.h>

uid_t getuid(void);
uid_t geteuid(void);

gid_t getgid(void);
gid_t getegid(void);
```

- `getuid/getgid` → real
- `geteuid/getegid` → effective

## 5.6.7.2 获取 real/effective/saved（Linux/HP-UX/部分 BSD 可用）

```c
#define _GNU_SOURCE
#include <unistd.h>

int getresuid(uid_t *ruid, uid_t *euid, uid_t *suid);
int getresgid(gid_t *rgid, gid_t *egid, gid_t *sgid);
```

用途：
- 你在调试 setuid 程序时非常好用：一眼看清 r/e/s 三者

示例：
```c
uid_t r,e,s;
getresuid(&r,&e,&s);
// r: 启动者   e: 当前权限检查身份   s: 可恢复的保存身份
```

---

# 一张“速查表”：我该用哪个函数？

|需求|推荐 API|效果|
|---|---|---|
|永久降权（root→普通用户，不能恢复）|`setuid()` / `setgid()` 或 `setresuid(u,u,u)`|改 r/e/s 全部，清掉恢复通道|
|临时降权再恢复（setuid 程序）|`seteuid()` / `setegid()`|只改 euid/egid，r/s 保持|
|一次性精确控制 r/e/s|`setresuid()` / `setresgid()`|最清晰、最可移植|
|兼容旧 BSD 风格|`setreuid()` / `setregid()`|可改 r/e，但细节易受平台差异影响|
|获取 r/e|`getuid/geteuid/getgid/getegid`|POSIX 通用|
|获取 r/e/s|`getresuid/getresgid`|非标准但在 Linux/HP-UX/部分 BSD 常见|

---

# 最后给你 2 个“面试级”小问题（自测）

1) 为什么“永久降权”通常先 `setgid` 再 `setuid`？
2) setuid-root 程序如果调用 `setuid(getuid())`，为什么通常就再也恢复不了 root？这和 saved UID 有什么关系？

