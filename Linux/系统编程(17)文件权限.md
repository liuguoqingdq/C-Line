# 一、Linux 系统目录结构
![[Pasted image 20251221234637.png]]
## `/` 根目录（Root directory）

整棵 Linux 文件系统树的起点。所有目录都从这里展开。

---

## `/bin`（基本命令）

放**最基础、系统启动/救援也必须能用**的用户命令（可执行程序），例如：

- `ls` `cp` `mv` `cat` `sh` `bash` 等
    

> 现代很多发行版（systemd 系）会把 `/bin` 做成指向 `/usr/bin` 的符号链接，但概念作用不变。

---

## `/boot`（启动相关文件）

系统启动所需的静态文件，例如：

- 内核：`vmlinuz-*`
    
- initramfs：`initrd.img-*`
    
- 引导加载器配置：如 GRUB 的相关文件
    

---

## `/dev`（设备文件）

“**一切皆文件**”的体现：硬盘、终端、鼠标等设备在这里以文件形式呈现，例如：

- `/dev/sda` 磁盘
    
- `/dev/tty` 终端
    
- `/dev/null` 黑洞设备
    
- `/dev/random` 随机源
    

> 这里很多设备节点是系统运行时动态生成的（udev）。

---

## `/etc`（系统级配置）

放**系统全局配置文件**（文本为主），例如：

- 用户/组信息：`/etc/passwd` `/etc/group`
    
- 网络：`/etc/hosts` `/etc/resolv.conf`
    
- 服务配置：`/etc/ssh/sshd_config`
    
- 软件配置目录：`/etc/nginx/` `/etc/systemd/`
    

> 记忆点：`etc` ≈ “editable text configuration”。

---

## `/home`（普通用户家目录）

每个普通用户的个人空间，例如：

- `/home/chen/`  
    里面放你的文档、下载、项目代码、个人配置（如 `~/.bashrc`、`~/.ssh/`）等。
    

---

## `/lib`（关键共享库）

放**系统关键库文件**，给 `/bin`、`/sbin` 里的程序在启动时链接使用，例如：

- `libc.so` 等基础库
    
- 以及内核模块目录常见在 `/lib/modules/`
    

> 现代发行版也常把 `/lib` 链接到 `/usr/lib`（或拆成 `/lib64` 等），但语义一样：**基础运行库**。

---

## `/media`（可移动设备挂载点）

通常用于**U 盘、移动硬盘、光盘**等自动挂载的位置，例如：

- `/media/chen/USB_DISK/`
    

桌面环境（GNOME/KDE）和 udisks 一般会把可移动设备挂这里。

---

## `/mnt`（临时挂载点）

用于**手动临时挂载**文件系统的地方（管理员常用），例如：

- 你手动 `mount /dev/sdb1 /mnt`
    
- 或者修系统时把别的分区挂到 `/mnt`
    

---

## `/opt`（可选/第三方软件）

放“可选应用软件包”（尤其是**非系统包管理器安装**、或厂商自带的整套程序），例如：

- `/opt/google/`
    
- `/opt/myapp/`
    

特点是：通常一个软件一个目录，结构自包含，比较“干净”。

---

## `/tmp`（临时文件）

临时文件存放处，特点：

- 任何用户都能写（通常有 **sticky bit**，防止互删）
    
- 很多系统会在重启时清理（或定期清理）
    

适合放：临时解压、临时缓存、程序运行时中间文件。

---

## `/usr`（用户级应用与共享资源：系统主干）

这是系统里**最大的一块**：大多数命令、库、头文件、文档都在这里，例如：

- `/usr/bin`：大量常用命令（gcc、python、git…）
    
- `/usr/lib`：对应库文件
    
- `/usr/include`：头文件
    
- `/usr/share`：架构无关的数据（man 手册、icons、locale）
    

> 记忆点：**不是“用户 home”**，而是历史遗留命名。现在 `/usr` 更像“系统应用与资源的主体”。

---

# 顺带补充几个你以后必遇到的目录（图里没画但很重要）

- `/var`：经常变化的数据（日志 `/var/log`、缓存、数据库、spool 等）
    
- `/proc`：进程/内核信息的“伪文件系统”（例如 `/proc/cpuinfo`）
    
- `/sys`：设备/驱动/内核对象信息（sysfs）
    
- `/run`：运行时状态（PID、socket 等，通常是 tmpfs）
    
- `/root`：root 用户的家目录（不是 `/home/root`）

-----
# 二、文件及其元数据

每个文件均对应一个inode（索引节点），它是由文件系统中唯一数值编址，该数值称为inode编号（或称inode号，inode number）。inode既是位于UNIX式的文件系统的物理对象，也是在Linux内核数据结构描述的概念实体。inode存储了与文件有关的元数据，例如文件的访问权限、最后访问时间戳、所有者、用户组、大小以及文件数据的存储位置。 

 **可以使用ls命令的-i选项来获取一个文件的inode编号：

```shell
“$ ls -i
1689459 Kconfig
1689461 main.c
1680144 process.c
1689464 swsusp.c
1680137 Makefile
1680141 pm. c
1680145 smp.c
1680149 user. c
1680138 console.c
1689462 power.h
1689463 snapshot.c
1689460 disk.c
1680143 poweroff.c 
1680147 swap.c
```
以上输出结果表示，比如文件disk.c的inode编号是1689460。在该文件系统中，不会有其他任何文件拥有该inode编号。但在不同的文件系统中，不能保证inode编号完全相同。

-----
# 三、stat一组API
## 1) `struct stat` 结构体代码（你要的“代码给出来”）

注意：**字段顺序/填充字节会因架构/ABI 不同而略有变化**，真实定义以你系统的 `<sys/stat.h>` 为准；下面是 Linux 上最常见的“典型字段集合/语义版”（足够写题、写项目）。[Debian Manpages+1](https://manpages.debian.org/stretch/manpages-dev/newfstatat.2.en.html)

```C
#include <sys/types.h>
#include <sys/stat.h>
#include <time.h>

struct stat {
    dev_t     st_dev;      // 文件所在文件系统的设备号
    ino_t     st_ino;      // inode 号（文件“身份”）
    mode_t    st_mode;     // 文件类型 + 权限位（最重要）
    nlink_t   st_nlink;    // 硬链接计数
    uid_t     st_uid;      // 所有者用户 ID
    gid_t     st_gid;      // 所属组 ID
    dev_t     st_rdev;     // 若是设备文件，表示该设备的设备号（主/次设备号）
    off_t     st_size;     // 文件大小（字节）
    blksize_t st_blksize;  // 建议的 I/O 块大小（性能相关）
    blkcnt_t  st_blocks;   // 已分配的块数量（通常以 512B 为单位）

    struct timespec st_atim; // 最后访问时间（读）
    struct timespec st_mtim; // 最后修改内容时间（写内容）
    struct timespec st_ctim; // 最后状态改变时间（改权限/所有者等元数据）
};

/* 兼容宏：很多系统还会提供 st_atime/st_mtime/st_ctime（秒级） */
```


> 另外一个重要提醒：`stat()` 返回的不同字段可能不是同一瞬间的“完全一致快照”（并发修改时可能混杂新旧字段），这是 man page 明确提醒过的。[man7.org](https://man7.org/linux/man-pages/man2/stat.2.html)

---

## 2) `stat / lstat / fstat` 三者到底差在哪？

它们都“把文件信息填进 `struct stat`”，区别在**你用什么定位文件、是否跟随符号链接**：

### 2.1 `int stat(const char *path, struct stat *buf);`

- **按路径查**
    
- 如果 `path` 是 **符号链接**：`stat` 会**跟随**它，返回“链接指向的目标文件”的信息（典型语义）。[man7.org](https://man7.org/linux/man-pages/man2/stat.2.html)
    

### 2.2 `int lstat(const char *path, struct stat *buf);`

- **按路径查**
    
- 如果 `path` 是 **符号链接**：`lstat` **不跟随**，返回“链接本身”的信息（类型会是 symlink，`st_size` 往往是链接字符串长度）。[man7.org+1](https://man7.org/linux/man-pages/man2/stat.2.html)
    

### 2.3 `int fstat(int fd, struct stat *buf);`

- **按文件描述符 fd 查**
    
- 不再进行路径解析（更适合 `open()` 之后做校验，避免一些竞态/替换）。[man7.org](https://man7.org/linux/man-pages/man2/stat.2.html)
    

---

## 3) 返回值与 errno

- 成功：返回 **0**
    
- 失败：返回 **-1**，并设置 `errno`（比如 `ENOENT/EACCES/ENOTDIR/ELOOP/EBADF` 等）[man7.org](https://man7.org/linux/man-pages/man2/stat.2.html)
    

---

## 4) `struct stat` 字段逐个讲透（系统编程常用）

### 4.1 `st_mode`：文件类型 + 权限（最核心）

它包含两部分：

#### A) 文件类型（一定用宏判断）

```C
S_ISREG(st.st_mode)  // 普通文件
S_ISDIR(st.st_mode)  // 目录
S_ISLNK(st.st_mode)  // 符号链接
S_ISCHR(st.st_mode)  // 字符设备
S_ISBLK(st.st_mode)  // 块设备
S_ISFIFO(st.st_mode) // 管道
S_ISSOCK(st.st_mode) // 套接字
```

这些类型编码/宏是 POSIX 在 `<sys/stat.h>` 里要求提供的核心内容。[Ubuntu Manpages](https://manpages.ubuntu.com/manpages/bionic/man7/sys_stat.h.7posix.html)

#### B) 权限位（rwx）

```C
st.st_mode & S_IRUSR  // owner read
st.st_mode & S_IWUSR  // owner write
st.st_mode & S_IXUSR  // owner exec
// group: S_IRGRP/S_IWGRP/S_IXGRP
// other: S_IROTH/S_IWOTH/S_IXOTH
```

还有三种特殊位你以后一定会碰到：

- `S_ISUID`：setuid
    
- `S_ISGID`：setgid
    
- `S_ISVTX`：sticky（/tmp 常用）
    

---

### 4.2 `st_size`：大小（字节）

- 普通文件：文件内容长度
    
- 符号链接：**链接文本长度**（`lstat` 下尤其明显）[Ubuntu Manpages+1](https://manpages.ubuntu.com/manpages/jammy/en/man2/stat.2.html)
    

---

### 4.3 `st_blocks / st_blksize`

- `st_blksize`：建议的高效 I/O 块大小（性能提示）。[Ubuntu Manpages+1](https://manpages.ubuntu.com/manpages/jammy/en/man2/stat.2.html)
    
- `st_blocks`：已分配块数量（通常以 **512B** 为单位），所以它可能 **小于 `st_size/512`**（稀疏文件有洞）。[Ubuntu Manpages](https://manpages.ubuntu.com/manpages/jammy/en/man2/stat.2.html)
    

---

### 4.4 `st_ino` + `st_dev`：定位文件“身份”

- `st_ino` 是 inode 号
    
- `st_dev` 是所在设备（文件系统）ID  
    二者组合可在系统内唯一标识一个文件（POSIX 也提到这一点）。[Ubuntu Manpages](https://manpages.ubuntu.com/manpages/bionic/man7/sys_stat.h.7posix.html)
    

---

### 4.5 `st_nlink`：硬链接数

- 有多少目录项（硬链接）指向同一个 inode。[Ubuntu Manpages+1](https://manpages.ubuntu.com/manpages/jammy/en/man2/stat.2.html)
    

---

### 4.6 `st_uid / st_gid`

- 文件所有者 UID / 组 GID。[Ubuntu Manpages+1](https://manpages.ubuntu.com/manpages/jammy/en/man2/stat.2.html)  
    常配合 `getpwuid()` / `getgrgid()` 转成人类可读名字（模拟 `ls -l`）。
    

---

### 4.7 `st_rdev`

- 只有当文件是字符/块设备文件时才有意义：表示这个设备的设备号。[Ubuntu Manpages+1](https://manpages.ubuntu.com/manpages/jammy/en/man2/stat.2.html)
    

---

### 4.8 三个时间：`st_atim / st_mtim / st_ctim`

- `st_atim`：最后访问（读）[Ubuntu Manpages+1](https://manpages.ubuntu.com/manpages/jammy/en/man2/stat.2.html)
    
- `st_mtim`：最后修改内容（写内容）[Ubuntu Manpages+1](https://manpages.ubuntu.com/manpages/jammy/en/man2/stat.2.html)
    
- `st_ctim`：最后状态改变（改权限/所有者/链接数等 inode 元数据）  
    **注意：ctime 不是创建时间**。[Ubuntu Manpages+1](https://manpages.ubuntu.com/manpages/jammy/en/man2/stat.2.html)
    

---

## 5) 实战代码：能区分普通文件/目录/符号链接（并演示 stat vs lstat）

```C
#include <sys/stat.h>
#include <stdio.h>
#include <unistd.h>

static void show_type(const struct stat* st) {
    if (S_ISREG(st->st_mode)) puts("type: regular");
    else if (S_ISDIR(st->st_mode)) puts("type: directory");
    else if (S_ISLNK(st->st_mode)) puts("type: symlink");
    else if (S_ISCHR(st->st_mode)) puts("type: char device");
    else if (S_ISBLK(st->st_mode)) puts("type: block device");
    else if (S_ISFIFO(st->st_mode)) puts("type: fifo");
    else if (S_ISSOCK(st->st_mode)) puts("type: socket");
    else puts("type: unknown");
}

int main(int argc, char** argv) {
    if (argc != 2) return 1;
    const char* path = argv[1];

    struct stat a, b;

    if (lstat(path, &a) == -1) { perror("lstat"); return 1; }
    if (stat(path, &b) == -1)  { perror("stat");  return 1; }

    puts("[lstat] (link itself if symlink)");
    show_type(&a);
    printf("size=%lld\n\n", (long long)a.st_size);

    puts("[stat] (follow symlink)");
    show_type(&b);
    printf("size=%lld\n", (long long)b.st_size);

    return 0;
}
```

当 `path` 是符号链接时，你会看到：

- `lstat` 给你 `type: symlink`
    
- `stat` 给你目标文件的类型  
    这正是两者语义差异。[man7.org+1](https://man7.org/linux/man-pages/man2/stat.2.html)
    

---

## 6) 系统编程里最重要的一个“安全/竞态点”

很多同学会写：

`stat(path, &st); open(path, ...);`

这在某些场景会有 **TOCTOU**（检查与使用之间被替换）风险。更稳的习惯是：

- 先 `open()`，再用 `fstat(fd, &st)` 去验证你打开的到底是什么。


-----
# 四、权限
## chmod / fchmod 用来干什么？
chmod()和fchmod()都可以把文件权限设置为参数mode指定的值。对于chmod()方法，参数path表示需要修改的文件的相对或绝对路径名。对于fchmod()方法，文件是由文件描述符fd给定。
它们用于修改文件的 **mode bits**：主要是

- **权限位** `rwx`（owner/group/other）
    
- 以及 **SUID/SGID/sticky** 位（`S_ISUID/S_ISGID/S_ISVTX`）

函数签名：
- **chmod：
```C
int chmod(const char *path, mode_t mode);
```

- 按 **路径 path** 修改权限
    
- 如果 `path` 是符号链接：会 **跟随符号链接**，改的是“目标文件”的权限（解引用 symlink）

- **fchmod：
```C
int fchmod(int fd, mode_t mode);
```

- 按 **文件描述符 fd** 修改权限（通常你 `open()` 之后拿到 fd）
    
- 不涉及再次路径解析，更适合“先打开再校验/修改”的写法
## 2) 返回值是什么？

对 `chmod / fchmod / fchmodat` 都一样：

- 成功：返回 **0**
    
- 失败：返回 **-1**，并设置 `errno`

### `mode`（最关键）

`mode` 是一个 **位掩码（bit mask）**，通常用**八进制**写（很重要！）：

- 常见权限：`0644`、`0755`、`0600` …
    
- 也可以用宏 OR 起来：`S_IRUSR | S_IWUSR | S_IRGRP | ...` [man7.org](https://man7.org/linux/man-pages/man2/chmod.2.html)
    

`mode` 能包含：

- `S_IRUSR/S_IWUSR/S_IXUSR`：owner 的 rwx
    
- `S_IRGRP/...`：group 的 rwx
    
- `S_IROTH/...`：other 的 rwx
    
- 以及 `S_ISUID/S_ISGID/S_ISVTX` [man7.org](https://man7.org/linux/man-pages/man2/chmod.2.html)
    

> 注意：你传的 `mode` 是“你想设成的权限位集合”，不是“增量修改”。  
> 若想在原有基础上加/减权限，先 `stat()` 读 `st_mode`，再按位操作后 `chmod()`。

## 4) 常见错误码（errno）

`chmod/fchmod` 常见会遇到： [man7.org](https://man7.org/linux/man-pages/man2/chmod.2.html)

- `EACCES`：路径某级目录没有搜索权限
    
- `ENOENT`：文件不存在
    
- `ENOTDIR`：路径中某一段不是目录
    
- `ELOOP`：符号链接解析循环太多
    
- `EROFS`：只读文件系统
    
- `EPERM`：没权限修改（不是文件 owner 且无特权能力）
    
- `EBADF`：`fchmod(fd, ...)` 的 fd 无效

## 5) 权限能不能随便改？（权限检查规则）

一般要求：

- 调用进程的有效 UID 必须是文件 owner，或进程具备相应特权（Linux 用 capability 表达，比如 `CAP_FOWNER`） [man7.org](https://man7.org/linux/man-pages/man2/chmod.2.html)
    
- 还有一些安全规则：例如在某些情况下 SGID 位可能被内核自动清掉（不一定报错）

## 如果我真的把 euid 变成 0 了，能不能 `chmod` 改别的 UID 的文件权限？

**一般来说可以。**  
Linux 的权限检查背后是 capabilities：当 euid=0（传统 root）时通常拥有 `CAP_FOWNER` / `CAP_DAC_OVERRIDE` 等能力，因此可以对**不属于自己的文件**执行 `chmod`（以及很多原本不允许的访问）。

但注意几个“你是 root 也不一定能改”的限制：

### A. 文件系统/挂载限制

- **只读文件系统**：会报 `EROFS`
    
- 某些挂载选项、网络文件系统策略可能限制（比如 **NFS root_squash**：远端把 root 映射成 nobody，root 也改不了）
    

### B. 文件的不可变属性

- 如果文件被 `chattr +i` 设成 **immutable**，即使 root 直接 `chmod` 也会失败（通常 `EPERM`）。要先去掉 immutable。
    

### C. 你“看似是 root”，但能力不一定还在

- 如果进程被主动 **drop capabilities**（比如用 `prctl`/容器运行时配置），即使 euid=0 也可能不再有绕过权限的能力。
    
- 在 **user namespace** 里，“namespace 内的 root”对宿主机文件未必有权限。
    

### D. `chmod` 只改传统 mode bits，不等于所有安全策略都放行

- **ACL（setfacl）**、**SELinux/AppArmor** 等可能仍然限制访问；你改了 mode 不代表一定能按你想要的方式访问（尤其是 ACL/安全模块参与判定时）。

----
# 五、所有权

**函数原型：
```C
#include <unistd.h>

int chown (const char *path, uid_t owner, gid_t group);
int fchown(int fd,          uid_t owner, gid_t group);
int lchown(const char *path, uid_t owner, gid_t group);

```
### 1)作用是什么？

这三个函数都是**修改文件的属主(owner)和属组(group)**（也就是把文件的 `st_uid / st_gid` 改掉）。它们的区别**只在于“你用什么方式指定那个文件”**。
### 2) 三者区别（重点：符号链接）

### `chown(path, owner, group)`

- 按**路径**改属主/属组
    
- 如果 `path` 是**符号链接**：会**跟随链接**（修改“链接指向的目标文件”）。[man7.org](https://man7.org/linux/man-pages/man2/lchown.2.html)
    

### `lchown(path, owner, group)`

- 按**路径**改属主/属组
    
- 但**不跟随符号链接**：如果 `path` 是 symlink，改的是**链接本身**（link inode），不是目标。[man7.org+1](https://man7.org/linux/man-pages/man2/lchown.2.html)
    

### `fchown(fd, owner, group)`

- 按**文件描述符 fd** 改属主/属组（你 `open()` 之后拿到的 fd）。[man7.org](https://man7.org/linux/man-pages/man2/lchown.2.html)
    

> 记忆：`chown` 跟随 symlink；`lchown` 改 symlink 本身；`fchown` 对 fd 指向的文件生效。


### 3) 返回值代表什么？

- 成功：返回 **0**
    
- 失败：返回 **-1** 并设置 `errno` 指明原因。

- **设置errno：

EACCES 调用进程缺少对路径path中某一目录的搜索权限（仅适用于chown()和lchown()）。 
 EBADF fd非法（仅适用于fchown()）。 
 EFAULT path非法（仅适用于chown()和lchown()）。 
 EIO 发生内部I/O错误（这很严重）。 
 ELOOP 内核在解析path时遇到太多符号链接（仅适用于chown()和lchown()）。 
 ENAMETOOLONG path太长（仅适用于chown()和lchown()）)。 
 ENOENT 文件不存在。 
 ENOMEM 剩余内存不足，无法完成请求。 
 ENOTDIR 路径path中的某部分不是目录（仅适用于chown()和lchown()）。 
 EPERM 调用的进程缺少必要的权限，无法按要求改变所有者或所属组。 
 EROFS文件系统只可读。
 
 ---
### 4) 参数分别代表什么？

### `path`

要操作的路径。

### `fd`

要操作的“已打开文件”的文件描述符。

### `owner` / `group`

要设置的新 UID/GID。

**特殊规则：传 `-1` 表示“不修改这一项”**：

- `owner == (uid_t)-1` → 不改 owner
    
- `group == (gid_t)-1` → 不改 group [man7.org](https://man7.org/linux/man-pages/man2/lchown.2.html)
    

> 注意：`uid_t/gid_t` 通常是无符号类型，所以代码里一般写 `(uid_t)-1` / `(gid_t)-1` 更严谨。

## 5）什么时候用哪个？（工程决策）

- **用 chmod**：你要调整访问策略（谁可读/写/执行）
    
    - 例如：日志 640、私钥 600、脚本 755
        
- **用 chown**：你要把文件交给某个用户/服务账号管理
    
    - 例如：`/var/www` 交给 `www-data`，让 Web 服务写
        
    - 例如：安装程序把配置文件改给某服务用户
        

常见组合就是：

- `chown service:service file`
    
- `chmod 640 file`  
    一起用：既指定“谁负责”，又指定“允许做什么”。

----
## 六、扩展属性

扩展属性（Extended attributes）”也称作xattrs，提供一种把文件与键/值对相关联的机制。本章中，我们已经讨论了各种与文件关联的键/值元数据的情况：文件大小，所有者，最后修改时间戳等等。扩展属性支持已有文件系统支持最初设计中未实现的新特性，例如出于安全目的的强制访问控制。扩展属性的很有趣的一点在于用户空间的应用可能任意创建和读写键/值对。

- **扩展属性是与文件系统无关的**，这是指应用程序可以使用标准接口操作它们，接口对所有的文件系统都没有区别。因此，应用程序在使用扩展属性时无需考虑文件所在的文件系统，或文件系统如何内部存储键与值。

- **但是，扩展属性的实现是与文件系统相关的。** 不同的文件系统以不同的方式存储扩展属性，但内核隐藏了这些差别，把它们从扩展属性接口抽象出来。

- **每个扩展属性都对应一个唯一的键（key）。** 键必须是合法的UTF-8字符。它们采用namespace.attribute的形式。每一个键都必须包含完整的名称，也就是说，它必须以有效的命名空间开头，并接着一个句点。一个有效的键名的例子是user.mime_type，该键的命名空间是user，属性名是mime_type。 

Linux对键的数目，键的长度，值的大小，或被与文件相关联的所有键与值消耗的空间大小上都没有任何限制。但在文件系统上却有实际的限制。这些限制通常体现在与给定文件相关联的所有键与值的总长度上。

---
# 扩展的属性命名空间 
 
 与扩展属性相关联的命名空间不仅仅是组织文件的工具。依赖于命名空间，内核可以执行不同访问策略。
  
 Linux当前定义四种扩展属性命名空间，将来可能会定义更多。目前分别有以下四种扩展： 
 **system ：
 - 命名空间system通常利用扩展属性实现内核特性，例如访问控制列表（ACLs）。在命名空间的扩展属性的一个例子是 system.posix_acl_access。无论用户是读取这些属性还是写入这些属性，都依赖于相应位置的安全模块。最糟糕的情况是，没有用户（包括root）可以读取这些属性。 
 **security ：
 - 命名空间security通常实现安全模块，例如SELinux。用户空间应用程序访问这些属性也依赖于相应位置的安全模块。默认情况下，所有进程能读取这些属性，但只有具有CAP_SYS_ADMIN权限的进程能写入它们。 
 **trusted：
 - 命名空间trusted存储用户空间限制的信息。只有具有CAP_SYS_ADMIN权限的进程能读写这些属性。
**user ：
 - 命名空间user是普通进程所使用的标准命名空间。内核通过普通的文件权限位来控制访问该命名空间。为了从已有的键中读取值，进程必须具有给定文件的读权限。要创建一个新键，或者向已有的键写入值，进程必须具有给定文件的写权限。在用户命名空间只能对普通文件指派扩展属性，符号链接或设备文件则不可以。当设计一个能使用扩展属性的用户空间应用程序时，命名空间正是你所需要采用的。

---
## 1）扩展属性长什么样？

可以把它理解成：

- `name`：字符串键（例如 `user.comment`）
    
- `value`：一段字节数组（可存文本/二进制）
    

例如给文件加一个备注：

- `user.comment = "hello"`
    

---

## 3）它用来干嘛？（典型用途）

- **SELinux/AppArmor 安全标签**：常见在 `security.*`
    
- **POSIX ACL**：很多实现把 ACL 存在 `system.posix_acl_access`/`system.posix_acl_default`
    
- **文件 capabilities**：例如给可执行文件设置“无需 root 也能 bind 低端口”的能力，通常存为 `security.capability`
    
- 应用自定义元数据：比如备份软件、索引器给文件打 tag（放 `user.*`）

[[扩展属性]]
----

