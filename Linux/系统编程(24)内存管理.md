
# 一、进程地址空间

像所有的现代操作系统一样，Linux将它的物理内存虚拟化。进程并不能直接在物理内存上寻址，而是由Linux内核为每个进程维护一个特殊的虚拟地址空间（virtual address space）。这个地址空间是线性的，从0开始，一直到某个最大值。

## 1.2页面调度
内存是由比特位组成，**8个比特组成一个字节。** **字节又组成字，字组成页。** 对于内存管理，页是最重要的：**页是内存管理单元（MMU）可以管理的最小可访问内存单元。** 因此，虚拟空间是由许多页组成的。系统的体系结构以及机型决定了页的大小（页的大小是固定的），典型的页大小包括4K（32位系统）和8K（64位系统）。 

 - 32位地址空间包含约一百万的4KB的页。
 - 而64位的地址空间包含数倍的8KB的页。
 
 一个进程不可能访问所有这些页，这些页可能并没有任何含义。因此，页有两种状态：
- **有效的（valid）：** 一个有效页（valid page）和实际的数据页相关联，可能是物理内存（RAM），也可能是二级存储介质，比如交换分区或硬盘上的文件。
- **无效的（invalid）：** 一个无效页（invalid page）没有任何含义，表示它没有被分配或使用。访问一个无效的页会引发一个段错误。 
 地址空间不需要是连续的。虽然是线性编址，但实际上中间有很多未编址的小区域。
 
 如果一个有效的页和二级存储的数据相关，进程不能访问该页，除非把这个页和物理内存中的数据关联。如果一个进程要访问这样的页，那么存储器管理单元（MMU）会产生页错误（page fault）。然后，内核会介入，把数据从二级存储切换到物理内存中（paging in），而且对用户“透明”。由于虚拟内存要比物理内存大得多，内核可能需要把数据从内存中切换出来，从而为后面要Page in的页腾出更多空间。因而，内核也需要把数据从物理内存切换到二级存储，这个过程称为Paging out。为了优化性能，实现后续page in操作代价最低，内核往往是把物理内存中近期最不可能使用的页替换出来。 

-----

## 1.2共享和写时复制

“虚拟内存中的多个页面，甚至是属于不同进程的虚拟地址空间，也有可能会映射到同一个物理页面。通过这种方式，可以支持不同的虚拟地址空间共享物理内存上的数据。举个例子，在某个时刻，系统中的很多进程很可能是使用标准C库。有了共享内存，这些进程可以把库映射到它们的虚拟地址空间，但是在物理内存中只存在一个进程。举个更明显的例子，两个进程可能会映射到大数据库的内存中。虽然这两个进程的数据库都在其虚拟地址空间中，它们只存在于RAM中。 


 共享的数据可能是只读的，只写的，或者可读可写的。当一个进程试图写某个共享的可写页时，可能发生以下两种情况之一。最简单的是内核允许写操作，在这种场景下，所有共享这个页的进程都将看到这次写操作的结果。通常，允许大量的进程对同一页面读写需要某种程度上的合作和同步机制。但是在内核级别，写操作“正常工作”，共享数据的所有进程会立即看到修改。

在另一种情况场景下，内存管理单元（MMU）会拦截这次写操作，并产生一个异常。内核会相应地“透明”创建一份该页的拷贝，支持继续对新的页面执行写操作。我们将这种方法称为“写时拷贝（copy-on-write）（COW）”。实际上，允许进程读取共享的数据，这样可以有效节省空间。当一个进程想要写一个共享页面时，可以立刻获得该页的唯一拷贝，这使得内核工作起来就像每个进程都始终有它自己的私有拷贝。写时拷贝是以页为单位进行的，通过这种方式，多个进程可以高效共享一个大文件。每个进程只有在对共享页写时才能获得一份新的拷贝。

-----

## 1.3内存区域

内核将具有某些相同特征的页组织成块（blocks），例如读写权限。这些块叫作内存区域（memory regions），段（segments），或者映射（mappings）。下面是一些在每个进程都可以见到的内存区域： 

  - **文本段（text segment）** 包含着一个进程的代码、字符串、常量和一些只读数据。在Linux中，文本段被标记为只读，并且直接从目标文件（可执行程序或是库文件）映射到内存中。  
   
   - **堆栈段（stack）** 包括一个进程的执行栈，随着栈的深度变化会动态伸长或收缩。执行栈中包括了程序的局部变量（local variables）和函数的返回值。  
   
   - **数据段（data segment）**，又叫堆（heap），包含一个进程的动态内存空间。这个段是可写的，而且它的大小是可以变化的。这部分空间往往是由malloc分配的（这将会在下一节讨论）。  
   - **BSS段“bss segment）** 包含了没有被初始化的全局变量。根据不同的C标准，这些变量包含特殊的值（通常来说，这些值都是0）。  
  
 Linux从两个方面优化这些变量。首先，因为附加段是用来存放没有被初始化的数据，所以链接器（ld）实际上并不会将特殊的值存储在对象文件中。这样，可以减少二进制文件的大小。其次，当这个段被加载到内存时，内核只需根据写时复制的原则，简单地将它们映射到一个全是0的页上，通过这种方式，可以高效地把这些变量设置成初始值。 
 
 大多数地址空间包含很多映射文件，比如可执行文件执行自己的代码、C和其他的共享库和数据文件。可以看看/proc/self/maps，或者pmap程序的输出，我们能看到一个进程里面有很多映像文件。
 
---
## 1.4动态内存分配

## 从内核视角：进程拿到的是“虚拟地址”，不是直接物理内存

进程看到的地址空间是**虚拟内存**。内核用页表把虚拟页映射到物理页，并用**缺页异常**按需分配/装入页面。

所以很多时候：

- `malloc` 返回一个地址 **并不代表立刻有物理页**
    
- 直到你第一次写那块内存，才可能触发缺页，真正分到物理页（“按需分页 / lazy allocation”）


## 1) `malloc`

### 签名

```C
#include <stdlib.h>
void *malloc(size_t size);
```

### 作用

向堆申请 `size` 字节的连续内存，**内容不初始化**（里面是“旧数据”）。

### 返回值

- 成功：返回指向新内存块的指针（类型 `void*`）
    
- 失败：返回 `NULL`（并不保证设置 errno）
    

### 要点/坑

- `malloc(0)`：标准允许返回 `NULL` 或一个“可用于 free 的唯一指针”；别依赖其返回值。
    
- 返回的指针满足适当对齐（能放任何类型）。
    
- 用完必须 `free`，否则内存泄漏。
    
## 2) `malloc` 的底层：分配器 + 向内核要大块内存

`malloc` 本身不是系统调用，它是 **用户态内存分配器**：

### 2.1 分配器内部在做什么

分配器维护一些数据结构（自由链表/桶 bins）来管理“堆上的块（chunk）”：

- 每次 `malloc(n)`：
    
    1. 把 `n` **向上对齐**（alignment）并加上管理开销（chunk header）
        
    2. 去对应大小的 bin 里找一块空闲 chunk
        
    3. 找到就切一块给你（可能把剩余部分拆分成新的空闲块）
        
    4. 找不到就向“更大池子”要内存
        
- 每次 `free(p)`：
    
    1. 通过 `p` 找到它前面的 chunk 元数据（大小、标志位等）
        
    2. 把 chunk 放回对应 bin
        
    3. 可能尝试与前后空闲块**合并（coalesce）**减少碎片
        

你可以把内存想成这样（简化示意）：

```CSS
[ chunk hdr | 用户数据 ... ] [ chunk hdr | 用户数据 ... ] ...
             ^ malloc 返回的指针 p 指向这里
```

> 这也解释了：`free(p + 1)` 为什么是未定义行为——分配器找不到正确的 chunk 头。
### 2.2 分配器怎么向内核“要更多内存”

常见两条路：

1. **brk/sbrk 扩展 “heap 段”**（传统堆）
    
    - 内核把进程的 heap 末尾往高地址“推大”一段
        
    - 适合中小块、频繁分配
        
2. **mmap 映射匿名内存**（通常用于大块）
    
    - 直接得到一段独立映射区
        
    - 释放时更可能 `munmap` 还给内核
        

典型策略（概念上）：

- **小/中等分配**：从 heap（brk）切
    
- **大分配**：走 mmap 单独映射（阈值由实现决定

---

## 2) `calloc`

### 签名

```C
#include <stdlib.h>
void *calloc(size_t nmemb, size_t size);
```

### 作用

申请 `nmemb * size` 字节，并把**整个块清零**（全 0）。

### 返回值

同 `malloc`：成功返回指针，失败返回 `NULL`。

### 要点/坑

- `calloc` 通常会做**乘法溢出检查**（比你手写 `nmemb*size` 更安全）。
    
- “清零”不等于“全部类型都等于 0 的语义”在极少数场景有差异，但对 C 的整数/指针/浮点在常规平台上可视为 0 值。
    

---

## 3) `realloc`

### 签名

```C
#include <stdlib.h>
void *realloc(void *ptr, size_t size);
```

### 作用

把 `ptr` 指向的旧块调整为 `size` 字节，可能：

- 原地扩展/缩小（地址不变）
    
- 或者分配新块、拷贝旧内容、释放旧块（地址变化）
    

旧内容的保留规则：

- 保留 `min(old_size, new_size)` 字节
    
- 扩展出来的新区域内容**不初始化**
    

### 返回值与关键语义（最容易考）

- 成功：返回新指针（可能等于 ptr，也可能不同）
    
- 失败：返回 `NULL`，**并且旧指针 ptr 仍然有效、旧内存块不会被释放**
    
    - 所以千万别写 `p = realloc(p, newsize);` 然后不检查就用 p ——失败会丢失旧指针导致泄漏。
        

特殊情况：

- `realloc(NULL, size)` 等价于 `malloc(size)`
    
- `realloc(ptr, 0)`：等价于 `free(ptr)` 并返回 `NULL` 或可 free 的指针（别依赖）
    

**正确写法：**

```C
void *tmp = realloc(p, newsize);
if (!tmp) { /* 失败：p 仍可用 */ }
else p = tmp;
```

## 6) `realloc` 底层到底怎么扩容/缩容

`realloc(p, newsize)` 通常有三种结果：

1. **原地缩小**：
    
    - 分配器可能把尾部切下来做成新的空闲块（split）
        
2. **原地扩展**（理想情况，快）：
    
    - 如果 `p` 后面紧邻的 chunk 正好是空闲的，并且足够大
        
    - 分配器可直接“吃掉后面的空闲块”，指针不变
        
3. **搬家**（最常见的扩容情况）：
    
    - 分配新块 `q = malloc(newsize)`
        
    - `memcpy(q, p, min(old,new))`
        
    - `free(p)`
        
    - 返回 `q`
        

> 这就是为什么 `realloc` 扩容可能是 O(n) 拷贝，性能敏感场景会倾向“增长策略”（比如容量翻倍）减少 realloc 次数。


---

## 4) `free`

### 签名

`#include <stdlib.h> void free(void *ptr);`

### 作用

释放由 `malloc/calloc/realloc` 获得的内存块。

### 要点/坑

- `free(NULL)`：安全，什么也不做。
    
- **不能 double free**：同一个指针 free 两次是未定义行为（可能崩溃/安全漏洞）。
    
- **不能 free 非堆指针**：例如栈上地址、全局数组、`malloc` 中间偏移过的指针（必须 free 原始返回值）。
    
- `free` 后指针变成悬空（dangling pointer），建议马上 `ptr = NULL;`
## 4) 碎片：为什么“free 了也不见得省内存”

两类碎片：

- **内部碎片**：你要 33 字节，分配器按对齐/桶给了 48 字节，多出来的浪费在块内
    
- **外部碎片**：空闲块被切得零碎，虽然总空闲很多，但没有足够大的连续块满足一次大分配
    
- `free()` 的直接效果通常只是“把块交还给分配器”，而不是“把内存立刻还给操作系统”。  
而碎片会让这些被 free 的块**很难拼成一整段可归还（或可复用到你想要的形状）的内存**，于是进程的 RSS/占用看起来就降不下来。


这也是为什么某些工作负载用 jemalloc/tcmalloc 会比默认 allocator 更稳（它们在多线程/碎片控制上策略不同）。

------
## 1.5 对齐

数据对齐（alignment）是指数据在内存中的存储排列方式。如果内存地址A是2的n次幂的整数倍，我们就说A是n字节对齐。处理器、内存子系统以及系统中的其他组件都有特定的对齐需求。举个例子，大多数处理器的工作单位是字，只能访问字对齐的内存地址。同样，正如前面所讨论的，内存管理单元也只处理页对齐的地址。 

 如果一个变量的内存地址是它大小的整数倍时，就称为“自然对齐（naturally aligned）”。例如，对于一个32位长的变量，如果它的地址是4（字节）的整数倍（也就是说，如果地址的低两位是0），那就是自然对齐了。因此，如果一个类型的大小是2n字节，那么它的内存地址至少低n位是0。 
 
 数据对齐的规则是依赖于硬件的，因此不同系统的对齐规则不同。有些体系的计算机在数据对齐方面有很严格的要求，而有的很松散。当数据不对齐时，有的系统会生成一个可捕捉的错误。内核可以选择终止该进程或（更多情况下是）手工处理没有对齐的访问（通常通过多个对齐访问完成）。这种处理方式会引起性能下降，但至少进程不会终止。在编写可移植的代码的时候，编程人员一定要注意不要破坏了数据对齐规则。

## 预对齐内存的分配 

 在大多数情况下，编译器和C库会自动处理对齐问题。POSIX规定通过malloc()、calloc()和realloc()返回的内存空间对于C中的标准类型都应该是**对齐的。
 
 在Linux中，这些函数返回的地址在32位系统是以8字节为边界对齐，在64位系统是以16字节为边界对齐的。 
 
 有时，编程人员需要动态分配更大的内存，如页。虽然有很多不同的目的，最常见的需求是要对直接块I/O或其他软硬件通信的缓冲区对齐。为此，POSIX 1003.1d提供了posix_memalign()函数：
- 函数签名、头文件：
```C
#include <stdlib.h>

int posix_memalign(void **memptr, size_t alignment, size_t size);
```

调用成功时，会返回size字节的动态内存，并保证是按照alignment进行对齐的。参数alignment必须是2的整数幂，并且是void指针大小的整数倍。返回的内存块的地址保存在memptr里，函数调用返回0。

### 2) 参数含义

- `memptr`：输出参数。成功时，`*memptr` 会被设置为新分配的内存首地址。
    
- `alignment`：对齐要求（字节数）。
    
    - **必须是 2 的幂**（power of two）
        
    - **并且必须是 `sizeof(void*)` 的倍数**
        
    - 常见：16、32、64、4096（页对齐）
        
- `size`：要分配的字节数（可以不是对齐的倍数；但实际返回地址会满足对齐）
    

---

### 3) 返回值（重点：它不返回 NULL）

- 成功：返回 `0`，并让 `*memptr` 指向内存
    
- 失败：返回错误码（**不是 -1**，也**不一定设置 errno**），常见：
    
    - `EINVAL`：`alignment` 不合法
        
    - `ENOMEM`：内存不足
        
- 失败时：`*memptr` 的值**未定义**（别用）
    

释放：用普通 `free(*memptr)` 即可。

实例：
```C
#include <stdlib.h>
#include <stdalign.h>   // C11: alignof

struct S { double x; int y; };

int main() {
    struct S *ps = NULL;

    // 请求至少满足该类型对齐；你也可以请求更大，比如 64
    size_t A = 64; // 或 alignof(struct S)
    if (posix_memalign((void**)&ps, A, sizeof(*ps)) != 0) return 1;

    ps->x = 1.0;
    free(ps);
}
```


----
## 数据段管理

UNIX系统在曾经提供过直接管理数据段的接口。
但是，由于malloc()和其他分配机制更强大且易于使用，大多数程序都不会直接使用到这些接口。

**在这里提到这些接口是为了满足少数读者的好奇心，同时也为那些想自己实现基于堆的动态分配机制提供一些帮助：

## 1) program break 是什么

一个进程的虚拟地址空间里，堆通常从 `end`（BSS/数据段之后）开始向高地址增长。  
**program break** 就是“当前堆允许使用的最高边界”（堆顶/堆末尾）。

- **把 break 往高地址推**：堆变大（可以容纳更多动态内存）
    
- **把 break 往低地址拉**：堆变小（把尾部的一段堆空间还给内核）
    

---

## 2) brk 做什么

### `int brk(void *addr);`

- 作用：**把 program break 直接设置为 `addr`**（准确说：尝试设置到那个地址附近的合法边界）
    
- 成功：返回 `0`
    
- 失败：返回 `-1` 并设置 `errno`（如 `ENOMEM`）
    

它更“绝对”：你给一个目标地址，它尝试把堆顶设到那里。

---

## 3) sbrk 做什么

### `void *sbrk(intptr_t increment);`

- 作用：**把 program break 增加/减少 `increment` 字节**
    
    - `increment > 0`：扩堆
        
    - `increment < 0`：缩堆
        
    - `increment == 0`：不改，只是**返回当前 break**
        
- 返回值：
    
    - 成功：返回**调用前的 break 地址**
        
    - 失败：返回 `(void*)-1` 并设置 `errno`
        

它更“相对”：给一个增量，向上/向下挪。

---

## 4) 和 malloc/free 的关系（你最该记住的）

- 早期 `malloc` 常用 `sbrk` 向内核要一大块堆，然后在用户态自己切分管理。
    
- 现代 glibc 等分配器通常是：
    
    - **小块**：可能来自 `brk/sbrk` 管的“堆区”
        
    - **大块**：更常直接用 `mmap` 单独映射（便于释放回内核、减少碎片）
        
- `free()` **不一定**会把内存“还给内核”，很多时候只是把块放回 allocator 的空闲链表；只有当空闲块位于堆顶、满足策略条件时，allocator 才可能通过 `brk` 把 break 往回收缩。
    

---

## 5) 为什么现在不推荐直接用 brk/sbrk

- **线程安全/并发**：多线程下自己用 `sbrk` 很容易和 `malloc` 冲突（两者都会改 break）
    
- **碎片与回收困难**：堆是“顶端连续增长”的模型，非顶端空洞很难还给内核
    
- **可移植性/现代特性**：很多系统/运行库更偏向 `mmap` 等机制
    
- 在 Linux 手册里它们也常被标注为**历史接口**，应用层一般别直接用
    

---

## 6) 一个直观例子（理解返回值）

- `p = sbrk(0)`：拿到当前堆顶地址 `p`
    
- `q = sbrk(4096)`：扩 4KB，返回的是“扩之前”的堆顶（也就是 `p`）
    
- 此时新 break 大约是 `p + 4096`

-----
# 内存映射
[[系统编程(8) 内存映射]]

---

