在 Unix/Linux 里，“退出码（exit status）”本质上是进程结束时给父进程/Shell 的一个整数，但有两点要先记住：

1. **程序可以 `exit(code)` 传任意 int**，但父进程用 `wait()/waitpid()` 解析时，**通常只保留低 8 位**（也就是 0–255）。
    
2. **只有“正常退出”才有退出码**；如果是“被信号杀死”，父进程要用 `WIFSIGNALED/WTERMSIG` 看信号，而不是看 `WEXITSTATUS`。
    

---

## 退出码的取值范围

- 实际可见范围：**0–255**（低 8 位）
    
- 例如你 `exit(300)`，Shell/父进程通常看到的是 `300 % 256 = 44`
    

---

## 通用约定（最常用）

- **0**：成功（OK）
    
- **非 0**：失败（具体含义由程序/约定决定）
    

C 标准库还给了两个宏：

- `EXIT_SUCCESS`（通常是 0）
    
- `EXIT_FAILURE`（通常是 1，但标准只保证“非 0”）
    

---

## Shell 里非常常见的一些“事实标准”

这些不是语言强制，但在 Linux/Unix 命令行里非常常见：

- **1**：通用错误（很多程序遇到未分类错误就返回 1）
    
- **2**：Shell 内建命令用法错误（bash 常见）
    
- **126**：找到了命令但“不能执行”（权限不够、不是可执行文件等）
    
- **127**：命令找不到（PATH 里没有）
    
- **128 + N**：进程被信号 N 终止时，Shell 常用这种方式报告
    
    - **130 = 128 + 2**：SIGINT（Ctrl+C）
        
    - **137 = 128 + 9**：SIGKILL（kill -9）
        
    - **139 = 128 + 11**：SIGSEGV（段错误）
        

注意：`128+N` 这类是 **Shell 的表示习惯**；在 `waitpid` 里你应当用 `WTERMSIG(status)` 直接拿到信号号 N。

---

## 另一套更“规范化”的约定：`sysexits.h`（可选）

很多系统提供 `sysexits.h`（历史上来自 BSD），给出一组“更语义化”的退出码，常见范围是 **64–78**，例如：

- 64：命令行用法错误
    
- 65：数据格式错误
    
- 66：输入文件不存在
    
- 67：用户不存在
    
- 69：服务不可用
    
- 70：内部软件错误  
    （不同系统/项目使用程度不一，但写工具程序时挺好用。）
    

---

## 实战建议

- **自己写程序**：
    
    - 成功就 `return 0;`
        
    - 失败就选少量固定码（如 1/2/3…）或用 `sysexits.h` 这一套
        
- **父进程回收子进程**：先判断是正常退出还是信号终止：
    
    - 正常退出：`WIFEXITED` + `WEXITSTATUS`
        
    - 信号终止：`WIFSIGNALED` + `WTERMSIG`