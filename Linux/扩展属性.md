# Linux xattr API 全量详解（不省略版）

> 你要求“别省略”，下面按系统编程的写法把 **每一组 API 的作用、完整原型、参数语义、flags 语义、返回值、典型 errno、缓冲区格式、并发与重试、symlink 语义、fd 语义、安全建议** 全部讲清楚，并给出可直接抄的示例代码。

---

## 0. xattr（扩展属性）快速定位

- xattr = extended attributes：文件/目录（以及某些情况下符号链接）附加的 **name → value** 元数据。
- `name` 是 C 字符串，通常带命名空间前缀：`user.*` / `security.*` / `system.*` / `trusted.*`。
- `value` 是任意字节序列（不一定是字符串），长度由 `size` 指定。

### 0.1 命名空间与权限（你写程序必须考虑）
- `user.*`：最常给应用存自定义标签；普通用户通常可对**自己拥有且有权限**的文件读写（但受文件系统/挂载选项影响）。
- `security.*`：安全相关（SELinux label、file capabilities 等），通常需要特权。
- `system.*`：系统内部（ACL 常在这里），通常需要特权或由内核/工具管理。
- `trusted.*`：一般仅特权可访问。

> 不同文件系统、挂载选项可能导致普通用户写 `user.*` 也失败（例如返回 `EOPNOTSUPP`/`EPERM`）。

---

## 1. 三套变体：path / lpath / fd（所有 xattr API 都遵循）

### 1.1 `xxx(path, ...)`：按路径
- 通过 `path` 解析到目标 inode。
- **若 path 是符号链接**：通常会“跟随 symlink”（对目标文件操作）。

### 1.2 `lxxx(path, ...)`：按路径但不跟随 symlink
- `l*` = link itself。
- **若 path 是符号链接**：对**链接本身**（symlink inode）操作。

### 1.3 `fxxx(fd, ...)`：按文件描述符
- `f*` = file descriptor。
- 不再做路径解析，直接对 fd 引用的对象操作。
- **系统编程安全建议**：涉及安全/权限校验的场景优先用 `f*`，减少 TOCTOU（路径被替换）风险。

---

## 2. 头文件与链接

### 2.1 需要的头文件
```c
#include <sys/types.h>
#include <sys/xattr.h>
```

### 2.2 返回类型
- `set/remove`：`int`
- `get/list`：`ssize_t`（因为要返回字节数，且需要能返回 -1）

---

## 3. setxattr / lsetxattr / fsetxattr —— 写入/更新属性

### 3.1 原型（完整）
```c
int setxattr (const char *path, const char *name,
             const void *value, size_t size, int flags);

int lsetxattr(const char *path, const char *name,
             const void *value, size_t size, int flags);

int fsetxattr(int fd, const char *name,
             const void *value, size_t size, int flags);
```

### 3.2 作用
- 在目标对象上设置名为 `name` 的 xattr 值为 `value`（长度 `size`）。
- 可选择：
  - 创建或覆盖
  - 只创建
  - 只替换

### 3.3 参数语义（逐项不省略）
- `path`：目标路径。
- `fd`：目标文件描述符。
- `name`：属性名。
  - 必须是合法 C 字符串。
  - 通常必须带命名空间前缀（例如 `user.comment`），不同系统对不带前缀的名字会拒绝。
- `value`：指向要写入的数据。
  - 可以是文本，也可以是结构体序列化后的二进制。
  - **允许 `value` 为 NULL 吗？**：一般不建议；“空值”通常用 `size=0` 且 `value` 指向任意非空指针/或 NULL（不同实现细节），工程上若要“清空”，更推荐 `removexattr`。
- `size`：写入数据字节数。
- `flags`：行为控制（重点）。

### 3.4 flags（重点，不省略）
- `0`：若属性不存在则创建；若存在则覆盖。
- `XATTR_CREATE`：**仅创建**。
  - 若属性已存在：失败，`errno=EEXIST`。
  - 用途：实现“只在第一次写入成功，避免覆盖别人写的值”。
- `XATTR_REPLACE`：**仅替换**。
  - 若属性不存在：失败，`errno=ENODATA`。
  - 用途：实现“只更新已有属性，避免无意创建”。

> `XATTR_CREATE` 和 `XATTR_REPLACE` 通常不能同时设置；若同时设置一般会 `EINVAL`。

### 3.5 返回值
- 成功：`0`
- 失败：`-1`，并设置 `errno`

### 3.6 常见 errno（按你写程序最常碰到的列）
- `EOPNOTSUPP`：文件系统不支持 xattr。
- `EPERM` / `EACCES`：无权限写该属性（命名空间受限、无写权限、LSM 策略等）。
- `EEXIST`：使用 `XATTR_CREATE` 但属性已存在。
- `ENODATA`：使用 `XATTR_REPLACE` 但属性不存在。
- `EINVAL`：name/flags 不合法（例如同时 CREATE+REPLACE）。
- `ENOSPC`：空间不足（xattr 存储配额/ inode 扩展空间不足）。
- `ERANGE`：属性值过大（超过 FS 支持的最大值）。
- `ENOENT` / `ENOTDIR`：路径解析失败。

---

## 4. getxattr / lgetxattr / fgetxattr —— 读取属性值

### 4.1 原型
```c
ssize_t getxattr (const char *path, const char *name,
                 void *value, size_t size);

ssize_t lgetxattr(const char *path, const char *name,
                 void *value, size_t size);

ssize_t fgetxattr(int fd, const char *name,
                 void *value, size_t size);
```

### 4.2 作用
读取名为 `name` 的属性值到 `value` 缓冲区。

### 4.3 参数语义
- `name`：要读取的属性名。
- `value`：输出缓冲区指针。
  - **如果 `value == NULL` 且 `size == 0`**：不读内容，仅返回该属性值需要的字节数（非常常用）。
- `size`：缓冲区大小。

### 4.4 返回值（不省略）
- 成功：返回**属性值的字节数**（`ssize_t`，记作 N）
  - 如果你提供的 `size >= N`，则把 N 字节拷贝到 `value`。
  - 如果你提供的 `size < N`，失败并置 `errno=ERANGE`。
- 失败：返回 `-1` 并置 `errno`。

### 4.5 典型“两次调用模式”（必须掌握）
因为你通常不知道值多大：

```c
ssize_t n = getxattr(path, name, NULL, 0);
if (n == -1) { /* handle */ }
void *buf = malloc((size_t)n);
ssize_t m = getxattr(path, name, buf, (size_t)n);
```

### 4.6 并发与重试（你要求不省略，就讲透）
两次调用之间，其他线程/进程可能修改了该 xattr：
- 第一次得到 n
- 第二次读时值变大 → `ERANGE`

工程写法：循环重试：

```c
for (;;) {
    ssize_t n = getxattr(path, name, NULL, 0);
    if (n < 0) return -1;
    void *buf = malloc((size_t)n);
    ssize_t m = getxattr(path, name, buf, (size_t)n);
    if (m >= 0) { /* success */ break; }
    free(buf);
    if (errno != ERANGE) return -1;
}
```

### 4.7 常见 errno
- `ENODATA`：属性不存在。
- `ERANGE`：buffer 太小。
- `EOPNOTSUPP`：不支持。
- `EPERM/EACCES`：无权限读取该 namespace。
- `ENOENT/ENOTDIR/ELOOP`：路径解析问题（path 版本）。

---

## 5. listxattr / llistxattr / flistxattr —— 列出所有属性名

### 5.1 原型
```c
ssize_t listxattr (const char *path, char *list, size_t size);
ssize_t llistxattr(const char *path, char *list, size_t size);
ssize_t flistxattr(int fd, char *list, size_t size);
```

### 5.2 作用
列出目标对象的所有 xattr 名字。

### 5.3 参数语义
- `list`：输出缓冲区（可为 NULL）。
- `size`：缓冲区大小。
  - 若 `list==NULL` 且 `size==0`：仅返回所需字节数（推荐做法）。

### 5.4 返回值
- 成功：返回写入（或所需）的**总字节数**（`ssize_t`，记作 **L**）
- 失败：-1 并设置 `errno`

### 5.5 list 缓冲区格式（非常关键，不省略）
返回的不是数组，不是带长度结构体，而是：
- 多个 `\0` 结尾的字符串拼接
- 末尾也以 `\0` 结束

例：
```
user.comment\0security.selinux\0system.posix_acl_access\0
```

### 5.6 遍历方法（正确且常用）
```c
for (char *p = list; p < list + L; p += strlen(p) + 1) {
    printf("%s\n", p);
}
```

### 5.7 并发与重试
与 get 一样，两次调用之间属性集合可能变化，导致第二次 `ERANGE`。
工程上同样用循环重试。

### 5.8 常见 errno
- `EOPNOTSUPP`：不支持。
- `ERANGE`：buffer 太小。
- `EPERM/EACCES`：权限问题。

---

## 6. removexattr / lremovexattr / fremovexattr —— 删除属性

### 6.1 原型
```c
int removexattr (const char *path, const char *name);
int lremovexattr(const char *path, const char *name);
int fremovexattr(int fd, const char *name);
```

### 6.2 作用
删除名为 `name` 的 xattr。

### 6.3 参数语义
- `name`：要删除的属性名。

### 6.4 返回值
- 成功：0
- 失败：-1 并设置 `errno`

### 6.5 常见 errno
- `ENODATA`：属性不存在。
- `EPERM/EACCES`：无权限。
- `EOPNOTSUPP`：不支持。

---

## 7. 选择哪个版本：path vs lpath vs fd（场景化总结）

### 7.1 需要对“目标文件”操作（跟随 symlink）
- 用 `setxattr/getxattr/listxattr/removexattr`

### 7.2 需要对“符号链接本身”操作
- 用 `lsetxattr/lgetxattr/llistxattr/lremovexattr`

### 7.3 安全/避免路径竞态（TOCTOU）或你已经 open 了文件
- 用 `fsetxattr/fgetxattr/flistxattr/fremovexattr`

---

## 8. 完整示例：写入→读取→列出→删除（含重试，偏工程级）

```c
#include <sys/xattr.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>

static void die(const char *msg) {
    perror(msg);
    exit(1);
}

static void *xmalloc(size_t n) {
    void *p = malloc(n);
    if (!p) { fprintf(stderr, "malloc failed\n"); exit(1); }
    return p;
}

static ssize_t getxattr_retry(const char *path, const char *name, void **out) {
    for (;;) {
        ssize_t n = getxattr(path, name, NULL, 0);
        if (n < 0) return -1;
        void *buf = xmalloc((size_t)n + 1); // +1 方便当字符串打印
        ssize_t m = getxattr(path, name, buf, (size_t)n);
        if (m >= 0) {
            ((char*)buf)[m] = '\0';
            *out = buf;
            return m;
        }
        free(buf);
        if (errno != ERANGE) return -1;
    }
}

static ssize_t listxattr_retry(const char *path, char **out) {
    for (;;) {
        ssize_t n = listxattr(path, NULL, 0);
        if (n < 0) return -1;
        char *buf = (char*)xmalloc((size_t)n);
        ssize_t m = listxattr(path, buf, (size_t)n);
        if (m >= 0) {
            *out = buf;
            return m;
        }
        free(buf);
        if (errno != ERANGE) return -1;
    }
}

int main() {
    const char *path = "a.txt";
    const char *name = "user.comment";
    const char *val  = "hello xattr";

    // 1) set: 覆盖或创建
    if (setxattr(path, name, val, strlen(val), 0) == -1) {
        die("setxattr");
    }

    // 2) get
    void *v = NULL;
    ssize_t vlen = getxattr_retry(path, name, &v);
    if (vlen < 0) die("getxattr");
    printf("%s=%s (len=%zd)\n", name, (char*)v, vlen);
    free(v);

    // 3) list
    char *list = NULL;
    ssize_t llen = listxattr_retry(path, &list);
    if (llen < 0) die("listxattr");

    printf("xattr list:\n");
    for (char *p = list; p < list + llen; p += strlen(p) + 1) {
        printf("  %s\n", p);
    }
    free(list);

    // 4) remove
    if (removexattr(path, name) == -1) {
        die("removexattr");
    }

    return 0;
}
```

---

## 9. 关键对照表（完全版）

|类别|path 版本（跟随 symlink）|l* 版本（不跟随）|f* 版本（fd）|返回值|
|---|---|---|---|---|
|写|setxattr|lsetxattr|fsetxattr|0 / -1|
|读|getxattr|lgetxattr|fgetxattr|字节数 / -1|
|列名|listxattr|llistxattr|flistxattr|字节数 / -1|
|删除|removexattr|lremovexattr|fremovexattr|0 / -1|

---

## 10. 高频考点（总结你要能复述的）

1) xattr 是 name→value；value 是字节数组。
2) `get/list` 返回的是字节数，用 `ssize_t`。
3) 典型模式：`value/list=NULL,size=0` 先取大小，再分配再读。
4) `listxattr` 的缓冲区是多个 `\0` 结尾字符串拼接。
5) `l*` 作用于符号链接本身，非目标。
6) `f*` 作用于 fd，安全（减少 TOCTOU）。
7) `setxattr` 的 flags：0 / `XATTR_CREATE` / `XATTR_REPLACE`。
8) 并发下两次调用可能 `ERANGE`，工程用循环重试。

如果你还想继续：我可以把 ACL/capability/SELinux 的 xattr 名字与实际效果（例如 `security.capability` 如何让非 root 绑定低端口）用一个实验步骤串起来。

