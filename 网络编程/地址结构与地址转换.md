# 模块 3：地址结构 & 地址转换详解

> 目标：搞懂各种 `sockaddr*` 结构体的意义，熟练使用 `inet_pton/inet_ntop` 等地址转换函数，并理解如何在代码中正确地在“字符串 IP ↔ 二进制 IP ↔ 结构体”之间来回转换。

---

## 一、为什么需要地址结构？

网络编程本质上就是：

> 把“我要跟谁通信”（IP + 端口）描述清楚，交给内核去联系对方。

C 接口里不直接用“字符串 IP + 整数端口”，而是用一系列 **地址结构体** 来描述：

- 通用结构：`struct sockaddr`
- IPv4 专用：`struct sockaddr_in`
- IPv6 专用：`struct sockaddr_in6`
- IP 地址本体：`struct in_addr`（IPv4）、`struct in6_addr`（IPv6）

很多 socket 函数（`bind`, `connect`, `accept`, `getsockname`, `getpeername`）统一使用 `struct sockaddr *` 作为参数，是为了做 **多协议兼容**：

- IPv4 / IPv6 / Unix 域 socket 都可以通过 `sockaddr*` 传进去。

---

## 二、通用地址结构：`struct sockaddr`

这是最基础的抽象，定义大致如下（不同平台略有差异）：

```c
struct sockaddr {
    sa_family_t sa_family;  // 地址族，例如 AF_INET, AF_INET6
    char        sa_data[14];
};
```

- `sa_family_t sa_family`：地址族（Address Family）
  - `AF_INET`  ：IPv4
  - `AF_INET6` ：IPv6
  - 还有 `AF_UNIX` 等
- `sa_data[14]`：存放具体的地址数据（端口+IP 等），但布局比较“黑盒”。

**实际开发中：几乎不直接用 `sockaddr` 的 `sa_data` 字段，而是使用更具体的结构（`sockaddr_in` 等），等到真正调用 socket API 时，再强制转换为 `(struct sockaddr*)`。**

---

## 三、IPv4 地址结构：`struct sockaddr_in` & `struct in_addr`

### 3.1 `struct in_addr`（IPv4 地址本体）

IPv4 地址本质上就是一个 32 位整数，通常用 `struct in_addr` 表示：

```c
struct in_addr {
    in_addr_t s_addr; // 32 位，网络字节序
};
```

- `s_addr` 内部存放的是 **网络字节序** 的 IPv4 地址（大端）。
- 例如 `127.0.0.1` 可以存成 `0x7F000001`（再按大端顺序摆放）。

### 3.2 `struct sockaddr_in`（IPv4 套接字地址）

```c
struct sockaddr_in {
    sa_family_t    sin_family; // 地址族，AF_INET
    in_port_t      sin_port;   // 端口号（16 位，网络字节序）
    struct in_addr sin_addr;   // IPv4 地址（网络字节序）
    // 还可能有一些填充字段（sin_zero）
};
```

常用字段：

- `sin_family`：必须设为 `AF_INET`，表示是一个 IPv4 地址
- `sin_port`：端口号
  - 类型通常是 `uint16_t` / `in_port_t`
  - **必须用 `htons` 转成网络字节序后再赋值**
- `sin_addr`：IPv4 地址结构体
  - 内部 `s_addr` 是网络字节序
  - 通常通过 `inet_pton` / `inet_aton` 等函数设置

示例：

```c
struct sockaddr_in addr;

addr.sin_family = AF_INET;
addr.sin_port   = htons(8080);  // 主机序 8080 → 网络序

// 把字符串形式的 IP 转成二进制，存到 addr.sin_addr
inet_pton(AF_INET, "127.0.0.1", &addr.sin_addr);
```

---

## 四、IPv6 地址结构：`struct sockaddr_in6` & `struct in6_addr`（了解）

IPv6 地址是 128 位（16 字节），对应结构：

```c
struct in6_addr {
    unsigned char s6_addr[16]; // 128 位的地址
};

struct sockaddr_in6 {
    sa_family_t     sin6_family;   // AF_INET6
    in_port_t       sin6_port;     // 端口号（16 位，网络字节序）
    uint32_t        sin6_flowinfo; // 流信息（一般不用）
    struct in6_addr sin6_addr;     // IPv6 地址
    uint32_t        sin6_scope_id; // 作用域 ID（多网卡时使用）
};
```

用法与 IPv4 类似，只是地址族为 `AF_INET6`，地址字段为 128 位。

```c
struct sockaddr_in6 addr6;
addr6.sin6_family = AF_INET6;
addr6.sin6_port   = htons(8080);
inet_pton(AF_INET6, "2001:db8::1", &addr6.sin6_addr);
```

网络编程入门阶段，重点掌握 IPv4 即可；理解 IPv6 结构有利于今后写“同时支持 IPv4/IPv6”的程序。

---

## 五、`socklen_t`：长度参数类型

很多 socket 系统调用都需要传入“结构体长度”，使用类型 `socklen_t`：

常见用例：

```c
struct sockaddr_in addr;
socklen_t addrlen = sizeof(addr);

bind(sockfd, (struct sockaddr*)&addr, addrlen);

struct sockaddr_in cliaddr;
addrlen = sizeof(cliaddr);
int connfd = accept(sockfd, (struct sockaddr*)&cliaddr, &addrlen);
```

- `addrlen` 通常先设为 `sizeof(struct sockaddr_in)`，调用后可能被修改（例如 `accept` 实际返回的结构大小）。
- `socklen_t` 是为了跨平台统一长度类型，避免直接用 `int` 或 `unsigned int` 带来的不兼容。

---

## 六、地址转换函数：`inet_pton / inet_ntop`（推荐）

### 6.1 `inet_pton` —— 字符串 → 二进制（Presentation to Network）

```c
#include <arpa/inet.h>

int inet_pton(int af, const char *src, void *dst);
```

- `af`：地址族
  - `AF_INET`  → 解析 IPv4：`src` 例如 `"192.168.1.1"`，`dst` 指向 `struct in_addr`
  - `AF_INET6` → 解析 IPv6：`src` 例如 `"2001:db8::1"`，`dst` 指向 `struct in6_addr`
- `src`：字符串 IP
- `dst`：输出的二进制地址（网络字节序）

返回值：

- 1  → 成功
- 0  → `src` 不是有效的 IP 字符串
- -1 → 出错，并设置 `errno`

**IPv4 示例：**

```c
struct sockaddr_in addr;
addr.sin_family = AF_INET;
addr.sin_port   = htons(8080);

if (inet_pton(AF_INET, "127.0.0.1", &addr.sin_addr) <= 0) {
    perror("inet_pton");
}
```

### 6.2 `inet_ntop` —— 二进制 → 字符串（Network to Presentation）

```c
const char *inet_ntop(int af,
                      const void *src,
                      char *dst,
                      socklen_t size);
```

- `af`：地址族（`AF_INET` / `AF_INET6`）
- `src`：二进制 IP 地址指针
  - IPv4：`&addr.sin_addr`（`struct in_addr *`）
  - IPv6：`&addr6.sin6_addr`（`struct in6_addr *`）
- `dst`：用于存放结果字符串的缓冲区
- `size`：`dst` 的大小
  - IPv4：使用 `INET_ADDRSTRLEN`（一般 16）
  - IPv6：使用 `INET6_ADDRSTRLEN`（一般 46）

返回值：

- 成功：返回 `dst` 指针
- 失败：返回 `NULL`，并设置 `errno`

**常见用法：打印客户端 IP**

```c
struct sockaddr_in cli;
socklen_t len = sizeof(cli);
int cfd = accept(lfd, (struct sockaddr*)&cli, &len);

char ip[INET_ADDRSTRLEN];
if (inet_ntop(AF_INET, &cli.sin_addr, ip, sizeof(ip)) == NULL) {
    perror("inet_ntop");
} else {
    printf("client = %s:%u\n", ip, ntohs(cli.sin_port));
}
```

---

## 七、旧接口：`inet_aton / inet_ntoa / inet_addr`（知道即可）

这些是早期 BSD 风格的 IPv4 专用接口：

### 7.1 `inet_aton`

```c
int inet_aton(const char *cp, struct in_addr *inp);
```

- `cp`：字符串形式 IP
- `inp`：输出二进制 IPv4 地址（网络序）
- 返回值：非 0 表示成功；0 表示失败

大致等价于：`inet_pton(AF_INET, cp, inp)`。

### 7.2 `inet_addr`

```c
in_addr_t inet_addr(const char *cp);
```

- 返回二进制 IPv4 地址，但它把 `-1` 作为错误标志，这和合法 IP `255.255.255.255` 冲突 → 不推荐。

### 7.3 `inet_ntoa`

```c
char *inet_ntoa(struct in_addr in);
```

- 功能类似于 `inet_ntop(AF_INET, ...)`，但只支持 IPv4。
- 返回指向 **静态内部缓冲区** 的 `char *`：
  - 多线程环境不安全；
  - 多次调用会覆盖之前的结果。

**现代代码推荐：统一用 `inet_pton / inet_ntop`，同时支持 IPv4 和 IPv6，线程安全，可控缓冲区大小。**

---

## 八、本机/对端地址查询：`getsockname` / `getpeername`

有时候，你只拿着一个已连接的 socket fd，却不知道：

- 本端绑定的是哪个 IP:Port？
- 对端的 IP:Port 是什么？

可以用：

```c
int getsockname(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
int getpeername(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
```

- `getsockname`：获取本端地址
- `getpeername`：获取对端地址

使用示例（IPv4）：

```c
struct sockaddr_in local, peer;
socklen_t len;

len = sizeof(local);
getsockname(fd, (struct sockaddr*)&local, &len);

len = sizeof(peer);
getpeername(fd, (struct sockaddr*)&peer, &len);

char lip[INET_ADDRSTRLEN], pip[INET_ADDRSTRLEN];
inet_ntop(AF_INET, &local.sin_addr, lip, sizeof(lip));
inet_ntop(AF_INET, &peer.sin_addr,  pip, sizeof(pip));

printf("local: %s:%u\n", lip, ntohs(local.sin_port));
printf("peer:  %s:%u\n", pip, ntohs(peer.sin_port));
```

这两个函数在调试和实现复杂代理/隧道时很有用。

---

## 九、建议练习：字符串 IP + 端口 → sockaddr_in → 再打印回字符串

综合练习题：

> 写一个小程序，从命令行读取 `IP` 和 `端口`，
> - 使用 `inet_pton` + `htons` 写入 `sockaddr_in`；
> - 再用 `inet_ntop` + `ntohs` 把这一结构还原回字符串并打印。

示例代码：

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <arpa/inet.h>

int main(int argc, char *argv[]) {
    if (argc != 3) {
        fprintf(stderr, "Usage: %s <IP> <Port>\n", argv[0]);
        return 1;
    }

    const char *ip_str = argv[1];
    int port_int = atoi(argv[2]);

    struct sockaddr_in addr;
    memset(&addr, 0, sizeof(addr));

    addr.sin_family = AF_INET;
    addr.sin_port   = htons((uint16_t)port_int);

    if (inet_pton(AF_INET, ip_str, &addr.sin_addr) <= 0) {
        perror("inet_pton");
        return 1;
    }

    // ====== 还原打印 ======
    char ip_buf[INET_ADDRSTRLEN];
    if (inet_ntop(AF_INET, &addr.sin_addr, ip_buf, sizeof(ip_buf)) == NULL) {
        perror("inet_ntop");
        return 1;
    }

    printf("Stored sockaddr_in: IP=%s, Port=%u\n",
           ip_buf, (unsigned)ntohs(addr.sin_port));

    return 0;
}
```

你可以尝试：

1. 运行：`./a.out 127.0.0.1 8080`
2. 改成 `192.168.1.100 9000` 再试
3. 尝试在程序中打印 `addr.sin_addr.s_addr` 的十六进制值，结合 `htonl` 理解字节序。

---

## 十、小结

1. `sockaddr` 是通用抽象，实际开发中通常用更具体的 `sockaddr_in` / `sockaddr_in6`。
2. IPv4 地址通过 `sockaddr_in` 表示：
   - `sin_family = AF_INET`
   - `sin_port` 用 `htons` 转为网络序
   - `sin_addr` 用 `inet_pton` 填写
3. 地址转换函数：
   - 推荐：`inet_pton` / `inet_ntop`，支持 IPv4 + IPv6，线程安全
   - 旧接口：`inet_aton` / `inet_ntoa` / `inet_addr`，只需了解
4. `getsockname` / `getpeername` 可用于查询本端和对端的 IP:Port。
5. 通过“小工具练习题”把 **字符串 IP ↔ 结构体 ↔ 字符串 IP** 的来回转换练熟，是后续所有网络编程的基础。

