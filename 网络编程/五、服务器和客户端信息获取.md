### 字节序
字节序是由于不同的操作系统和处理器，对大于一个字节的变量在内存中的存放顺序不同而造成的。字节序通常由两种：
- **大端字节序**
- **小端字节序**

#### 大端字节序和小端字节序
##### 大端序（Big Endian）

### 规则

👉 **高位字节放在低地址**

更符合“人类阅读顺序”。

### 示例
```C++
uint32_t x = 0x12345678;
```
内存布局（低地址 → 高地址）：
```C++
地址:   +0   +1   +2   +3
内容:  12   34   56   78    //78才是第一位
```

##### 小端序（Little Endian）

### 规则

👉 **低位字节放在低地址**

现代 PC / x86 / x64 默认。

### 示例

```C++
uint32_t x = 0x12345678;
```

内存布局：

```C++
地址:   +0   +1   +2   +3
内容:  78   56   34   12  //78是第一位
```

------
### 字节序转换函数
由于主机千差万别，主机的字节序不能做到统一，所以需要一个统一的标识方法。通常，小端字节序的系统通过网络传输数据时需要进行字节序转换，大端字节序通常不需要这种转换。

**1.字节序转换函数**
 1. 四个函数一览表（必背）

|函数|全称|方向|位数|
|---|---|---|---|
|`htons`|host to network short|主机 → 网络|16 位|
|`htonl`|host to network long|主机 → 网络|32 位|
|`ntohs`|network to host short|网络 → 主机|16 位|
|`ntohl`|network to host long|网络 → 主机|32 位|

📌 **网络字节序 = 大端序**
 2. 函数原型
```C++
#include <arpa/inet.h>

uint16_t htons(uint16_t hostshort);
uint32_t htonl(uint32_t hostlong);

uint16_t ntohs(uint16_t netshort);
uint32_t ntohl(uint32_t netlong);
```
----
### 字符串IP地址和二进制IP地址的转换
## . 两种 IP 地址形式是什么？

### （1）字符串 IP 地址（人能看懂）

```C++
"192.168.1.1"
"127.0.0.1"
"8.8.8.8"
```

- 类型：`char *`
    
- 用途：
    
    - 配置文件
        
    - 命令行参数
        
    - 日志打印
        

---

### （2）二进制 IP 地址（机器用）

```C++
struct in_addr {
    uint32_t s_addr;   // 网络字节序
};
```

- 本质：**32 位整数（IPv4）**
    
- **必须是网络字节序（大端）**
    
- 用途：
    
    - `connect`
        
    - `bind`
        
    - `sendto`
        

---

## 2. 核心转换函数（必会）

### ✅ 现代、推荐方式（支持 IPv4 / IPv6）

#### `inet_pton`（字符串 → 二进制）

```C++
#include <arpa/inet.h>

int inet_pton(int af, const char *src, void *dst);
```

- `af`：`AF_INET` 或 `AF_INET6`
    
- `src`：字符串 IP
    
- `dst`：二进制地址缓冲区
    

返回值：

- `1`：成功
    
- `0`：IP 字符串非法
    
- `-1`：错误（如 `af` 不支持）
    

---

#### `inet_ntop`（二进制 → 字符串）

```C++
const char *inet_ntop(int af,
                      const void *src,
                      char *dst,
                      socklen_t size);
```

- `dst`：保存结果的字符串缓冲区
    
- `size`：缓冲区大小（如 `INET_ADDRSTRLEN`）
    

---

## 3. IPv4 转换示例（最常用）

### 字符串 → 二进制

```C++
struct sockaddr_in addr;
memset(&addr, 0, sizeof(addr));
addr.sin_family = AF_INET;
addr.sin_port   = htons(8080);
inet_pton(AF_INET, "192.168.1.100", &addr.sin_addr);
```

📌 注意：

- `inet_pton` **自动生成网络字节序**
    
- 不需要再 `htonl`
    

---

### 二进制 → 字符串

```C++
char ip[INET_ADDRSTRLEN];

inet_ntop(AF_INET,
          &addr.sin_addr,
          ip,
          sizeof(ip));

printf("ip = %s\n", ip);
```

------
#### 套接字描述符判定函数

套接字描述符在形式上与一般文件描述符无异，判断一个文件描述符是不是套接字文件描述符方法是：
- 先用fstat函数将文件描述符与struct stat绑定，获取文件状态
- 将stat的st_mode与模式的S_IFMT做&运算，看是否是S_IFSOCK
**issockettype函数实例**
```C++
int issockettype(int fd){
	struct stat st;
	int err = fstat(fd,&st);
	if(err<0){
	return -1;
	}
	if((st.st_mode & S_IFMT)==S_IFSOCK){
		return 1;
	}else{
		return 0;
	}
}
```

-----
#### IP地址与域名的相互转换

在实际使用中，经常只知道主机的域名而不知道主机对应的ip地址，二socket的API均是基于IP地址的，因此，进行主机域名和IP地址的转换是十分必要的。
**域名解析有两种：**
- **迭代查询：** - 本地 DNS：
    
    - 自己查缓存
        
    - 不命中就：
        
        - 问根 DNS
            
        - 问 TLD DNS
            
        - 问权威 DNS
            
- **直到拿到最终 IP**
    
- 再返回给客户端
- **递归查询**：**DNS 服务器之间**：

- 本地 DNS → 根 DNS
    
- 本地 DNS → TLD DNS
    
- 本地 DNS → 权威 DNS
    

📌 **客户端不会直接进行迭代查询**

------
#### 获取主机信息的函数
**1.gethostbyname()函数**
gethostbyname()函数根据主机名获取主机信息，如www.sina.com.cn，使用gethostbyname("www.sina.com.cn")可以获得主机的信息。该函数的参数name表示要查询的主机名，通常是DNS域名，函数原型如下：
```C++
#include <netdb.h>
extern int h_errno;
struct hostent* gethostbyname(const char* name);
```
gethostbyname的返回值是一个指向hostent结构体的指针，当其为NULL时，表示发生错误，错误类型可以通过errno获得。错误类型如下：
- HOST_NOT_FOUND：查询的主机不可知，查不到相关信息。
- NO_ADDRESS和NO_DATA：请求的名称和法但是没有合适的IP地址。
- NO_RECOVERY：域名服务器不响应。
- TRY——AGAIN：域名服务器当前出现临时性错误，稍后再试。
**hostent结构体**原型如下：
```C++
struct hostent {
    char  *h_name;       // 主机的规范名称（official name）
    char **h_aliases;    // 主机的别名列表（以 NULL 结尾）
    int    h_addrtype;   // 地址类型（AF_INET / AF_INET6）
    int    h_length;     // 地址长度（IPv4: 4 字节）
    char **h_addr_list;  // IP 地址列表（以 NULL 结尾）
#ifdef_USE_MISC
#define h_addr h_addr_list[0]  //向前兼容定义的宏
#endif
};
```
 ip地址可能被解析成多个，所以是一个list，因为需要负载均衡。
**gethostbyaddr()函数**
```C++
#include <betdb.h>
#include <sys/socket.h>
struct hosten* gethostbyaddr(const void *addr,_socklen_t len,int type);
```

gethostbyname与gethostbyaddr函数是不可重人函数，由于传出的值为一块静态的内存地址，当另一次查询到来时，这块区域会被占用，在使用时要小心。安全方法：
```C++
struct hostent *h = gethostbyname("example.com");

struct in_addr addr;
memcpy(&addr, h->h_addr_list[0], h->h_length);
```

**通过主机名获取主机信息实例**
```C++
#include <netdb.h>
#include <string.h>
#include <stdio.h>
#include <arpa/inet.h>
int main(int argc,char* argv[]){
	char host[]="www.sina.com.cn";
	struct hostent* ht=NULL;
	char str[30];
	ht=gethostbyname(host);
	if(ht){
	printf("get host name :%s\n",host);
	printf("name:%s\n",ht->h_name);
	printf("type:%s\n",ht->h_addrtype==AF_INET? "AF_INET" : "AF_INET6");
	printf("length of addr:%d\n",ht->h_length);
	for(int i=0;:i++){
	if(ht->h_addr_list[i]!=NULL){
		inet_ntop(ht->h_addrtype,ht->h_addr_list[i],str,30);
	}else{
	break;
	}
	}
	for(int i=0;;i++){
	if(ht->h_aliases[i]!=NULL){
	printf("name:%s\n",h_aliases[i]);
	}else{
	break;
	}
	}
	}
	return 0;
}
```

------
## 协议名称和处理函数
### 一、为什么要有 `getaddrinfo()`？（动机）

老接口的问题你已经见过了：

|老接口|问题|
|---|---|
|`gethostbyname`|❌ 只支持 IPv4|
|`hostent`|❌ 不可重入|
|`getservbyname`|❌ 分散、接口割裂|
|手工 `sockaddr_in`|❌ 写死 IPv4|

👉 **`getaddrinfo()` 的目标：**

> **一个接口，统一完成：  
> 域名解析 + 服务解析 + 协议族选择 + 地址结构生成**

---

### 二、`getaddrinfo()` 是干嘛的？（一句话）

> **把“主机名 + 服务名”解析成一个可直接用于 `socket / connect / bind` 的地址链表。**

---

### 三、核心函数一览（先有全局感）

|函数|作用|
|---|---|
|`getaddrinfo`|解析地址（核心）|
|`freeaddrinfo`|释放结果|
|`gai_strerror`|错误码转字符串|

---

### 四、`getaddrinfo()` 函数原型

```C++
#include <netdb.h>

int getaddrinfo(const char *node,
                const char *service,
                const struct addrinfo *hints,
                struct addrinfo **res);
```

---

## 1️⃣ 参数逐个解释（非常重要）

### （1）`node` —— 主机名 / IP

可以是：

- 域名：
    
    `"www.example.com"`
    
- 字符串 IP：
    
    `"127.0.0.1"`
    
- `NULL`：
    
    - 常用于服务器 `bind`
        

---

### （2）`service` —— 服务名 / 端口

可以是：

- 服务名：
    
```C++
"http"   // 80
"https"  // 443
```
    
- 端口字符串：
    
    `"8080"`
    
- `NULL`
    

---

### （3）`hints` —— “你想要什么样的结果”

这是 `getaddrinfo` 的“筛选条件”。

常见写法：

```C++
struct addrinfo hints;
memset(&hints, 0, sizeof(hints));

hints.ai_family   = AF_INET;      // IPv4
hints.ai_socktype = SOCK_STREAM;  // TCP
```

常用字段解释👇

---

#### `ai_family`（协议族）

|值|含义|
|---|---|
|`AF_INET`|IPv4|
|`AF_INET6`|IPv6|
|`AF_UNSPEC`|IPv4 + IPv6|

---

#### `ai_socktype`（套接字类型）

|值|含义|
|---|---|
|`SOCK_STREAM`|TCP|
|`SOCK_DGRAM`|UDP|

---

#### `ai_protocol`（协议号）

通常填 `0`，系统自动匹配。

---

#### `ai_flags`（高级控制）

常见：

|flag|作用|
|---|---|
|`AI_PASSIVE`|用于 `bind`|
|`AI_CANONNAME`|返回规范主机名|
|`AI_NUMERICHOST`|node 必须是数字 IP|

---

### （4）`res` —— 输出结果（地址链表）

- 返回：
    
    `struct addrinfo *`
    
- 是一个 **链表**
    
- 每个节点都可以直接用于 `socket + connect`
    

---

# 五、`struct addrinfo` 结构体（重点）

```C++
struct addrinfo {
    int              ai_flags;
    int              ai_family;
    int              ai_socktype;
    int              ai_protocol;
    socklen_t        ai_addrlen;
    struct sockaddr *ai_addr;     // 关键：可直接用
    char            *ai_canonname;
    struct addrinfo *ai_next;     // 链表
};
```

📌 **设计精髓**：

> 你不再关心 `sockaddr_in / sockaddr_in6`，  
> 只把 `ai_addr` 交给 socket 接口。

---

# 六、典型使用流程（模板，必须会）

## 1️⃣ 客户端 `connect`（最常见）

```C++
struct addrinfo hints, *res, *rp;

memset(&hints, 0, sizeof(hints));
hints.ai_family   = AF_UNSPEC;
hints.ai_socktype = SOCK_STREAM;

getaddrinfo("www.example.com", "80", &hints, &res);

for (rp = res; rp != NULL; rp = rp->ai_next) {
    int fd = socket(rp->ai_family,
                    rp->ai_socktype,
                    rp->ai_protocol);
    if (fd == -1)
        continue;

    if (connect(fd, rp->ai_addr, rp->ai_addrlen) == 0)
        break;   // 成功

    close(fd);
}

freeaddrinfo(res);
```

👉 **这段代码就是“多 IP + 多协议族”的正确写法**
```C++
struct addrinfo hint,*res;
memset(&hint,0,sizeof(hint));
hint.ai_family=AF_INET;
hint.ai_socktype=SOCK_STREAM;
getaddrinfo("www.sina.com.cn",&hint,&res);

for(auto rp=res;rp!=NULL;rp=rp->ai_next){
	int fd = socket(rp->ai_family,rp->ai_socktype,rp->ai_protocol);
	if(fd==-1){
	continue;
	}
	if(connect(fd,rp->ai_addr,rp->ai_addrlen)==0){
	break;
	}
	close(fd);
}
freeaddrinfo(res);
```


---

## 2️⃣ 服务器 `bind`

```C++
hints.ai_family   = AF_INET;
hints.ai_socktype = SOCK_STREAM;
hints.ai_flags    = AI_PASSIVE;

getaddrinfo(NULL, "8080", &hints, &res);
```

---

# 七、相关辅助函数

### 1️⃣ `freeaddrinfo`

`void freeaddrinfo(struct addrinfo *res);`

👉 **必须调用**，否则内存泄漏。

---

### 2️⃣ `gai_strerror`

```C++
const char *gai_strerror(int errcode);
```

示例：

```C++
int ret = getaddrinfo(...);
if (ret != 0)
    fprintf(stderr, "%s\n", gai_strerror(ret));
```

---

# 八、和旧接口的对应关系（帮你“断舍离”）

|老接口|新接口|
|---|---|
|`gethostbyname`|`getaddrinfo`|
|`getservbyname`|`getaddrinfo`|
|`hostent`|`addrinfo`|
|IPv4 only|IPv4 + IPv6|
|不可重入|线程安全|

---

# 九、你现在应该形成的“心智模型”

> `getaddrinfo`  
> = DNS 解析
> 
> - 服务解析
>     
> - 协议族选择
>     
> - 地址结构生成
>     
> - 多结果链表
>     

---

# 十、终极一句话总结（面试版）

> `getaddrinfo()` 是现代网络编程推荐的地址解析接口，它统一了主机名和服务名解析，支持 IPv4/IPv6，线程安全，并返回可直接用于 socket 操作的地址链表。



-----
