### 1️⃣【判断题】

基类的 `private` 成员在派生类中**完全不可访问**，但仍然属于派生类对象的一部分。  
是否正确？为什么？
## 1️⃣ 判断题：private 成员不可访问但仍在对象中？

**答案：对。**  
**解析：**

- `private` 只影响**访问权限**，不影响对象布局。
    
- 派生类对象包含一个“基类子对象”，基类的所有非静态数据成员都在其中（包括 private）。  
    **坑：**派生类不能直接访问基类 private，但基类自己的成员函数仍可访问它们。
    

---

### 2️⃣【选择题】

以下哪种继承方式下，**基类的 `public` 成员在派生类中仍是 `public`**？

A. `class D : private B`  
B. `class D : protected B`  
C. `class D : public B`  
D. 都不是

**答案：C（public 继承）。**  
**解析：**

- `public` 继承：基类 `public/protected` 保持 `public/protected`。
    
- `protected` 继承：基类 `public` 变成 `protected`。
    
- `private` 继承：基类 `public/protected` 变成 `private`。
---

### 3️⃣【推理题】

```C++
struct Base {
    int x;
};

struct Derived : Base {
    int y;
};
```

`sizeof(Derived)` 一定等于 `sizeof(Base) + sizeof(int)` 吗？  
请给出**至少两个可能影响结果的因素**。
**答案：不一定。**  
**解析（至少两点）：**

1. **对齐/填充（padding）**：成员可能插入填充字节满足对齐。
    
2. **空基类优化（EBO）**：若 `Base` 为空类（无成员），`sizeof(Derived)` 可能只等于 `sizeof(int)` 或更小增长。  
    （还有：虚函数导致 vptr，虚继承额外开销等。）
---

### 4️⃣【判断 + 解释】

构造派生类对象时，**派生类构造函数一定先执行**。  
对还是错？为什么？
**答案：错。**  
**解析：**构造顺序固定：

1. **基类子对象先构造**
    
2. 再构造派生类成员
    
3. 最后执行派生类构造函数体  
    **原因：**派生类依赖基类处于有效状态。
---

### 5️⃣【简答题】

为什么 C++ 要强制：**基类子对象必须先于派生类构造**？
**答案要点：**

- 派生类成员函数/构造体中可能使用基类部分的状态。
    
- 如果基类未构造就使用，会违反对象生命周期规则。  
    **工程建议：**把“可复用的、不变量”放在基类构造里建立。
---

### 6️⃣【思考题】

如果一个类“只是为了代码复用”，但**不打算通过基类指针使用它**，你还应该用继承吗？  
请从**设计语义**角度回答。
**参考答案：通常不建议，用组合优先。**  
**解析：**

- 继承表达 **is-a** 语义，不只是复用。
    
- 若只是复用实现，组合/委托更清晰，耦合更低。  
    **例外：**CRTP、policy-based design、空基类优化等（偏高级用法）。
---

# 二、访问控制与继承方式（7–11）

### 7️⃣【推理题】

```C++
struct Base {
public:
    int a;
protected:
    int b;
private:
    int c;
};

struct D : public Base {};
```

在 `D` 中，`a / b / c` 的可访问性分别是什么？
- `a`：在 `D` 中仍是 **public**
    
- `b`：在 `D` 中仍是 **protected**
    
- `c`：仍是 **private 于 Base**，`D` 不能访问  
    **关键：**继承方式只影响 `public/protected` 的“映射”，不改变 `private` 的不可访问性。
---

### 8️⃣【判断题】

`protected` 成员可以被**派生类对象**直接访问。  
对还是错？请区分“在成员函数中”和“在对象外部”。
**答案：错（对象外部不能），对（在派生类成员函数里可以）。**  
**解析：**

- `protected` 表示：**派生类的成员函数**可访问。
    
- 但在类外，通过 `d.b` 访问不允许。  
    **常见坑：**`protected` 不是“谁都能用但小心点”，它是严格权限。
---

### 9️⃣【推理题】

```C++
struct B {
public:
    void f();
};

struct D : private B {};
```

在以下场景中，`f()` 是否可访问？

1. 在 `D` 的成员函数中
    
2. 在 `main()` 中通过 `D` 对象
    
3. 在 `main()` 中通过 `B*` 指向 `D`

**答:**
- 在 `D` 的成员函数中：✅ 可访问（因为 B 的 public 变成 D 的 private，但 D 内部能用）
    
- 在 `main()` 中通过 `D` 对象：❌ 不可访问（对外是 private）
    
- 在 `main()` 中通过 `B*` 指向 `D`：❌ 一般也不行，因为**D 不能隐式转换为 B***（private 继承阻止向上转型）  
    **说明：**只有在 `D` 内部或友元里才允许这种转换。
---

### 🔟【设计题】

什么情况下你会**刻意使用 `private` 继承**？  
请给出一个合理的工程场景（不是“因为语法允许”）。
**参考答案：**当你想复用实现，但**不想暴露 is-a 关系**，也不希望外部把派生当基类用。  
**典型场景：**

- 复用基类的某些实现细节（以前常见于“以实现方式继承”）
    
- 但现代更推荐：组合 + 委托；只有少数情况下 private 继承有优势（如 EBO 的空基类作为实现细节）。
---

### 1️⃣1️⃣【判断 + 解释】

`struct` 和 `class` 在继承语义上的**唯一区别**是默认访问控制。  
是否完全正确？
**答案：基本正确，但要说“语法层面”。**  
**解析：**

- 语法上：`struct` 默认成员/继承为 `public`；`class` 默认为 `private`。
    
- 语义/能力上：完全相同。  
    **坑：**规范通常用 `struct` 表示“纯数据/弱封装”，用 `class` 表示“封装/不变量”，这是风格约定，不是语言规则。
---

# 三、虚函数、多态与对象模型（12–18）

### 1️⃣2️⃣【判断题】

只要函数被声明为 `virtual`，就一定会发生**动态绑定**。  
对还是错？举例说明。
**答案：错。**  
**解析：**动态绑定需要通过**多态方式调用**：

- 通过 `Base*` / `Base&` 调用虚函数 → 动态绑定
    
- 通过对象本身（静态类型已知）调用：`b.f()`（b 是 Base 对象）→ 静态绑定  
    **例子：**
```C++
Base b;
b.virtualFunc(); // 静态分派（对象不是指针/引用到派生）
```
**注意：⚠️**
 **触发动态绑定的“三要素”**
只要缺一个，就是静态绑定。必须同时满足：

1. **有继承关系**：存在父类和子类。
    
2. **有虚函数**：父类中函数声明为 `virtual`，且子类进行了重写 (Override)。
    
3. **通过父类指针或引用调用**：使用的是 `Base*` 或 `Base&` 指向子类对象。

代码演示：
```C++
#include <iostream>

class Animal {
public:
    // 1. 父类声明 virtual
    virtual void makeSound() { 
        std::cout << "Animal sound" << std::endl; 
    }
    
    // 普通函数（非虚函数）
    void move() {
        std::cout << "Animal moves" << std::endl;
    }
};

class Dog : public Animal {
public:
    // 2. 子类重写 (Override)
    void makeSound() override { 
        std::cout << "Woof!" << std::endl; 
    }
    
    // 隐藏了父类的 move，但不是重写（因为父类没写 virtual）
    void move() {
        std::cout << "Dog runs" << std::endl;
    }
};

int main() {
    Dog d;
    
    // 3. 通过父类指针指向子类对象
    Animal* ptr = &d; 

    std::cout << "--- 动态绑定 ---" << std::endl;
    // 编译器看到 makeSound 是 virtual，于是去查 ptr 实际指向谁
    // 结果：调用 Dog::makeSound()
    ptr->makeSound(); 

    std::cout << "--- 静态绑定 ---" << std::endl;
    // 编译器看到 move 不是 virtual
    // 哪怕 ptr 指向的是 Dog，编译器只认 ptr 的类型 (Animal*)
    // 结果：调用 Animal::move()
    ptr->move();

    return 0;
}
```
---

### 1️⃣3️⃣【推理题】

```C++
struct Base {
    void f();
};

struct Derived : Base {
    void f();
};
```

通过 `Base*` 调用 `f()`，调用的是哪个版本？为什么？
**答案：调用 `Base::f()`。**  
**解析：*_没有 `virtual` 就没有动态分派；通过 `Base*` 的静态类型决定调用。  
**坑：**这不是 override，而是**隐藏/重定义**（但通过 Base_ 还是 Base::f）。

---

### 1️⃣4️⃣【判断 + 解释】

基类析构函数不声明为 `virtual`，但通过基类指针删除派生类对象，是未定义行为。  
是否正确？

**答案：对。**  
**解析：**  
`delete basePtr;` 需要调用正确的析构链。如果 `Base::~Base` 非 virtual，则只调用 `Base` 析构，派生部分不析构 → 资源泄漏/更严重 UB。  
**工程规则：**只要类可能被当作多态基类使用，就必须有 `virtual ~Base()`。

---

### 1️⃣5️⃣【推理题】

```C++
struct Base {
    virtual void f();
};

struct Derived : Base {
    void f(int);
};
```

`Derived` 是否“重写”了 `Base::f()`？为什么这是一个**常见坑**？
**答案：没有重写。**  
**解析：**签名不同（参数列表不同），这是**名字隐藏（name hiding）**：`Derived::f(int)` 隐藏了 `Base::f()` 的同名集合。  
**坑：**你以为 override 了，但实际没有，多态调用仍走 `Base::f()`。  
**修复：**`using Base::f;` 或正确写 `void f() override;`

---

### 1️⃣6️⃣【语言机制题】

`override` 关键字解决了什么问题？  
它在**编译期**还是**运行期**起作用？

**答案：解决“你以为重写但没重写”的错误；编译期。**  
**解析：**`override` 要求编译器检查：是否存在可重写的虚函数匹配签名；不匹配直接报错。

---

### 1️⃣7️⃣【对象模型题】

一个类只要**有一个虚函数**，通常就会多出一个成员。  
这个成员是什么？它大致起什么作用？
**答案：vptr（虚表指针）。**  
**解析：**

- 对象中存一个指针，指向该动态类型对应的 vtable。
    
- 通过 vtable 找到虚函数实现。  
    **注意：**标准不强制具体实现，但主流 ABI 基本如此。
**流程如下：**

```C++
class Base {
public:
    virtual void func1() { ... } // 虚函数 1
    virtual void func2() { ... } // 虚函数 2
};

class Derived : public Base {
public:
    // 重写了 func1
    void func1() override { ... } 
    // 没重写 func2，沿用父类的
};

int main() {
    Derived d;
    Base* ptr = &d;  // 父类指针指向子类对象
    
    ptr->func1();    // 👈 我们要分析就是这一行！
}
```

下面是详细的微观步骤拆解：

---

### 第一阶段：准备工作 (编译期 & 构造期)

在程序运行这行代码之前，内存里已经准备好了两样东西：

1. **虚函数表 (vtable) - 位于只读数据段**
    
    - 编译器为 `Derived` 类生成了一张表（数组），里面存着函数指针。
        
    - `Derived vtable[0]` = `&Derived::func1` (因为子类重写了，所以填子类的地址)
        
    - `Derived vtable[1]` = `&Base::func2` (因为子类没重写，所以填父类的地址)
        
2. **虚函数指针 (vptr) - 位于对象内存头部**
    
    - 当你执行 `Derived d;` 构造对象时，`Derived` 的构造函数悄悄执行了一步操作：
        
    - `this->vptr = &Derived_vtable;`
        
    - 它将对象的隐藏指针 `vptr` 指向了上面那张表。
        

---

### 第二阶段：调用过程 (运行时 Run-time)

当 CPU 执行到 `ptr->func1()` 这一行时，它并没有直接跳去执行函数，而是不得不完成一套**“四步跳”**动作。

为了方便理解，假设：

- 对象 `d` 的地址是 `0x1000`。
    
- `vptr` 存放在对象的开头（偏移量 0）。
    

#### 步骤 1：通过指针找到对象 (Dereference Object)

CPU 首先通过 `ptr` 找到内存中的对象。

> _汇编逻辑：_ 拿到地址 `0x1000`。

#### 步骤 2：取出虚指针 (Load vptr)

CPU 读取对象内存的前 8 个字节（64位系统），也就是 `vptr` 的值。

> _汇编逻辑：_ `MOV RAX, [0x1000]` _结果：_ 此时寄存器 `RAX` 里装的是 **Derived vtable 的地址** (比如 `0x8888`)。 _注意：_ 这一步的关键在于，虽然 `ptr` 是 `Base*` 类型，但它指向的内存里存的是 `Derived` 的 vptr，所以拿到的是子类的表。

#### 步骤 3：计算偏移量，查表 (Offset & Fetch)

编译器在编译时就知道 `func1()` 是类中的**第 1 个**虚函数。所以它会去表中取第 0 项。

> _汇编逻辑：_ `MOV RBX, [RAX + 0]` （如果是 func2 则是 `[RAX + 8]`） _结果：_ 此时寄存器 `RBX` 里装的就是 **`Derived::func1` 的真实函数地址** (比如 `0xCODE`)。

#### 步骤 4：跳转执行 (Indirect Call)

万事俱备，CPU 直接跳转到该地址执行代码。

> _汇编逻辑：_ `CALL RBX`


---

### 1️⃣8️⃣【设计题】

为什么“接口类”通常只包含：

- 纯虚函数
    
- 虚析构函数
    
- 没有数据成员？
    
**答案要点：**

- 只表达行为，不携带状态（降低耦合）。
    
- 纯虚函数强制派生实现。
    
- 虚析构保证多态删除安全。
    
- 无数据成员减少布局/二义性，利于稳定 ABI。
---

# 四、继承中的拷贝 / 析构 / Rule of 5（19–23）

### 1️⃣9️⃣【推理题】

派生类对象拷贝时：

- 基类子对象如何被拷贝？
    
- 拷贝顺序是怎样的？
    
**答案：**

- 先拷贝构造（或赋值）基类子对象，再拷贝派生部分。
    
- 顺序与构造/析构一致：**基类 → 派生**（析构相反）。  
    **原因：**基类子对象是派生对象的一部分，必须先建立。
**例子：**
```C++
#include <iostream>
#include <string>

class Base {
public:
    Base(int val) : b_val(val) {}

    // 基类拷贝构造函数
    Base(const Base& other) : b_val(other.b_val) {
        std::cout << "Base 拷贝构造完成" << std::endl;
    }

private:
    int b_val;
};

class Derived : public Base {
public:
    // 关键点：必须在初始化列表中将 other 传给 Base
    Derived(const Derived& other) 
        : Base(other),  // 1. 先拷贝基类子对象（这里发生了向上转型）
          d_val(other.d_val) // 2. 再拷贝派生类成员
    {
        std::cout << "Derived 拷贝构造完成" << std::endl;
    }

    Derived(int b, int d) : Base(b), d_val(d) {}

private:
    int d_val;
};

int main() {
    Derived d1(10, 20);
    std::cout << "--- 开始拷贝 ---" << std::endl;
    Derived d2 = d1; 
    return 0;
}
```

 2. **赋值运算符 (`operator=`) 的情况**

对于赋值操作，逻辑是一样的，但语法不同。你需要在派生类的赋值函数中手动调用基类的赋值函数：

```C++
Derived& operator=(const Derived& other) {
    if (this != &other) {
        Base::operator=(other); // 手动调用基类赋值
        this->d_val = other.d_val;
    }
    return *this;
}
```

---

### 2️⃣0️⃣【判断题】

如果基类拷贝构造被 `delete`，派生类还能有默认拷贝构造。  
对还是错？为什么？
**答案：不能。**  
**解析：**  
默认生成的派生拷贝构造需要调用基类拷贝构造；基类不可拷贝 → 派生默认拷贝也被隐式删除。  
**工程建议：**不可拷贝的基类常用于资源/互斥等语义。

---

### 2️⃣1️⃣【推理题】

```C++
struct Base {
    ~Base() {}
};

struct Derived : Base {
    int* p;
    ~Derived() { delete p; }
};
```

通过 `Base*` 删除 `Derived` 对象会发生什么问题？
**答案：通过 `Base*` delete `Derived` 是 UB（至少派生析构不调用）。**  
**解析：**派生析构不执行 → `p` 泄漏；更糟时破坏运行时。  
**修复：**`virtual ~Base() = default;`

---

### 2️⃣2️⃣【设计题】

在“拥有资源”的派生类中，你是否应该：

- 让基类析构函数为 `virtual`？
    
- 让基类支持拷贝？
    

请说明理由。
**答案：**

- **要 virtual 析构**（只要可能通过基类指针管理对象）。
    
- 基类是否可拷贝取决于语义：
    
    - 若基类表示“可复制的值语义接口” → 需要拷贝/clone
        
    - 若表示“独占资源/句柄语义” → 通常不可拷贝，只可移动  
        **工程建议：**多态基类通常提供 `virtual std::unique_ptr<Base> clone() const = 0;` 来表达可复制语义。
---

### 2️⃣3️⃣【思考题】

为什么**组合（has-a）**往往比**继承（is-a）**更安全？  
请至少给出 **2 个工程级理由**。
**参考答案：**

1. 组合耦合更低：不会把基类接口“强行暴露”给外部（避免 LSP 破坏）。
    
2. 避免脆弱基类问题：基类改动可能破坏派生类行为/ABI。
    
3. 更易控制对象生命周期与资源：继承容易踩到非虚析构、切片等坑。
    
4. 可替换性更强：组合可随时换实现对象，不受继承层次限制。
---

# 五、多重继承与虚继承（24–25）

### 2️⃣4️⃣【推理题】

```C++
struct A { int x; };
struct B : A {};
struct C : A {};
struct D : B, C {};
```

`D` 中有几份 `A`？  
如何只保留一份？代价是什么？
- `D` 中有 **两份 `A`**（一份来自 B，一份来自 C）。
    
- 用 **虚继承**：`struct B : virtual A {}; struct C : virtual A {};`
    
- 代价：对象布局更复杂，访问虚基类通常需要额外偏移/指针，`sizeof` 增大、构造顺序更复杂。
---

### 2️⃣5️⃣【判断 + 解释】

虚继承主要解决的是“菱形继承”中的**二义性问题**。  
是否完整？还有什么额外影响？
**答案：不完整。**  
**解析：**  
它解决：

- 重复的虚基类子对象（共享一份）
    
- 由此带来的成员访问二义性  
    同时带来：
    
- 布局/性能开销
    
- 构造责任变化：**最派生类**负责构造虚基类部分
---

# 六、编程题（26–30）⭐

---

## 2️⃣6️⃣【编程题】基础继承与构造顺序

写一个程序，验证：

- 基类构造 / 析构
    
- 派生类构造 / 析构
    

的**执行顺序**。

👉 要求：

- 用 `std::cout` 打印
    
- 至少一个基类，一个派生类
    
```C++
class Base{
public:
	Base(){
		std::cout<<"基类构造"<<std::endl;
	}
	~Base(){
		std::cout<<"基类析构"<<std::endl;
	}
};

class Derived : public Base{
public:
	Derived(){
		std::cout<<“派生类构造”<<std::endl;
	}
	~Derived(){
		std::cout<<"派生类析构"<<std::endl;
	}
};

int main(){
	Derived d;
	Base *b=&d;
	return 0;
}
```
---

## 2️⃣7️⃣【编程题】虚析构的必要性

写一个程序：

- 基类析构函数 **不加 `virtual`**
    
- 派生类在析构中释放资源
    

通过 `Base*` 删除 `Derived`，观察并解释结果。
```C++
#include <iostream>

struct Base {
    // 注意：非 virtual
    ~Base() { std::cout << "Base dtor\n"; }
};

struct Derived : Base {
    int* p = new int[10];
    ~Derived() {
        std::cout << "Derived dtor (free p)\n";
        delete[] p;
    }
};

int main() {
    Base* b = new Derived();
    delete b; // UB：通常只调用 Base dtor
}
```
**现象：**

- 常见输出只有 `Base dtor`
    
- `Derived` 析构没执行，资源没释放（并且行为是 UB，不保证稳定表现）
---

## 2️⃣8️⃣【编程题】函数隐藏 vs 重写

写一段代码，展示：

- 派生类定义同名但不同参数的函数
    
- 导致基类函数被隐藏
    

然后用一种方式修复这个问题。
```C++
#include <iostream>

struct Base {
    void f() { std::cout << "Base::f()\n"; }
    void f(int) { std::cout << "Base::f(int)\n"; }
};

struct Derived : Base {
    void f(double) { std::cout << "Derived::f(double)\n"; } // 隐藏 Base::f 整组
};

int main() {
    Derived d;
    // d.f();      // ❌ 编译失败：Base::f 被隐藏
    // d.f(1);     // ❌ 编译失败：Base::f(int) 也被隐藏
    d.f(1.0);      // ✅
}
```

**修复方式 1（推荐）：**

```C++
struct Derived : Base {
    using Base::f;          // 把基类同名函数集合引入作用域
    void f(double) { std::cout << "Derived::f(double)\n"; }
};
```

**修复方式 2：**  
显式调用：`d.Base::f();`

---

## 2️⃣9️⃣【编程题】多态调用验证

写一个基类 `Shape`，派生类 `Circle / Rectangle`：

- 使用虚函数 `area()`
    
- 通过 `Shape*` 容器调用不同实现
    
```C++
#include <iostream>
#include <vector>
#include <memory>

struct Shape {
    virtual ~Shape() = default;
    virtual double area() const = 0;
};

struct Circle:Shape{
	double r;
	explicit Circle(double val):r(val){}
	double area() const override{
		return 3.1415926*r*2;
	}
};
struct Rectangle : Shape {
	double w,h;
	explicit Rectangle(double x,double y): w(x),h(y){}
	double area() const override{
		return w*h;
	}
};

int main(){
	std::vector<std::unique_ptr<Shape>> shapes;
	shapes.emplace_back(std::make_unique<Shape>(2));
	shapes.emplace_back(std::make_unique<Shape>(2,3));
	
	for(auto c:v){
		//c.get()->area();unique_ptr重载了->与*，这样使用起来和普通指针无异
		std::cout<<c->area()<<std::endl;
	}

	return 0;
}
```
---

## 3️⃣0️⃣【编程题】禁止拷贝的基类设计

设计一个基类：

- 禁止拷贝
    
- 允许派生类被移动
    
- 基类析构函数为 `virtual`
    

并写一个简单派生类验证设计是否合理。
```C++
#include <iostream>
#include <utility>

struct NonCopyableBase {
    NonCopyableBase() = default;
    virtual ~NonCopyableBase() = default;

    NonCopyableBase(const NonCopyableBase&) = delete;
    NonCopyableBase& operator=(const NonCopyableBase&) = delete;

    NonCopyableBase(NonCopyableBase&&) noexcept = default;
    NonCopyableBase& operator=(NonCopyableBase&&) noexcept = default;
};

struct Derived : NonCopyableBase {
    int* p = nullptr;

    explicit Derived(int n) : p(new int[n]) {}

    ~Derived() override {
        delete[] p;
        std::cout << "Derived dtor\n";
    }

    // 移动：夺取资源
    Derived(Derived&& other) noexcept
        : NonCopyableBase(std::move(other)), p(other.p) {
        other.p = nullptr;
    }

    Derived& operator=(Derived&& other) noexcept {
        if (this != &other) {
            NonCopyableBase::operator=(std::move(other));
            delete[] p;
            p = other.p;
            other.p = nullptr;
        }
        return *this;
    }
};

int main() {
    Derived a(10);
    // Derived b = a; // ❌ 拷贝被禁止
    Derived c = std::move(a); // ✅ 移动
}
```
---

## 🎯 使用建议（很重要）

刷这 30 题时，你可以按三轮来：

1. **第一轮**：只回答“会发生什么”
    
2. **第二轮**：回答“为什么语言这么设计”
    
3. **第三轮（编程题）**：用代码验证你自己的推理