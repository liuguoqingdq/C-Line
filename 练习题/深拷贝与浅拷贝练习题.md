# 一、拷贝触发机制与默认行为（1–4）

### 1️⃣【推理题】

下面代码中，一共发生了**几次拷贝构造 / 拷贝赋值**？分别在哪些语句发生？

```C++
struct A {
    A() = default;
    A(const A&) { std::cout << "copy\n"; }
    A& operator=(const A&) {
        std::cout << "assign\n";
        return *this;
    }
};

int main() {
    A a;
    A b = a;
    A c(a);
    b = c;
}
```

👉 要求：逐行分析触发点。
### ✅ 结论

- 拷贝构造：**2 次**
    
- 拷贝赋值：**1 次**
    

### 🧠 推理

|语句|触发|
|---|---|
|`A a;`|默认构造|
|`A b = a;`|**拷贝构造**|
|`A c(a);`|**拷贝构造**|
|`b = c;`|**拷贝赋值**|

### 🏗 工程视角

- `=` 出现在**定义语句中** → 拷贝构造
    
- `=` 出现在**对象已存在** → 拷贝赋值  
    这是面试里**必考的基础判断点**
---

### 2️⃣【判断 + 解释】

下面这个类，**编译器生成的默认拷贝构造是否安全？**

```C++
struct X {
    int* p;
};
```

你的结论需要区分：

- **“能不能编译”**
    
- **“是不是语义安全”**
    
### ✅ 结论

- ✅ **能编译**
    
- ❌ **语义不安全**
    

### 🧠 推理

默认拷贝只会做：

`p = other.p;`

两个对象指向**同一块内存**，如果有析构释放资源 → double free。

### 🏗 工程视角

**“能编译 ≠ 能上线”**  
这是 C++ 最危险的陷阱之一，也是 RAII 设计的出发点。

---

### 3️⃣【推理题】

假设：

```C++
struct Foo {
    int x;
    std::string s;
};
```

对 `Foo` 使用默认拷贝构造，  
这是**浅拷贝还是深拷贝**？为什么不能简单用“有没有指针成员”来判断？
### ✅ 结论

**对用户来说是“深拷贝”**

### 🧠 推理

- `int`：值拷贝
    
- `std::string`：**自己实现了深拷贝**
    
- 所以 `Foo` 的默认拷贝会调用 `string` 的拷贝构造
    

### 🏗 工程视角

**不要用“有没有指针成员”来判断深浅**  
而是问：

> 成员类型是否 **自己正确管理了资源**

---

### 4️⃣【思考题】

为什么说：

> “默认拷贝 = 成员逐个拷贝”  
> 是一个**语义描述**，而不是“浅拷贝/深拷贝”的绝对定义？

### ✅ 结论

“成员逐个拷贝”是**语义描述**，不是安全保证。

### 🧠 推理

- 对 `int` → 深拷贝
    
- 对 `string` → 深拷贝（内部指针）
    
- 对 `int*` → 浅拷贝（地址）
    
### 🏗 工程视角

**深/浅拷贝是“资源语义”，不是语法概念**

---

# 二、浅拷贝的真实风险（5–7）

### 5️⃣【推理题】

下面代码是否一定会产生 **double free**？如果是，发生在什么时候？

```C++
struct Buffer {
    int* data;
    Buffer(int n) : data(new int[n]) {}
    ~Buffer() { delete[] data; }
};

int main() {
    Buffer a(10);
    Buffer b = a;
}
```

👉 请从 **对象生命周期顺序** 角度解释。
### ✅ 结论

**一定会（程序结束时）**

### 🧠 推理

销毁顺序（逆序）：

1. `b` 析构 → `delete[] data`
    
2. `a` 析构 → 再 `delete[] data`（同一块）
    

### 🏗 工程视角

这是**最经典的“默认拷贝 + 析构”组合炸弹**

---

### 6️⃣【反例题】

有没有可能出现 **浅拷贝但不出 bug** 的场景？  
请给出一个**合理的设计前提**，说明为什么在这个前提下浅拷贝是“可接受的”。
### ✅ 结论

当**资源不由对象负责释放**时。

### 🧠 合理前提示例

```C++
struct View {    
 const int* data;   // 只读视图 
};

int arr[10]{};
View v{arr};//资源的所有权不在view上，不由view来析构
View v2=v;
```

### 🏗 工程视角

- 非 owning pointer
    
- 借用（borrowed view）
    
- 生命周期由外部保证
    

👉 STL 里大量存在这种设计（`string_view`, span）

---

### 7️⃣【工程判断题】

如果一个类内部持有的是：

- `int*`
    
- `FILE*`
    
- `std::unique_ptr<int>`
    
- `std::shared_ptr<int>`
    

哪些 **默认拷贝是危险的**？哪些是**被类型本身“拦住”或“语义上允许”的**？说明原因。

|成员|默认拷贝|原因|
|---|---|---|
|`int*`|❌ 危险|owning 原始指针|
|`FILE*`|❌ 危险|双重 fclose|
|`unique_ptr`|❌ 不允许|编译期禁止|
|`shared_ptr`|✅ 安全|引用计数|

### 🏗 工程视角

**类型系统是否帮你兜底**，是设计好坏的分水岭。

---

# 三、深拷贝实现与异常安全（8–11）

### 8️⃣【代码推理题】

下面这个深拷贝赋值实现有什么问题？

```C++
Buffer& operator=(const Buffer& other) {
    delete[] data;
    size = other.size;
    data = new int[size];
    std::copy(other.data, other.data + size, data);
    return *this;
}
```

👉 提示：从 **异常安全** 和 **自赋值** 两个角度思考。
**答：**
### ❌ 问题

1. **异常安全**：`new` 抛异常 → 对象已被破坏
    
2. **自赋值**：`a = a` → 先 delete 自己的数据
    

### 🏗 工程视角

拷贝赋值至少要满足 **基本异常安全保证**

---

### 9️⃣【改进题】

请说明 **“拷贝-交换（copy-and-swap）”** 为什么能同时解决：

- 自赋值问题
    
- 拷贝赋值的异常安全问题
不要求写代码，但要讲清楚“顺序”和“所有权变化”。
### ✅ 结论

**一次性解决自赋值 + 异常安全**

### 🧠 思路

1. 用拷贝构造生成临时对象（失败不影响自己）
    
2. swap 内部指针
    
3. 临时对象析构，释放旧资源
### 🏗 工程视角

这是**教科书级别的强异常安全写法**
```C++
#include <iostream>
#include <algorithm> // for std::swap
#include <vector>

class MyBuffer {
private:
    int* data;
    size_t size;

public:
    // 1. 普通构造函数
    MyBuffer(size_t s) : size(s), data(new int[s]) {
        std::cout << "Constructing: " << size << std::endl;
    }

    // 2. 析构函数
    ~MyBuffer() {
        delete[] data; 
        // 这里的打印是为了让你看到旧资源是在何时被释放的
        if (size > 0) std::cout << "Destroying buffer of size: " << size << std::endl;
    }

    // 3. 拷贝构造函数 (Copy Constructor)
    // 这是 "Copy" 发生的地方，可能抛出异常 (std::bad_alloc)
    MyBuffer(const MyBuffer& other) : size(other.size), data(new int[other.size]) {
        std::copy(other.data, other.data + other.size, data);
        std::cout << "Copy Constructing" << std::endl;
    }

    // 4. Move 构造函数 (C++11, 性能优化必须有)
    MyBuffer(MyBuffer&& other) noexcept : MyBuffer(0) {
        swap(*this, other);
    }

    // ==========================================
    // ⭐ 核心逻辑：自定义 swap 函数
    // ==========================================
    // 必须保证是 noexcept，绝不能抛出异常
    friend void swap(MyBuffer& first, MyBuffer& second) noexcept {
        using std::swap; 
        // 交换所有成员变量
        swap(first.size, second.size);
        swap(first.data, second.data); 
    }

    // ==========================================
    // ⭐ 核心逻辑：赋值运算符 (Copy-and-Swap)
    // ==========================================
    // 注意：参数是【传值 (by value)】，而不是引用！
    // 这会自动调用拷贝构造函数（或移动构造），生成一个临时对象 'other'
    MyBuffer& operator=(MyBuffer other) {
        // 此时 'other' 是右边对象的一个副本（全新的资源）
        
        // 交换我现有的（旧）资源和 'other' 的（新）资源
        swap(*this, other);
        
        // 函数结束时：
        // 1. *this 拿到了新资源。
        // 2. 'other' 手里拿着旧资源。
        // 3. 'other' 离开作用域析构，顺带把我的旧资源释放了。
        
        return *this;
    }
};

int main() {
    MyBuffer a(10);
    MyBuffer b(20);

    std::cout << "--- 开始赋值 ---" << std::endl;
    // 赋值发生：
    // 1. b 被拷贝一份生成临时对象 (temp)
    // 2. a 和 temp 交换数据
    // 3. temp 带着 a 的旧数据析构
    a = b; 
    std::cout << "--- 赋值结束 ---" << std::endl;

    return 0;
}
```
---

### 🔟【判断 + 解释】

下面类只实现了析构函数，没有显式写拷贝构造/赋值：

```C++
struct Buffer {
    int* data;
    Buffer(int n) : data(new int[n]) {}
    ~Buffer() { delete[] data; }
};
```

是否违反了 Rule of 5？  
**为什么“只写析构”在现代 C++ 中往往是一个危险信号？**
### ✅ 结论

**是的，非常危险**

### 🧠 原因

- 你声明析构 → 表示你在管理资源
    
- 但你却让编译器生成浅拷贝 → double free
---

### 1️⃣1️⃣【工程设计题】

如果你负责设计一个 `Buffer` 类，下面三种策略你会在什么情况下选择？说明理由：

1. 禁止拷贝，只允许移动
    
2. 支持深拷贝 + 移动
    
3. 使用 `shared_ptr` 让拷贝变成“共享”
    
|策略|适用场景|
|---|---|
|禁拷贝，仅移动|socket / mutex / file|
|深拷贝 + 移动|buffer / image / string|
|shared_ptr|显式共享语义|

### 🏗 工程视角

**拷贝语义 = 所有权语义**

---

# 四、STL、深拷贝与“看起来像值语义”的本质（12–13）

### 1️⃣2️⃣【推理题】

为什么我们说：

```C++
std::vector<int> v2 = v1;
```

对用户来说是“深拷贝”，  
但对 `vector` 的实现者来说，它**内部仍然是指针 + 堆内存**？

👉 这个问题在考：**抽象边界**。
### ✅ 结论

因为 **vector 对资源负责**

### 🧠 推理

- 内部确实有指针
    
- 但拷贝构造会重新分配内存并复制元素
    

### 🏗 工程视角

**抽象的意义：隐藏资源管理细节**

---

### 1️⃣3️⃣【对比题】

下面两段代码，在“拷贝语义”上有什么**本质区别**？

```C++
struct A {
    int* p;
};

struct B {
    std::vector<int> v;
};
```

假设都使用默认拷贝。  
为什么一个危险，一个安全？
### ✅ 结论

- A：裸 owning pointer → 浅拷贝炸
    
- B：RAII 类型 → 安全
    

### 🏗 工程视角

**“不要自己管理内存，除非你真的必须”**

---

# 五、深拷贝 × 移动 × Rule of 5（14–15）

### 1️⃣4️⃣【推理题】

在你给出的 `Buffer` 最终版本中：

```C++
Buffer(Buffer&& other) noexcept;
Buffer& operator=(Buffer&& other) noexcept;
```

为什么 **必须**把移动构造/赋值写成 `noexcept`？  
如果不写，在 STL 容器中会发生什么变化？
**答：**
移动构造或者拷贝会释放掉参数对象，如果中途抛异常，可能会让对象半死不活
### ✅ 结论

否则 STL 容器可能 **放弃移动，退回拷贝**
### 🧠 推理

vector 扩容时：
- move noexcept → 用 move
    
- move 可能抛 → 用 copy 保证异常安全
### 🏗 工程视角

**性能不是“有没有 move”，而是“move 是否 noexcept”**

---

### 1️⃣5️⃣【综合设计题（难）】

你在写一个资源类 `FileBuffer`，内部持有文件句柄 + 内存缓冲区。

请你回答（不要求代码）：

1. 哪些拷贝/移动操作你会 **删除（= delete）**？
    
2. 哪些你会实现？
    
3. 哪些你会标记为 `noexcept`？
    
4. 为什么这是一个符合 **RAII + Rule of 5 + 性能** 的设计？
    
### ✅ 推荐答案（工程级）

1. **删除拷贝**
    
    `FileBuffer(const FileBuffer&) = delete;`
    
2. **允许移动**
    
3. **移动构造 / 赋值 noexcept**
    
4. **析构关闭文件 + 释放内存**
    

### 🏗 工程视角

- 文件句柄是**唯一资源**
    
- 拷贝语义不合理
    
- 移动语义天然匹配 RAII

---

## 🧠 建议你怎么用这 15 题

强烈建议你这样刷：

1. **先不写代码，只写“发生了什么”**
    
2. 用一句话回答：“这是值语义 / 所有权语义 / 共享语义？”
    
3. 再决定：**默认拷贝够不够？要不要禁？要不要深？**