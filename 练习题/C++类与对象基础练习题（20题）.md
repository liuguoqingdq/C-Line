以下练习题基于 **C++ 类（class）基础、访问控制、构造/析构函数、对象与生命周期、RAII** 等内容设计，难度从入门到进阶循序渐进。

---

## 一、基础理解题（1–6）

### 1. 类型与对象
下面代码中，哪些是“类型”，哪些是“对象”？请说明理由。

```cpp
class Point {
public:
    int x;
    int y;
};

Point p1;
Point p2;
```
- **答**：**Piont是类型** p1，**p2是对象**

---

### 2. 成员访问合法性
下面哪些语句可以通过编译？哪些不可以？为什么？

```cpp
class A {
    int x;
public:
    int y;
};

int main() {
    A a;
    a.x = 1;
    a.y = 2;
}
```
-  **答：a.x=1不能通过编译**
 **原因**
- `x` 是 **private（默认）**
    
- `private` 成员只能在 **类内部 / 友元** 访问
    
- `main()` 是“外部代码”
    

👉 **private 是“对外不可见”，不是“对象不可见”**

---

### 3. class 与 struct 的区别
不修改下面代码逻辑，仅通过 **class / struct** 的选择，让程序可以成功编译。

```cpp
___ Data {
    int value;
};

int main() {
    Data d;
    d.value = 10;
}
```
- **答：struct**
 **原因**
- `struct` 默认成员是 `public`
    
- `class` 默认成员是 `private`

---

### 4. 成员函数的调用
给定下面类，写出调用 `move` 后 `p` 中 `x`、`y` 的最终值。

```cpp
class Point {
public:
    int x = 1;
    int y = 2;
    void move(int dx, int dy) {
        x += dx;
        y += dy;
    }
};

Point p;
p.move(3, -1);
```
- **答：x=4，y=1**

---

### 5. const 成员函数理解
下面代码中，`print()` 为什么要加 `const`？如果不加会发生什么？

```cpp
class A {
public:
    void print() const {
        std::cout << x;
    }
private:
    int x = 10;
};
```
- **答：防止修改x，如果不加x值可能会变**

**本质含义**
> **这个函数不会修改对象状态**

等价于（概念上）：

```C++
void print(const A* this);
```

**如果不加** `const`

- ❌ **不能被 `const A` 对象调用**
    
- ❌ 破坏接口的“只读承诺”
    

```C++
void foo(const A& a) {     
a.print(); // 只有 print() 是 const 才能调用 
}
```

👉 `const` 是 **接口契约的一部分**

---

### 6. 成员变量的封装
为什么推荐把成员变量设为 `private`？请写出至少 **两个理由**。
- **答：设置为private，可以更好的保护变量的值，防止做出非主动的修改**
**** 核心理由（给你 4 点）
1. **保证不变量**
    - 防止非法状态（如 `age < 0`）
        
2. **封装实现**
    - 内部结构可以改，外部代码不受影响
        
3. **可控修改**
    - 统一入口（`setX()` / `inc()`）
        
4. **可维护性**
    - 防止“到处直接改成员”导致 Bug 扩散
        

👉 **public 成员 = 放弃控制权**

---

## 二、访问控制与继承（7–11）

### 7. private 访问失败分析
说明下面代码为什么编译失败，并给出 **一种合法的修改方式**。

```cpp
class Person {
private:
    int age;
};

int main() {
    Person p;
    p.age = 18;
}
```
- **答：age是私有变量，不能在外直接访问可以修改代码：**
```C++
class Person {
public:
	void set_age(int a){
		this.age = a;
	}
private:
    int age;
};

int main() {
    Person p;
    p.set_age(18);
}
```

---

### 8. protected 的作用
阅读代码并回答问题：

```cpp
class Base {
protected:
    int value;
};

class Derived : public Base {
public:
    void set(int v) { value = v; }
};
```

1. `Derived::set` 中为什么可以访问 `value`？  
2. `main()` 中是否可以直接访问 `value`？为什么？

**问题** 1
**为什么 `Derived::set` 可以访问 `value`？**

- `protected`：**类内部 + 派生类内部可访问**

**问题** 2
**`main()` 能否访问？**

❌ 不能  
因为 `main()` 既不是 `Base`，也不是 `Derived`

👉 `protected` 是“**留给子类用的 private**”

---

### 9. 默认访问权限
判断下面代码中 `x` 和 `y` 的访问权限。

```cpp
class A {
    int x;
};

struct B {
    int y;
};
```
- **答：x是private，y是public**

---

### 10. 接口设计题
请设计一个 `Counter` 类：

- 内部计数值不能被外部直接修改；
- 提供 `inc()` 和 `get()` 两个 `public` 接口。

只需写出类定义。
```C++
class Counter{
	public:
	void inc(){count++;};
	int get(){return count;};
	private:
	int count=0;
};
```

---

### 11. 不当 public 的风险
下面设计有什么问题？可能带来什么后果？

```cpp
class User {
public:
    int age;
};
```
- **答：age被设置为公有类型，任何人都可以访问和修改**
---

## 三、构造函数（12–16）

### 12. 构造函数调用
下面代码中，构造函数被调用了几次？

```cpp
class A {
public:
    A() { std::cout << "A"; }
};

int main() {
    A a1;
    A a2;
}
```
- **答：2次**
---

### 13. 缺失默认构造的错误
说明下面代码为什么无法编译。

```cpp
class Point {
public:
    Point(int x, int y) {}
};

int main() {
    Point p;
}
```
- **答：没有声明无参数构造，却使用了无参数构造**
---

### 14. 初始化列表 vs 赋值
下面两种写法有什么区别？哪一种更推荐？为什么？

```cpp
class A {
public:
    A(int v) {
        x = v;
    }
private:
    int x;
};
```

```cpp
class A {
public:
    A(int v) : x(v) {}
private:
    int x;
};
```
- **答：下面是初始化列表，更推荐下面的**
### 区别

- 赋值：**先默认构造，再赋值**
    
- 初始化列表：**直接构造**
原因：

- 更高效
    
- 必须用于 `const` / 引用成员
    
- 语义正确
---

### 15. 成员初始化顺序
下面代码中，`x` 和 `y` 的初始化顺序是什么？

```cpp
class Test {
public:
    Test() : y(2), x(1) {}
private:
    int x;
    int y;
};
```
- **答：初始化顺序是x,y，初始化列表的顺序不影响，取决于声明的顺序**

---

### 16. 构造函数重载
为 `Point` 类补全 **三个构造函数**：

- 无参构造：`(0,0)`  
- 一个参数：`(v,v)`  
- 两个参数：`(x,y)`

- **答：**
```C++
class Point{
public:
Point(){}
Point(int v): a(v),b(v){}
Point(int x,int y): a(x),b(y){}
private:
int a,b;
};
```

---

## 四、析构函数与生命周期（17–20）

### 17. 析构函数调用时机
下面代码中，析构函数在什么时候被调用？

```cpp
class A {
public:
    ~A() { std::cout << "~A"; }
};

int main() {
    A a;
    std::cout << "main";
}
```
- **答：在主函数的末尾**
先输出：main   再输出：～A。
---

### 18. 作用域与对象生命周期
请写出下面程序的输出顺序。

```cpp
class A {
public:
    A() { std::cout << "A"; }
    ~A() { std::cout << "~A"; }
};

int main() {
    {
        A a;
    }
    std::cout << "X";
}
```
- **答：A～AX**

---

### 19. RAII 理解题
说明为什么下面写法是 **RAII 风格**，以及它解决了什么问题。

```cpp
class File {
public:
    File(const std::string& path) {
        // open
    }
    ~File() {
        // close
    }
};
```
### RAII 本质

- 资源 **绑定到对象生命周期**
    
- 构造 = 获取资源
    
- 析构 = 释放资源
### 解决的问题

- 忘记 `close()`
    
- 异常提前返回
    
- 多出口函数资源泄漏

👉 **RAII = 异常安全的基础**

---

### 20. 析构函数缺失的风险
如果一个类 **管理资源（如文件、锁、内存）** 却没有定义析构函数，可能会导致什么问题？请举一个具体例子。

### 可能问题

- 内存泄漏
    
- 文件句柄泄漏
    
- 死锁
    

### 例子
```C++
class Lock {
    pthread_mutex_t* m;
public:
    Lock() { pthread_mutex_lock(m); }
    // 没有 ~Lock()
};
```
❌ 一旦异常或提前 return，**锁永远不释放**

---

> 建议做题方式：
> - 先不写代码，**先在脑中模拟对象生命周期**；
> - 每题都问自己一句话：**“这个对象什么时候生？什么时候死？”**。

如果你愿意，我可以：
- 给你 **20 题完整标准答案**；
- 或把这些题改成 **面试问答版 / 填空版 / Debug 版**。

