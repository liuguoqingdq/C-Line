## 一、基础概念理解（1–5）

### 1️⃣

用一句话解释：

> **`constexpr` 的核心语义是什么？**  
> 它和“`const`”最大的本质区别是什么？

**答案：**

> `constexpr` 表示：**该变量 / 表达式 / 函数的结果在满足条件时可以在编译期求值，并且用于必须编译期常量的场景。**

**与 `const` 的本质区别：**
- `const`：**只读语义**，不保证是编译期常量
    
- `constexpr`：**编译期常量语义**，初始化必须是常量表达式
👉 **一句话区分：**

> `const` 管“能不能改”，`constexpr` 管“能不能在编译期算”。
---

### 2️⃣

判断正误并说明理由：

> **`constexpr` 修饰的函数，所有调用都一定发生在编译期。**

**解析：**

- `constexpr` 函数只是**允许**在编译期执行
    
- 是否真的在编译期执行，取决于：
    
    - 实参是否是常量表达式
        
    - 调用点是否需要编译期结果
```C++
constexpr int f(int x) { return x * 2; }

constexpr int a = f(3); // 编译期
int b = 10;
int c = f(b);           // 运行期
```
---

### 3️⃣

下面这段代码中，哪些值**一定**在编译期确定？哪些可能在运行期？

```C++
constexpr int add(int a, int b) {
    return a + b;
}

constexpr int x = add(1, 2);
int y = 10;
int z = add(x, y);
```
**答案：**

- `x`：✅ **一定是编译期**
    
- `z`：❌ **一定是运行期**
    

**原因：**

- `x` 的所有参数都是常量表达式
    
- `y` 是运行期变量 → 整个调用退化为普通函数调用
---

### 4️⃣

为什么说：

```C++
constexpr int a = 1;
```

在语义上**不完全等价**于：

```C++
const int a = 1;
```
**答案：**

|项目|`const int a = 1`|`constexpr int a = 1`|
|---|---|---|
|是否只读|✅|✅|
|是否保证编译期常量|❌|✅|
|能否用于数组大小 / 模板参数|❌ 不保证|✅ 保证|

**关键点：**

> `constexpr` 是对“**求值时机**”的约束，而不是只读修饰。
---

### 5️⃣

以下说法中，哪些是正确的？（可多选）

A. `constexpr` 变量一定是只读的  
B. `constexpr` 变量一定是编译期常量  
C. `const` 变量一定是编译期常量  
D. `constexpr` 函数一定在编译期执行

**正确答案：A、B**

---

## 二、`const` vs `constexpr`（6–9）

### 6️⃣

分析下面代码的合法性，并说明原因（**从 C++ 标准角度**）：

```C++
int n = 10;
const int c1 = n;
int arr[c1];
```
**答案：❌ 标准 C++ 不合法**

**解析：**

- `c1` 的初始化发生在**运行期**
    
- C++ 标准要求数组大小是**常量表达式**
    
- GCC / Clang 可能允许（VLA 扩展），但**不是标准行为**
    

⚠️ 面试答法：

> “这是编译器扩展，不是标准 C++”
---

### 7️⃣

为什么下面代码是 **标准 C++ 合法的**？
```C++
constexpr int c2 = 10;
int arr[c2];
```
**答案：**

- `constexpr` 要求初始化表达式必须是**常量表达式**
    
- `c2` 在编译期可知
    
- 满足数组大小的标准要求
---

### 8️⃣

下面哪些变量可以作为**非类型模板参数**？

```C++
int n = 5;
const int a = 6;
constexpr int b = 7;
```

分别判断 `Vec<n>`、`Vec<a>`、`Vec<b>` 是否合法，并说明原因。

| 用法       | 是否合法 | 原因                |
| -------- | ---- | ----------------- |
| `Vec<n>` | ❌    | `n` 不是常量表达式       |
| Vec< a>  | ❌    | `a` 不保证是编译期常量     |
| Vec< b>  | ✅    | `b` 是 `constexpr` |

---

### 9️⃣

下面代码中，`c` 是不是编译期常量？为什么？

```C++
int get();
const int c = get();
```
**答案：❌ 不是**

**原因：**

- `get()` 是运行期函数
    
- `c` 只是“只读变量”，不是常量表达式
---

## 三、`constexpr` 函数（10–13）

### 🔟

判断以下代码在 **C++11 标准**下是否合法，并说明原因：
```C++
constexpr int f(int x) {
    int y = x + 1;
    return y * 2;
}
```
**答案：❌ 不合法（C++11）**

**原因：**

- C++11 要求 `constexpr` 函数体**只能有一条 return**
    
- 不能有局部变量
---

### 1️⃣1️⃣

在 **C++14 及以后**，为什么下面的 `constexpr` 函数是允许的？

```C++
constexpr int factorial(int n) {
    int res = 1;
    for (int i = 2; i <= n; ++i)
        res *= i;
    return res;
}
```
**答案：**

- C++14 放宽限制：
    
    - 允许局部变量
        
    - 允许循环和分支
        
- 只要**整体逻辑可在编译期求值**
---

### 1️⃣2️⃣

下面两次调用中，哪一次**一定**发生在编译期？哪一次**一定不是**？

```C++
constexpr int a = factorial(5);

int n;
std::cin >> n;
int b = factorial(n);
```
**原因：**

- `5` 是常量表达式
    
- `n` 是运行期输入
---

### 1️⃣3️⃣

解释这句话的真实含义（不要照抄）：

> “`constexpr` 函数只是**允许**在编译期求值，并不强制。”

**标准解释版：**

> `constexpr` 函数在满足常量表达式上下文时可被编译期求值，否则退化为普通函数。

**工程理解版：**

> “能提前算就提前算，算不了就运行时算。”
---

## 四、`constexpr` 对象与构造函数（14–16）

### 1️⃣4️⃣

为什么下面的 `Point` 可以在编译期构造对象？

```C++
struct Point {
    int x, y;
    constexpr Point(int a, int b) : x(a), y(b) {}
};
```
**原因：**

- 成员类型都是字面量类型
    
- 构造函数是 `constexpr`
    
- 初始化列表是常量表达式
    
- 没有运行期副作用
---

### 1️⃣5️⃣

如果把 `Point` 的构造函数里的初始化改成：

```C++
x = a;
y = b;
```

还能是 `constexpr` 构造函数吗？为什么？

---

### 1️⃣6️⃣

下面代码中，哪些表达式是**编译期常量表达式**？
```C++
constexpr Point p(1, 2);
int x = 3;
Point q(x, 4);

constexpr int d1 = p.x + p.y;
int d2 = q.x + q.y;
```

---

## 五、`if constexpr`（17–18）

### 1️⃣7️⃣

`if constexpr` 和普通 `if` 的**根本区别**是什么？  
请从 **“未选中分支”** 的角度解释。

---

### 1️⃣8️⃣

为什么下面代码在模板中是安全的？

```C++
template<typename T>
void f(T x) {
    if constexpr (std::is_integral_v<T>) {
        std::cout << x + 1;
    } else {
        x.non_exist_member();  // 看起来非法
    }
}
```

---

## 六、综合理解 & 易错点（19–20）

### 1️⃣9️⃣

下面代码中，哪些地方**容易被误认为是编译期计算，但实际上不是**？
```C++
int n = 10;
const int a = n;
constexpr int b = 20;

int arr1[a];
int arr2[b];
```

---

### 2️⃣0️⃣

总结一句**使用建议**：

> 在什么情况下，应当 **优先使用 `constexpr` 而不是 `const`**？

（要求：不超过两句话，偏工程实践）